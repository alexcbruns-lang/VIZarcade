<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Synthwave</title>
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Share+Tech+Mono&display=swap" rel="stylesheet">
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
html,body{width:100%;height:100%;background:#000;overflow:hidden;font-family:'Share Tech Mono',monospace;color:#fff;cursor:none}
#cur{position:fixed;width:8px;height:8px;border-radius:50%;pointer-events:none;z-index:9999;mix-blend-mode:screen;transition:background 2s}
canvas{position:fixed;top:0;left:0;width:100%;height:100%}
#c0{z-index:1}#c1{z-index:2}#c2{z-index:3}#c3{z-index:4;pointer-events:none}
#login{position:fixed;inset:0;z-index:200;display:flex;flex-direction:column;align-items:center;justify-content:center;background:#000}
#login::before{content:'';position:absolute;inset:0;background:radial-gradient(ellipse 70% 50% at 30% 50%,rgba(6,255,216,0.07) 0%,transparent 60%),radial-gradient(ellipse 50% 40% at 75% 50%,rgba(255,0,110,0.06) 0%,transparent 60%)}
.logo{position:relative;z-index:1;font-family:'Bebas Neue',sans-serif;font-size:clamp(3rem,8vw,7rem);letter-spacing:0.15em;background:linear-gradient(135deg,#06ffd8 0%,#8338ec 50%,#ff006e 100%);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
.tagline{position:relative;z-index:1;font-size:0.7rem;letter-spacing:0.4em;color:rgba(255,255,255,0.3);margin:0.8rem 0 4rem;text-transform:uppercase}
.btn{position:relative;z-index:1;padding:1rem 3rem;font-family:'Bebas Neue',sans-serif;font-size:1.1rem;letter-spacing:0.3em;color:#000;background:#06ffd8;border:none;cursor:pointer;clip-path:polygon(10px 0%,100% 0%,calc(100% - 10px) 100%,0% 100%);transition:all 0.2s}
.btn:hover{background:#fff;box-shadow:0 0 50px rgba(6,255,216,0.5);transform:scale(1.04)}
#loginErr{position:relative;z-index:1;color:#ff006e;font-size:0.62rem;letter-spacing:0.15em;margin-top:1.2rem;max-width:420px;text-align:center;display:none}
.scanlines{position:fixed;inset:0;background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.025) 2px,rgba(0,0,0,0.025) 4px);pointer-events:none;z-index:100}
#ui{position:fixed;z-index:80;inset:0;pointer-events:none;display:none}
#trackName{position:absolute;bottom:2.5rem;left:2.5rem;max-width:50vw;font-family:'Bebas Neue',sans-serif;font-size:clamp(1.2rem,3vw,2.2rem);letter-spacing:0.08em;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-shadow:0 0 40px currentColor;transition:color 3s}
#artistName{position:absolute;bottom:calc(2.5rem + 2.5rem);left:2.5rem;font-size:0.68rem;letter-spacing:0.3em;color:rgba(255,255,255,0.38);text-transform:uppercase}
#sceneTag{position:absolute;top:2rem;left:2.5rem;font-size:0.62rem;letter-spacing:0.3em;color:rgba(255,255,255,0.28);text-transform:uppercase}
#albumArt{position:absolute;bottom:2.5rem;right:2.5rem;width:72px;height:72px;object-fit:cover;opacity:0.55;border:1px solid rgba(255,255,255,0.07)}
#pgWrap{position:absolute;bottom:0;left:0;right:0;height:2px;background:rgba(255,255,255,0.04)}
#pgBar{height:100%;width:0%;transition:width 1s linear}
#splash{position:fixed;inset:0;z-index:90;display:flex;flex-direction:column;align-items:center;justify-content:center;pointer-events:none;opacity:0;transition:opacity 0.8s}
#splash.show{opacity:1}
#splashScene{font-family:'Bebas Neue',sans-serif;font-size:clamp(0.7rem,1.4vw,1rem);letter-spacing:0.6em;color:rgba(255,255,255,0.35);margin-bottom:0.8rem}
#splashTrack{font-family:'Bebas Neue',sans-serif;font-size:clamp(2.5rem,7vw,6.5rem);letter-spacing:0.06em;text-align:center;max-width:90vw;text-shadow:0 0 60px currentColor}
#splashArtist{font-size:clamp(0.8rem,1.8vw,1.1rem);letter-spacing:0.45em;color:rgba(255,255,255,0.4);margin-top:0.8rem;text-transform:uppercase}
#splashDesc{font-size:clamp(0.65rem,1.2vw,0.85rem);font-style:italic;color:rgba(255,255,255,0.22);margin-top:1.5rem;text-align:center;max-width:55vw;line-height:1.8;letter-spacing:0.05em}
#wash{position:fixed;inset:0;z-index:85;opacity:0;pointer-events:none;transition:opacity 1.2s ease}
#surpriseOverlay{position:fixed;inset:0;z-index:75;pointer-events:none;opacity:0}
#comicPanel{position:fixed;inset:0;z-index:76;pointer-events:none;display:none;font-family:'Bebas Neue',sans-serif}
#gameOverScreen{position:fixed;inset:0;z-index:76;pointer-events:none;display:none;align-items:center;justify-content:center;background:#000;font-family:'Bebas Neue',sans-serif;font-size:clamp(4rem,12vw,10rem);letter-spacing:0.2em;color:#f00;text-shadow:0 0 40px #f00}
#fsBtn{position:fixed;bottom:2.5rem;right:calc(72px + 3rem);z-index:85;background:none;border:1px solid rgba(255,255,255,0.1);color:rgba(255,255,255,0.28);font-family:'Share Tech Mono',monospace;font-size:0.6rem;letter-spacing:0.15em;padding:0.4rem 0.7rem;cursor:pointer;transition:all 0.2s;display:none;pointer-events:all}
#fsBtn:hover{border-color:#06ffd8;color:#06ffd8}
</style>
</head>
<body>
<div id="cur"></div>
<div class="scanlines"></div>
<canvas id="c0"></canvas><canvas id="c1"></canvas><canvas id="c2"></canvas><canvas id="c3"></canvas>
<div id="login">
  <div class="logo">SYNTHWAVE</div>
  <div class="tagline">AI Festival Visual Engine</div>
  <button id="loginBtn" class="btn">CONNECT SPOTIFY</button>
  <div id="loginErr"></div>
</div>
<div id="wash"></div>
<div id="surpriseOverlay"></div>
<div id="comicPanel"></div>
<div id="gameOverScreen">GAME OVER</div>
<div id="splash">
  <div id="splashScene"></div>
  <div id="splashTrack"></div>
  <div id="splashArtist"></div>
  <div id="splashDesc"></div>
</div>
<div id="ui">
  <div id="sceneTag">SCENE ENGINE</div>
  <div id="artistName">—</div>
  <div id="trackName">—</div>
  <img id="albumArt" src="" alt=""/>
  <div id="pgWrap"><div id="pgBar"></div></div>
</div>
<button id="fsBtn">⛶ FS</button>
<script>
// ═══ AUTH ═══
const CLIENT_ID='c4a8270f8bc6453490fc8bf4b9de5c42';
const REDIR=location.origin+'/callback';
const SCOPE='user-read-currently-playing user-read-playback-state';
function rnd(n){const a=new Uint8Array(n);crypto.getRandomValues(a);return btoa(String.fromCharCode(...a)).replace(/\+/g,'-').replace(/\//g,'_').replace(/=/g,'').slice(0,n)}
async function sha256b64(s){const d=new TextEncoder().encode(s),h=await crypto.subtle.digest('SHA-256',d);return btoa(String.fromCharCode(...new Uint8Array(h))).replace(/\+/g,'-').replace(/\//g,'_').replace(/=/g,'')}
const ls=(k,v)=>localStorage.setItem(k,v),lg=k=>localStorage.getItem(k);
async function doLogin(){
  const v=rnd(64),c=await sha256b64(v);
  ls('pv',v);
  console.log('[auth] login — redirect_uri='+REDIR);
  location.href='https://accounts.spotify.com/authorize?'+new URLSearchParams({client_id:CLIENT_ID,response_type:'code',redirect_uri:REDIR,scope:SCOPE,code_challenge_method:'S256',code_challenge:c,show_dialog:'true'});
}
async function exchToken(code){
  const v=lg('pv');
  console.log('[auth] exchToken code='+code.slice(0,8)+' verifier='+(v?'ok':'MISSING'));
  if(!v){showErr('Auth error: session data lost. Try again.');return null;}
  const r=await fetch('https://accounts.spotify.com/api/token',{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},body:new URLSearchParams({client_id:CLIENT_ID,grant_type:'authorization_code',code,redirect_uri:REDIR,code_verifier:v})});
  const d=await r.json();
  console.log('[auth] token response:',r.status,Object.keys(d).join(','));
  if(d.access_token){ls('at',d.access_token);ls('ats',Date.now());if(d.refresh_token)ls('rt',d.refresh_token);localStorage.removeItem('pv');return d.access_token;}
  showErr('Spotify error: '+(d.error_description||d.error||'unknown'));
  return null;
}
async function refreshAT(){const rt=lg('rt');if(!rt)return null;const r=await fetch('https://accounts.spotify.com/api/token',{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},body:new URLSearchParams({client_id:CLIENT_ID,grant_type:'refresh_token',refresh_token:rt})});const d=await r.json();if(d.access_token){ls('at',d.access_token);ls('ats',Date.now());return d.access_token}return null}
function getAT(){const t=lg('at'),s=parseInt(lg('ats')||0);return t&&Date.now()-s<3500000?t:null}
function showErr(msg){const el=document.getElementById('loginErr');el.textContent=msg;el.style.display='block';document.getElementById('loginBtn').textContent='TRY AGAIN';}
function logout(){ls('at','');document.getElementById('login').style.display='flex';document.getElementById('ui').style.display='none';document.getElementById('fsBtn').style.display='none';}

// ═══ CANVAS ═══
const c0=document.getElementById('c0'),x0=c0.getContext('2d');
const c1=document.getElementById('c1'),x1=c1.getContext('2d');
const c2=document.getElementById('c2'),x2=c2.getContext('2d');
const c3=document.getElementById('c3'),x3=c3.getContext('2d');
const W=()=>c0.width,H=()=>c0.height;
function resize(){[c0,c1,c2,c3].forEach(c=>{c.width=innerWidth;c.height=innerHeight})}
resize();addEventListener('resize',()=>{resize();if(token)initScene()});
const cur=document.getElementById('cur');
document.addEventListener('mousemove',e=>{cur.style.left=(e.clientX-4)+'px';cur.style.top=(e.clientY-4)+'px'});

// ═══ HELPERS ═══
function lerp(a,b,t){return a+(b-a)*t}
function rndEl(arr){return arr[Math.floor(Math.random()*arr.length)]}
function h2r(h){try{const x=parseInt(h.replace('#','').slice(0,6),16);return{r:(x>>16)&255,g:(x>>8)&255,b:x&255}}catch{return{r:6,g:255,b:216}}}
function rgba(h,a=1){const{r,g,b}=h2r(h);return`rgba(${r},${g},${b},${+a.toFixed(3)})`}
const pc=i=>THEME.palette[((i%4)+4)%4];
const delay=ms=>new Promise(r=>setTimeout(r,ms));

// ═══ VARIETY HISTORY — 25-song no-repeat window ═══
const ALL_SCENES=['WARP_SPEED','LAVA_WORLD','CYBER_GRID','DEEP_SEA','STORM_CHASER','JUNGLE_RAVE','DISCO_DIMENSION','ACID_TRIP','SPACE_STATION','NEON_CATHEDRAL','CLASSIC_ARCADE','ELECTRIC_FOREST','OMNIA_NIGHTCLUB','PIRATE_SHIP','JUNKYARD','SUPERHERO','DAY_OF_DEAD','CHINESE_DRAGON','MOUNT_OLYMPUS','SUPER_MARIO','ATLANTIS','CARNIVAL','EGYPTIAN_TOMB'];
const ALL_CPS=['skull','flaming_skull','skull_crossbones','smiley','demon_face','alien_head','robot_head','dragon','wolf_head','eagle','peace_sign','lightning_bolt','yin_yang','star','ankh','trident','flame','diamond','coffin','astronaut','rocket','ufo','vinyl_record','disco_ball','turntable','hourglass','crown','clock_face','chandelier','sun','moon','planet','comet','black_hole','wormhole','mandala','dna_helix','tesseract','eye','lotus'];
const CP_NO_REPEAT=25;
const SCENE_NO_REPEAT=15;
function loadJ(k,def){try{return JSON.parse(lg(k)||'null')||def}catch{return def}}
let sceneHist=loadJ('sw_sh',[]),cpHist=loadJ('sw_ch',[]),sceneLastSeen=loadJ('sw_ls',{});
let songCount=parseInt(lg('sw_n')||0),sessionStreak=parseInt(lg('sw_ss')||0);
if(Date.now()-parseInt(lg('sw_st')||0)>3600000){sessionStreak=0;ls('sw_ss','0');}
function getSceneShortlist(){
  const recent=new Set(sceneHist.slice(-SCENE_NO_REPEAT));
  const eligible=ALL_SCENES.filter(s=>!recent.has(s));
  if(eligible.length<4)return ALL_SCENES.slice().sort((a,b)=>(sceneLastSeen[a]||0)-(sceneLastSeen[b]||0)).slice(0,8);
  return eligible.sort((a,b)=>(sceneLastSeen[a]||0)-(sceneLastSeen[b]||0));
}
function getForbidCPs(){return cpHist.slice(-CP_NO_REPEAT);}
function recordScene(s){
  sceneHist.push(s);if(sceneHist.length>40)sceneHist.shift();
  sceneLastSeen[s]=songCount;
  ls('sw_sh',JSON.stringify(sceneHist));ls('sw_ls',JSON.stringify(sceneLastSeen));
  songCount++;ls('sw_n',songCount);
  sessionStreak++;ls('sw_ss',sessionStreak);ls('sw_st',Date.now());
}
function recordCP(c){if(!c)return;cpHist.push(c);if(cpHist.length>50)cpHist.shift();ls('sw_ch',JSON.stringify(cpHist));}
function enforceScene(s,shortlist){if(shortlist.includes(s))return s;return shortlist[0]||s;}
function enforceCP(c){
  if(!c)return null;
  const forbidden=getForbidCPs();
  if(!ALL_CPS.includes(c)||forbidden.includes(c)){
    const available=ALL_CPS.filter(x=>!forbidden.includes(x));
    return available.length>0?rndEl(available):c;
  }
  return c;
}

// ═══ INTEGRATED SCENES SET ═══
const CP_INTEGRATED_SCENES=new Set(['WARP_SPEED','DEEP_SEA','STORM_CHASER','CARNIVAL','JUNKYARD','EGYPTIAN_TOMB','ELECTRIC_FOREST','PIRATE_SHIP','ACID_TRIP','NEON_CATHEDRAL','SPACE_STATION','LAVA_WORLD','DISCO_DIMENSION','CLASSIC_ARCADE','SUPERHERO','DAY_OF_DEAD','CHINESE_DRAGON','MOUNT_OLYMPUS','SUPER_MARIO','ATLANTIS','JUNGLE_RAVE','CYBER_GRID','OMNIA_NIGHTCLUB']);

// ═══ SURPRISE SYSTEM — 12–15 second multi-wave events ═══
function flash(color,ms){const o=document.getElementById('surpriseOverlay');o.style.background=color;o.style.transition='opacity 0.08s';o.style.opacity='1';setTimeout(()=>{o.style.transition=`opacity ${ms}ms ease`;o.style.opacity='0';},100);}

// Schedule a series of timed events
function sequence(events){events.forEach(([delay,fn])=>setTimeout(fn,delay));}

function fireSurprise(){
  if(!midShifted&&Math.random()<0.15&&songProg>0.3&&songProg<0.75){
    midShifted=true;
    const f=getForbidCPs(),pool=ALL_SCENES.filter(s=>s!==THEME.scene);
    const newScene=rndEl(pool);
    const savedScene=THEME.scene,savedCP=THEME.centerpiece;
    setTimeout(()=>{THEME.scene=newScene;initScene();
      setTimeout(()=>{THEME.scene=savedScene;initScene();THEME.centerpiece=savedCP;},11000);},400);
    return;
  }
  const sc=THEME.scene;
  const variant=Math.floor(Math.random()*3); // up to 3 variants per scene

  if(sc==='WARP_SPEED'){
    if(variant===0){
      // Hyperspeed — centerpiece rushes to fill screen
      sequence([[0,()=>{beatFX.speedBoost=6;flash('rgba(255,255,255,0.3)',300);}],[500,()=>{beatFX.speedBoost=10;flash(rgba(pc(0),0.4),200);}],[1500,()=>{flash('rgba(255,255,255,0.8)',150);}],[2000,()=>{beatFX.speedBoost=4;}],[5000,()=>{beatFX.speedBoost=0;}]]);
    } else if(variant===1){
      // Asteroid field
      sequence([[0,()=>{flash(rgba(pc(1),0.5),400);for(let i=0;i<15;i++)setTimeout(()=>{beatFX.shockwaveR=0;beatFX.shockwaveA=0.7;},i*200);}],[3000,()=>{beatFX.speedBoost=3;}],[7000,()=>{beatFX.speedBoost=0;}]]);
    } else {
      sequence([[0,()=>{beatFX.speedBoost=8;flash('rgba(0,0,0,0.95)',50);}],[100,()=>{flash(rgba(pc(0),0.9),100);}],[200,()=>{flash(rgba(pc(1),0.8),200);}],[500,()=>{beatFX.speedBoost=12;}],[2000,()=>{beatFX.speedBoost=3;}],[8000,()=>{beatFX.speedBoost=0;}]]);
    }
  }
  else if(sc==='LAVA_WORLD'){
    if(variant===0){
      // Mega eruption — lava balls swarm the sky
      sequence([[0,()=>{flash(rgba(pc(0),0.7),400);fireLavaBalls();fireLavaBalls();}],[600,()=>{fireLavaBalls();flash(rgba(pc(1),0.5),300);}],[1200,()=>{fireLavaBalls();fireLavaBalls();}],[2000,()=>{flash('rgba(255,100,0,0.4)',800);if(SD.embers)SD.embers.forEach(e=>e.vy*=5);}],[3500,()=>{fireLavaBalls();}],[5000,()=>{fireLavaBalls();fireLavaBalls();}],[8000,()=>{if(SD.embers)SD.embers.forEach(e=>e.vy/=5);}]]);
    } else if(variant===1){
      // Lava floor rises — screen floods orange then recedes
      sequence([[0,()=>{flash('rgba(255,80,0,0.5)',500);}],[500,()=>{flash('rgba(255,120,0,0.6)',800);}],[1000,()=>{flash('rgba(255,60,0,0.8)',400);fireLavaBalls();fireLavaBalls();fireLavaBalls();}],[2500,()=>{flash('rgba(200,40,0,0.5)',1500);}],[5000,()=>{fireLavaBalls();fireLavaBalls();}],[9000,()=>{}]]);
    } else {
      // Double volcano eruption
      sequence([[0,()=>{fireLavaBalls();flash(rgba(pc(0),0.6),300);}],[300,()=>{fireLavaBalls();}],[700,()=>{fireLavaBalls();fireLavaBalls();}],[1500,()=>{flash('rgba(255,80,0,0.7)',200);}],[2000,()=>{fireLavaBalls();fireLavaBalls();fireLavaBalls();}],[4000,()=>{fireLavaBalls();fireLavaBalls();}],[7000,()=>{fireLavaBalls();}]]);
    }
  }
  else if(sc==='DEEP_SEA'){
    if(variant===0){
      // Creature swarm — multiple giants fill screen
      sequence([[0,()=>{flash(rgba(pc(0),0.4),600);if(SD.creatures)SD.creatures.push({...mkDeepCreature(W(),H()),sz:Math.min(W(),H())*0.5,vx:1.8,y:H()*0.3});}],[800,()=>{if(SD.creatures)SD.creatures.push({...mkDeepCreature(W(),H()),sz:Math.min(W(),H())*0.6,vx:2,y:H()*0.5});}],[1600,()=>{flash(rgba(pc(1),0.5),400);if(SD.creatures)for(let i=0;i<3;i++)SD.creatures.push({...mkDeepCreature(W(),H()),sz:160+i*40,vx:1+i*0.3});}],[4000,()=>{if(SD.plankton)SD.plankton.forEach(p=>p.vy*=8);}],[6000,()=>{if(SD.plankton)SD.plankton.forEach(p=>p.vy/=8);}]]);
    } else if(variant===1){
      // Bioluminescent explosion
      sequence([[0,()=>{flash(rgba(pc(0),0.8),200);}],[200,()=>{flash('rgba(255,255,255,0.9)',100);}],[400,()=>{flash(rgba(pc(1),0.7),400);if(SD.plankton)SD.plankton.forEach(p=>{p.vy*=10;p.r*=2;});}],[1000,()=>{flash(rgba(pc(2),0.5),600);}],[3000,()=>{if(SD.plankton)SD.plankton.forEach(p=>{p.vy/=10;p.r/=2;});}],[5000,()=>{if(SD.creatures)SD.creatures.push({...mkDeepCreature(W(),H()),sz:Math.min(W(),H())*0.7,vx:2.5,y:H()*0.4});}]]);
    } else {
      sequence([[0,()=>{flash('rgba(0,200,150,0.4)',300);}],[400,()=>{for(let i=0;i<4;i++)setTimeout(()=>SD.creatures&&SD.creatures.push({...mkDeepCreature(W(),H()),sz:200,vx:1.5+i*0.3,y:H()*(0.2+i*0.15)}),i*300);}],[3000,()=>{flash(rgba(pc(0),0.6),500);}],[7000,()=>{if(SD.plankton)SD.plankton.forEach(p=>p.vy*=6);}],[9000,()=>{if(SD.plankton)SD.plankton.forEach(p=>p.vy/=6);}]]);
    }
  }
  else if(sc==='CYBER_GRID'){
    if(variant===0){
      // Matrix meltdown
      sequence([[0,()=>{gridGlitch=true;if(SD.dataStreams)SD.dataStreams.forEach(ds=>ds.speed*=8);flash(rgba(pc(0),0.7),150);}],[200,()=>{flash(rgba(pc(1),0.6),150);}],[500,()=>{beatFX.invertA=0.5;if(SD.buildings)SD.buildings.forEach(b=>{b.h*=1.6;b.ci=(b.ci+2)%4;});}],[2000,()=>{flash(rgba(pc(0),0.8),200);}],[3000,()=>{beatFX.invertA=0;gridGlitch=false;if(SD.dataStreams)SD.dataStreams.forEach(ds=>ds.speed/=8);if(SD.buildings)SD.buildings.forEach(b=>b.h/=1.6);}],[6000,()=>{}]]);
    } else if(variant===1){
      // City collapse and rebuild
      sequence([[0,()=>{flash(rgba(pc(0),0.9),200);beatFX.invertA=0.8;}],[300,()=>{if(SD.buildings)SD.buildings.forEach(b=>b.h*=0.3);flash('rgba(0,0,0,0.95)',300);}],[700,()=>{beatFX.invertA=0;}],[2000,()=>{if(SD.buildings)SD.buildings.forEach(b=>b.h/=0.3);gridGlitch=true;flash(rgba(pc(1),0.6),400);}],[4000,()=>{gridGlitch=false;}],[8000,()=>{}]]);
    } else {
      sequence([[0,()=>{for(let i=0;i<5;i++)setTimeout(()=>{flash(rgba(pc(i%4),0.5),100);},i*200);}],[1500,()=>{gridGlitch=true;beatFX.speedBoost=2;if(SD.dataStreams)SD.dataStreams.forEach(ds=>ds.speed*=5);}],[4000,()=>{gridGlitch=false;beatFX.speedBoost=0;if(SD.dataStreams)SD.dataStreams.forEach(ds=>ds.speed/=5);}]]);
    }
  }
  else if(sc==='STORM_CHASER'){
    if(variant===0){
      // Lightning wall
      sequence([[0,()=>{for(let i=0;i<6;i++)setTimeout(()=>{SD.lightnings&&SD.lightnings.push(mkLightning());flash('rgba(255,255,255,0.8)',80);},i*120);}],[1000,()=>{for(let i=0;i<8;i++)setTimeout(()=>{SD.lightnings&&SD.lightnings.push(mkLightning());},i*100);}],[3000,()=>{flash(rgba(pc(0),0.6),400);}],[5000,()=>{for(let i=0;i<5;i++)setTimeout(()=>{SD.lightnings&&SD.lightnings.push(mkLightning());},i*150);}]]);
    } else if(variant===1){
      // Tornado splits into 3
      sequence([[0,()=>{beatFX.speedBoost=3;flash('rgba(200,220,255,0.5)',400);}],[500,()=>{flash('rgba(255,255,255,0.7)',200);}],[1000,()=>{for(let i=0;i<10;i++)setTimeout(()=>{SD.lightnings&&SD.lightnings.push(mkLightning());},i*80);}],[3000,()=>{beatFX.speedBoost=1;}],[7000,()=>{beatFX.speedBoost=0;}]]);
    } else {
      sequence([[0,()=>{flash('rgba(255,255,255,0.95)',100);}],[200,()=>{for(let i=0;i<12;i++)setTimeout(()=>{SD.lightnings&&SD.lightnings.push(mkLightning());},i*60);}],[1500,()=>{flash(rgba(pc(0),0.7),300);beatFX.speedBoost=2;}],[4000,()=>{for(let i=0;i<6;i++)setTimeout(()=>{SD.lightnings&&SD.lightnings.push(mkLightning());flash('rgba(255,255,255,0.5)',80);},i*200);}],[8000,()=>{beatFX.speedBoost=0;}]]);
    }
  }
  else if(sc==='JUNGLE_RAVE'){
    if(variant===0){
      // Stampede — creatures charge through, canopy explodes
      sequence([[0,()=>{flash(rgba(pc(2),0.5),400);for(let i=0;i<6;i++)setTimeout(()=>SD.creatures&&SD.creatures.push({...mkJungleCreature(W(),H()),sz:180+i*25,vx:-(2+i*0.4),y:H()*(0.25+i*0.08)}),i*200);}],[2000,()=>{if(SD.trees)SD.trees.forEach(t=>t.glowMult=4);if(SD.spores)SD.spores.forEach(s=>s.vy*=8);}],[4000,()=>{flash(rgba(pc(0),0.6),500);}],[5000,()=>{if(SD.spores)SD.spores.forEach(s=>s.vy/=8);}],[8000,()=>{}]]);
    } else if(variant===1){
      // Canopy explosion — vines and leaves fill screen
      sequence([[0,()=>{if(SD.trees)SD.trees.forEach(t=>t.glowMult=6);flash(rgba(pc(2),0.7),300);}],[500,()=>{if(SD.vines)SD.vines.forEach(v=>v.swingSpeed*=5);flash(rgba(pc(0),0.5),400);}],[1500,()=>{if(SD.spores)SD.spores.forEach(s=>{s.vy*=6;s.vx=(Math.random()-0.5)*4;});}],[4000,()=>{if(SD.vines)SD.vines.forEach(v=>v.swingSpeed/=5);if(SD.spores)SD.spores.forEach(s=>{s.vy/=6;s.vx=(Math.random()-0.5)*0.3;});}],[8000,()=>{}]]);
    } else {
      sequence([[0,()=>{flash(rgba(pc(2),0.8),200);}],[300,()=>{for(let i=0;i<4;i++)setTimeout(()=>{SD.creatures&&SD.creatures.push({...mkJungleCreature(W(),H()),sz:220});if(SD.trees)SD.trees[i%SD.trees.length].glowMult=5;},i*400);}],[3000,()=>{flash(rgba(pc(0),0.6),400);if(SD.spores)SD.spores.forEach(s=>s.vy*=10);}],[5000,()=>{if(SD.spores)SD.spores.forEach(s=>s.vy/=10);}],[9000,()=>{}]]);
    }
  }
  else if(sc==='DISCO_DIMENSION'){
    if(variant===0){
      // Strobe overload — all tiles flash simultaneously
      sequence([[0,()=>{for(let i=0;i<8;i++)setTimeout(()=>{flash(rgba(pc(i%4),0.6),60);if(SD.discoFloor)SD.discoFloor.forEach(t=>t.ci=Math.floor(Math.random()*4));},i*100);}],[1000,()=>{beatFX.invertA=0.6;flash('rgba(255,255,255,0.9)',150);}],[1500,()=>{beatFX.invertA=0;}],[2000,()=>{for(let i=0;i<6;i++)setTimeout(()=>{flash(rgba(pc(i%4),0.5),80);},i*130);}],[5000,()=>{if(SD.beams)SD.beams.forEach(b=>b.speed*=4);}],[8000,()=>{if(SD.beams)SD.beams.forEach(b=>b.speed/=4);}]]);
    } else if(variant===1){
      // Floor cracks, light erupts from below
      sequence([[0,()=>{flash(rgba(pc(0),0.7),300);}],[400,()=>{if(SD.discoFloor)SD.discoFloor.forEach(t=>{t.bright=1;t.ph+=Math.PI;});}],[600,()=>{flash('rgba(255,255,255,0.95)',200);}],[1000,()=>{for(let i=0;i<5;i++)setTimeout(()=>{beatFX.shockwaveR=0;beatFX.shockwaveA=0.8;},i*250);}],[3000,()=>{if(SD.discoFloor)SD.discoFloor.forEach(t=>t.ci=Math.floor(Math.random()*4));}],[7000,()=>{}]]);
    } else {
      sequence([[0,()=>{flash(rgba(pc(1),0.8),150);}],[200,()=>{flash('rgba(255,255,255,0.7)',100);}],[400,()=>{if(SD.crowd)SD.crowd.forEach(p=>p.h*=2);flash(rgba(pc(0),0.6),200);}],[1500,()=>{beatFX.invertA=0.5;}],[2000,()=>{beatFX.invertA=0;if(SD.crowd)SD.crowd.forEach(p=>p.h/=2);}],[4000,()=>{if(SD.discoFloor)SD.discoFloor.forEach(t=>t.bright=1);}],[8000,()=>{}]]);
    }
  }
  else if(sc==='ACID_TRIP'){
    if(variant===0){
      sequence([[0,()=>{beatFX.invertA=0.9;flash(rgba(pc(0),0.8),200);}],[300,()=>{flash(rgba(pc(1),0.7),200);}],[600,()=>{flash(rgba(pc(2),0.8),200);}],[1000,()=>{beatFX.invertA=0.6;flash(rgba(pc(3),0.7),300);}],[2500,()=>{beatFX.invertA=0.8;}],[4000,()=>{beatFX.invertA=0.4;}],[7000,()=>{beatFX.invertA=0;}]]);
    } else if(variant===1){
      sequence([[0,()=>{flash('rgba(0,0,0,0.95)',100);}],[200,()=>{if(SD.warpGrid)SD.warpGrid.forEach(p=>p.ph+=Math.PI*(Math.random()-0.5)*4);flash(rgba(pc(0),0.9),100);}],[600,()=>{beatFX.invertA=0.7;flash(rgba(pc(1),0.8),200);}],[2000,()=>{if(SD.warpGrid)SD.warpGrid.forEach(p=>p.ph=Math.random()*Math.PI*2);}],[3000,()=>{beatFX.invertA=0.4;}],[6000,()=>{beatFX.invertA=0;}]]);
    } else {
      sequence([[0,()=>{for(let i=0;i<6;i++)setTimeout(()=>{flash(rgba(pc(i%4),0.7),100);beatFX.invertA=i%2===0?0.6:0;},i*150);}],[1200,()=>{beatFX.invertA=0.5;if(SD.warpGrid)SD.warpGrid.forEach(p=>p.ph+=Math.PI);}],[4000,()=>{beatFX.invertA=0.3;}],[7000,()=>{beatFX.invertA=0;}]]);
    }
  }
  else if(sc==='SPACE_STATION'){
    if(variant===0){
      // Hull breach — red alert, debris, cracks
      sequence([[0,()=>{SD.hullBreachActive=true;flash('rgba(255,0,0,0.6)',300);beatFX.speedBoost=2;}],[400,()=>{flash('rgba(255,0,0,0.5)',300);if(SD.debris)for(let i=0;i<10;i++)SD.debris.push({...mkDebris(),vx:(Math.random()-0.5)*14,vy:(Math.random()-0.5)*14});}],[800,()=>{flash('rgba(255,50,0,0.4)',400);}],[1500,()=>{for(let i=0;i<5;i++)setTimeout(()=>{document.getElementById('surpriseOverlay').style.background='rgba(200,0,0,0.1)';document.getElementById('surpriseOverlay').style.opacity='1';setTimeout(()=>document.getElementById('surpriseOverlay').style.opacity='0',80);},i*250);}],[4000,()=>{beatFX.speedBoost=0;}],[8000,()=>{SD.hullBreachActive=false;}]]);
    } else if(variant===1){
      // Warp jump — scene stretches and snaps
      sequence([[0,()=>{beatFX.speedBoost=4;flash('rgba(255,255,255,0.4)',200);}],[500,()=>{beatFX.speedBoost=8;flash('rgba(255,255,255,0.8)',150);}],[700,()=>{beatFX.speedBoost=14;flash('rgba(255,255,255,0.95)',100);}],[900,()=>{beatFX.speedBoost=2;flash('rgba(0,0,0,0.8)',300);}],[2000,()=>{beatFX.speedBoost=0.5;}],[6000,()=>{beatFX.speedBoost=0;}]]);
    } else {
      sequence([[0,()=>{flash('rgba(255,0,0,0.7)',200);SD.hullBreachActive=true;}],[400,()=>{beatFX.speedBoost=3;if(SD.debris)for(let i=0;i<8;i++)SD.debris.push({...mkDebris(),vx:(Math.random()-0.5)*16,vy:(Math.random()-0.5)*16});}],[2000,()=>{flash('rgba(255,100,0,0.5)',400);}],[5000,()=>{beatFX.speedBoost=0;}],[9000,()=>{SD.hullBreachActive=false;}]]);
    }
  }
else if(sc==='NEON_CATHEDRAL'){
    if(variant===0){
      // A: Angel descends — ghosts scatter screaming outward
      sequence([
        [0,()=>{
          // Angel enters from top center
          if(!SD.angel){
            SD.angel={
              x:W()/2, y:-120,
              vx:0, vy:3.5,
              alpha:0, tilt:0, tiltDir:1,
              wingFlap:0, entering:true
            };
          }
          flash('rgba(255,255,220,0.5)',600);
        }],
        [800,()=>{
          // Angel slows to hover
          if(SD.angel){SD.angel.vy=0.3;}
          flash('rgba(255,255,200,0.7)',300);
        }],
        [1400,()=>{
          // All ghosts flee outward from angel position
          if(SD.ghosts&&SD.angel){
            for(const g of SD.ghosts){
              g.fleeing=true;g.orbitting=false;
              const dx=g.x-SD.angel.x,dy=g.y-SD.angel.y;
              const dist=Math.hypot(dx,dy)||1;
              const speed=4+Math.random()*3;
              g.fleeVx=dx/dist*speed;
              g.fleeVy=dy/dist*speed;
            }
          }
          flash('rgba(255,255,255,0.9)',200);
        }],
        [3000,()=>{
          // Angel begins to fade and ascend
          if(SD.angel){SD.angel.entering=false;SD.angel.vy=-1.5;}
        }],
        [7000,()=>{SD.angel=null;}],
      ]);
    } else if(variant===1){
      // B: Giant ghost overtakes the scene
      sequence([
        [0,()=>{
          // Spawn one massive ghost in center
          if(SD.ghosts){
            SD.ghosts.push({
              x:W()/2, y:-200,
              targetX:W()/2, targetY:H()*0.35,
              speed:2, wobble:0, wobbleSpeed:0.015,
              orbitAngle:0, orbitR:0, orbitting:false,
              alpha:0, ci:Math.floor(Math.random()*4),
              fleeing:false, fleeVx:0, fleeVy:0,
              sz:4.5, giant:true,
            });
          }
          flash(rgba(pc(0),0.4),600);
        }],
        [500,()=>{flash('rgba(0,0,0,0.7)',300);}],
        [1000,()=>{flash(rgba(pc(1),0.5),400);}],
        [2000,()=>{
          // All small ghosts flee from giant
          if(SD.ghosts){
            for(const g of SD.ghosts){
              if(!g.giant){
                g.fleeing=true;g.orbitting=false;
                g.fleeVx=(Math.random()-0.5)*6;
                g.fleeVy=-(Math.random()*4+2);
              }
            }
          }
          flash(rgba(pc(0),0.6),300);
        }],
        [4000,()=>{flash('rgba(0,0,0,0.5)',400);}],
        [7000,()=>{
          // Giant ghost fades
          if(SD.ghosts){
            for(const g of SD.ghosts){
              if(g.giant){g.fleeing=true;g.fleeVx=0;g.fleeVy=-3;}
            }
          }
        }],
        [9000,()=>{if(SD.ghosts)SD.ghosts=SD.ghosts.filter(g=>!g.giant);}],
      ]);
    } else {
      // C: All ghosts strobe violently
      sequence([
        [0,()=>{
          SD.ghostStrobe=true;
          flash(rgba(pc(0),0.6),200);
        }],
        [300,()=>{flash(rgba(pc(1),0.5),150);}],
        [600,()=>{flash('rgba(255,255,255,0.8)',100);}],
        [1000,()=>{flash(rgba(pc(2),0.6),200);}],
        [1500,()=>{flash(rgba(pc(3),0.5),200);}],
        [2000,()=>{flash('rgba(255,255,255,0.7)',150);}],
        [3000,()=>{flash(rgba(pc(0),0.5),300);}],
        [4500,()=>{flash('rgba(255,255,255,0.6)',200);}],
        [6000,()=>{flash(rgba(pc(1),0.4),400);}],
        [8000,()=>{SD.ghostStrobe=false;}],
      ]);
    }
  }
  else if(sc==='CLASSIC_ARCADE'){
    if(variant===0){
      // Boss appears!
      sequence([[0,()=>{SD.bossActive=true;SD.bossX=W()*0.72;SD.bossY=H()*0.3;SD.bossShots=[];flash(rgba(pc(0),0.7),300);}],[500,()=>{flash('rgba(255,0,0,0.4)',400);}],[3000,()=>{flash(rgba(pc(1),0.5),300);}],[9000,()=>{SD.bossActive=false;}],[10000,()=>{showGameOver();}]]);
    } else if(variant===1){
      // Game over screen
      sequence([[0,()=>{showGameOver();flash('rgba(255,0,0,0.5)',300);}],[2500,()=>{flash(rgba(pc(0),0.4),400);}],[3000,()=>{if(SD.galaShips)SD.galaShips.forEach(gs=>gs.ph=0);}]]);
    } else {
      sequence([[0,()=>{SD.bossActive=true;SD.bossX=W()*0.6;SD.bossY=H()*0.25;SD.bossShots=[];flash(rgba(pc(0),0.8),200);}],[400,()=>{flash('rgba(255,0,0,0.6)',200);}],[1000,()=>{flash('rgba(255,255,0,0.4)',300);}],[6000,()=>{flash(rgba(pc(1),0.5),400);}],[8000,()=>{SD.bossActive=false;showGameOver();}]]);
    }
  }
  else if(sc==='ELECTRIC_FOREST'){
    if(variant===0){
      // Trees catch fire, burn, regrow
      sequence([[0,()=>{if(SD.trees)SD.trees.forEach(t=>t.glowMult=5);flash(rgba(pc(0),0.7),400);}],[1000,()=>{flash(rgba(pc(1),0.5),300);}],[2000,()=>{if(SD.trees)SD.trees.forEach(t=>t.glowMult=3);flash(rgba(pc(2),0.4),400);}],[4000,()=>{if(SD.trees)SD.trees.forEach(t=>t.glowMult=1);}],[5000,()=>{if(SD.trees)SD.trees.forEach(t=>t.glowMult=4);}],[8000,()=>{if(SD.trees)SD.trees.forEach(t=>t.glowMult=1);}]]);
    } else if(variant===1){
      // Lightning storm through canopy
      sequence([[0,()=>{for(let i=0;i<8;i++)setTimeout(()=>{SD.lightnings&&SD.lightnings.push(mkLightning());flash('rgba(255,255,255,0.6)',60);},i*120);}],[1500,()=>{if(SD.trees)SD.trees.forEach(t=>t.glowMult=4);}],[3000,()=>{for(let i=0;i<6;i++)setTimeout(()=>{SD.lightnings&&SD.lightnings.push(mkLightning());},i*150);}],[6000,()=>{if(SD.trees)SD.trees.forEach(t=>t.glowMult=1);}]]);
    } else {
      sequence([[0,()=>{if(SD.trees)SD.trees.forEach(t=>t.glowMult=6);flash(rgba(pc(0),0.8),300);}],[500,()=>{flash('rgba(255,255,255,0.7)',150);}],[1000,()=>{beatFX.speedBoost=2;if(SD.trees)SD.trees.forEach(t=>t.glowMult=3);}],[3000,()=>{beatFX.speedBoost=0;}],[5000,()=>{if(SD.trees)SD.trees.forEach(t=>t.glowMult=5);}],[8000,()=>{if(SD.trees)SD.trees.forEach(t=>t.glowMult=1);}]]);
    }
  }
else if(sc==='OMNIA_NIGHTCLUB'){
    if(variant===0){
      // A: Full laser show erupts from chandelier
      sequence([
        [0,()=>{
          if(SD.omnia){SD.omnia.laserActive=true;SD.omnia.beamRot=0;}
          flash(rgba(pc(0),0.5),200);
        }],
        [300,()=>{flash(rgba(pc(1),0.4),150);}],
        [700,()=>{flash(rgba(pc(2),0.5),150);}],
        [1200,()=>{flash(rgba(pc(3),0.4),200);}],
        [2000,()=>{flash('rgba(255,255,255,0.3)',100);}],
        [3500,()=>{flash(rgba(pc(0),0.4),150);}],
        [5000,()=>{flash(rgba(pc(1),0.3),200);}],
        [7000,()=>{flash(rgba(pc(2),0.4),150);}],
        [10000,()=>{if(SD.omnia)SD.omnia.laserActive=false;}],
      ]);
    } else if(variant===1){
      // B: CO2 billows from chandelier, whites out scene
      sequence([
        [0,()=>{
          if(SD.omnia)SD.omnia.co2Active=true;
          flash('rgba(220,235,255,0.3)',400);
        }],
        [600,()=>{flash('rgba(240,245,255,0.5)',300);}],
        [1200,()=>{flash('rgba(255,255,255,0.7)',200);}],
        [2000,()=>{flash('rgba(240,248,255,0.4)',500);}],
        [4000,()=>{flash('rgba(220,235,255,0.3)',400);}],
        [7000,()=>{if(SD.omnia)SD.omnia.co2Active=false;}],
        [10000,()=>{}],
      ]);
    } else {
      // C: Rings go haywire independently — each spins out of control
      sequence([
        [0,()=>{
          flash(rgba(pc(0),0.6),200);
          if(SD.omnia&&SD.omnia.rings){
            // Each ring gets its own haywire speed and direction
            SD.omnia.rings.forEach((ring,i)=>{
              setTimeout(()=>{
                ring.haywire=true;
                ring.haywireSpeed=ring.rotSpeed*(8+Math.random()*12)*(Math.random()<0.5?1:-1);
                flash(rgba(pc(ring.ci),0.5),100);
              },i*180);
            });
          }
        }],
        [1200,()=>{flash('rgba(255,255,255,0.6)',150);}],
        [2000,()=>{
          // Mid-chaos direction flip on some rings
          if(SD.omnia&&SD.omnia.rings){
            SD.omnia.rings.forEach((ring,i)=>{
              if(i%2===0)ring.haywireSpeed*=-1;
            });
          }
          flash(rgba(pc(1),0.5),200);
        }],
        [3500,()=>{flash(rgba(pc(2),0.4),200);}],
        [5000,()=>{
          // Second chaos burst
          if(SD.omnia&&SD.omnia.rings){
            SD.omnia.rings.forEach(ring=>{
              ring.haywireSpeed=ring.rotSpeed*(10+Math.random()*15)*(Math.random()<0.5?1:-1);
              flash(rgba(pc(ring.ci),0.4),80);
            });
          }
        }],
        [7000,()=>{flash('rgba(255,255,255,0.4)',300);}],
        [9000,()=>{
          // Rings slowly calm back to normal
          if(SD.omnia&&SD.omnia.rings){
            SD.omnia.rings.forEach(ring=>{ring.haywire=false;});
          }
        }],
      ]);
    }
  }
  else if(sc==='PIRATE_SHIP'){
    if(variant===0){
      // Kraken attack — tentacles from water
      sequence([[0,()=>{flash(rgba(pc(0),0.6),400);if(SD.creatures)for(let i=0;i<4;i++)setTimeout(()=>{SD.creatures&&SD.creatures.push({...mkDeepCreature(W(),H()),sz:150+i*30,vx:1.2+i*0.3,y:H()*(0.55+i*0.08)});},i*300);}],[2000,()=>{flash(rgba(pc(1),0.5),500);}],[4000,()=>{for(let i=0;i<5;i++)setTimeout(()=>SD.cannonballs&&SD.cannonballs.push(mkCannonball()),i*120);}],[7000,()=>{}]]);
    } else if(variant===1){
      // Cannonball broadside
      sequence([[0,()=>{for(let i=0;i<8;i++)setTimeout(()=>{SD.cannonballs&&SD.cannonballs.push(mkCannonball());flash('rgba(255,150,0,0.4)',150);},i*180);}],[2000,()=>{flash(rgba(pc(0),0.6),300);}],[3000,()=>{for(let i=0;i<6;i++)setTimeout(()=>{SD.cannonballs&&SD.cannonballs.push(mkCannonball());},i*200);}],[6000,()=>{}]]);
    } else {
      sequence([[0,()=>{flash(rgba(pc(0),0.7),300);}],[500,()=>{for(let i=0;i<5;i++)setTimeout(()=>SD.cannonballs&&SD.cannonballs.push(mkCannonball()),i*150);}],[2000,()=>{if(SD.creatures)for(let i=0;i<3;i++)SD.creatures.push({...mkDeepCreature(W(),H()),sz:180,vx:1.5,y:H()*(0.6+i*0.08)});}],[4000,()=>{flash(rgba(pc(1),0.5),400);}],[7000,()=>{}]]);
    }
  }
  else if(sc==='JUNKYARD'){
    if(variant===0){
      // Wrecking ball berserk + spark explosion
      sequence([[0,()=>{beatFX.speedBoost=2;for(let i=0;i<50;i++)SD.sparks&&SD.sparks.push(mkSpark(false));flash(rgba(pc(1),0.7),200);}],[400,()=>{flash(rgba(pc(0),0.6),200);for(let i=0;i<40;i++)SD.sparks&&SD.sparks.push(mkSpark(false));}],[1000,()=>{beatFX.gravityWave=2;for(let i=0;i<5;i++)setTimeout(()=>{for(let j=0;j<20;j++)SD.sparks&&SD.sparks.push(mkSpark(false));},i*400);}],[4000,()=>{beatFX.gravityWave=0;}],[7000,()=>{beatFX.speedBoost=0;}]]);
    } else if(variant===1){
      // Junk pile avalanche
      sequence([[0,()=>{flash(rgba(pc(0),0.7),300);for(let i=0;i<60;i++)SD.sparks&&SD.sparks.push(mkSpark(false));}],[500,()=>{flash(rgba(pc(1),0.5),400);}],[1000,()=>{beatFX.slamS=1.5;for(let i=0;i<4;i++)setTimeout(()=>{beatFX.shockwaveR=0;beatFX.shockwaveA=0.8;},i*400);}],[4000,()=>{beatFX.slamS=1;}],[6000,()=>{}]]);
    } else {
      sequence([[0,()=>{beatFX.speedBoost=3;flash(rgba(pc(0),0.8),200);}],[400,()=>{flash(rgba(pc(1),0.6),200);for(let i=0;i<80;i++)SD.sparks&&SD.sparks.push(mkSpark(false));}],[1200,()=>{beatFX.gravityWave=1.5;}],[3000,()=>{beatFX.gravityWave=0;beatFX.speedBoost=1;}],[6000,()=>{beatFX.speedBoost=0;}]]);
    }
  }
  else if(sc==='SUPERHERO'){
    if(variant===0){
      // Villain attack — city under siege
      sequence([[0,()=>{doComicBurst();flash(rgba(pc(0),0.6),300);}],[800,()=>{doComicBurst();}],[2000,()=>{flash('rgba(255,0,0,0.3)',400);doComicBurst();}],[4000,()=>{flash(rgba(pc(1),0.5),400);}],[6000,()=>{doComicBurst();}]]);
    } else if(variant===1){
      // Hero power-up — light radiates from signal
      sequence([[0,()=>{flash('rgba(255,255,200,0.7)',300);beatFX.speedBoost=2;}],[400,()=>{flash('rgba(255,255,255,0.9)',200);}],[800,()=>{flash(rgba(pc(0),0.6),400);}],[2000,()=>{doComicBurst();}],[4000,()=>{beatFX.speedBoost=0;}]]);
    } else {
      sequence([[0,()=>{doComicBurst();flash(rgba(pc(0),0.7),200);}],[500,()=>{doComicBurst();}],[1200,()=>{flash('rgba(255,255,0,0.5)',300);}],[2500,()=>{doComicBurst();flash(rgba(pc(1),0.5),400);}],[5000,()=>{flash('rgba(255,255,255,0.4)',300);}]]);
    }
  }
else if(sc==='DAY_OF_DEAD'){
    if(variant===0){
      // A: Mask gets huge and vibrant — swells to fill screen
      sequence([
        [0,()=>{
          if(SD.dotd){SD.dotd.maskRotSpeed=0.025;SD.dotd.maskPulse=0.2;}
          flash(rgba(pc(0),0.7),300);
        }],
        [400,()=>{flash(rgba(pc(1),0.6),200);}],
        [800,()=>{
          if(SD.dotd){SD.dotd.maskPulse=0.35;}
          flash(rgba(pc(2),0.7),200);
        }],
        [1200,()=>{flash('rgba(255,255,255,0.5)',150);}],
        [2000,()=>{flash(rgba(pc(3),0.5),300);}],
        [3000,()=>{flash(rgba(pc(0),0.6),200);}],
        [4500,()=>{
          if(SD.dotd){SD.dotd.maskPulse=0.2;}
          flash(rgba(pc(1),0.5),300);
        }],
        [7000,()=>{flash(rgba(pc(2),0.4),400);}],
        [9000,()=>{if(SD.dotd){SD.dotd.maskRotSpeed=0.008;SD.dotd.maskPulse=0;}}],
      ]);
    } else if(variant===1){
      // B: Zombies rise from the bottom and dance
      sequence([
        [0,()=>{
          flash(rgba(pc(0),0.5),400);
          if(SD.dotd){
            SD.dotd.zombieActive=true;
            // Spawn 6 zombies — rise from bottom, spread across floor
            const w2=W(),h2=H();
            for(let i=0;i<6;i++){
              setTimeout(()=>{
                const spawnSide=i%2===0?-1:1;
                SD.dotd.zombies.push({
                  x: spawnSide*(w2*0.6+Math.random()*w2*0.2),
                  y: h2*0.78,
                  vx: spawnSide*(-0.4-Math.random()*0.5),
                  sz: 38+Math.random()*20,
                  ph: Math.random()*Math.PI*2,
                  phSpeed: 0.04+Math.random()*0.03,
                  ci: i%4,
                  alpha: 0,
                });
              },i*350);
            }
          }
        }],
        [800,()=>{flash(rgba(pc(1),0.4),300);}],
        [2000,()=>{flash(rgba(pc(2),0.5),200);}],
        [4000,()=>{flash(rgba(pc(3),0.4),300);}],
        [7000,()=>{
          // Zombies start shuffling off
          if(SD.dotd&&SD.dotd.zombies){
            SD.dotd.zombies.forEach(z=>{z.vx=(z.x<W()/2?-1:1)*(1+Math.random());});
          }
        }],
        [10000,()=>{if(SD.dotd)SD.dotd.zombies=[];}],
      ]);
    } else {
      // C: Giant sombrero spins down from above and lands on mask
      sequence([
        [0,()=>{
          flash(rgba(pc(1),0.6),300);
          if(SD.dotd&&!SD.dotd.sombrero){
            const w2=W(),h2=H();
            SD.dotd.sombrero={
              x: w2/2,
              y: -h2*0.3,
              vy: 2.5,
              rot: 0,
              rotSpeed: 0.12,
              wobble: 0,
              worn: false,
            };
          }
        }],
        [500,()=>{flash(rgba(pc(0),0.5),200);}],
        [1200,()=>{flash(rgba(pc(3),0.6),200);}],
        [2000,()=>{
          // Once worn — mask shows off: speed up spin, vibrant flash
          if(SD.dotd&&SD.dotd.sombrero&&SD.dotd.sombrero.worn){
            SD.dotd.maskRotSpeed=0.02;
            flash(rgba(pc(1),0.7),300);
          }
        }],
        [3000,()=>{flash('rgba(255,255,255,0.4)',200);}],
        [4000,()=>{flash(rgba(pc(0),0.5),300);}],
        [6000,()=>{flash(rgba(pc(2),0.4),400);}],
        [9000,()=>{
          // Sombrero flies off upward
          if(SD.dotd&&SD.dotd.sombrero){
            SD.dotd.sombrero.vy=-4;
            SD.dotd.sombrero.worn=false;
          }
          if(SD.dotd)SD.dotd.maskRotSpeed=0.008;
          flash(rgba(pc(1),0.5),300);
        }],
        [11000,()=>{if(SD.dotd){SD.dotd.sombrero=null;SD.dotd.sombreroWorn=false;}}],
      ]);
    }
  }
  else if(sc==='CHINESE_DRAGON'){
    if(variant===0){
      // Dragon breathes fire — giant flash + centerpiece pearl surges
      sequence([[0,()=>{flash(rgba(pc(0),0.8),300);}],[400,()=>{flash('rgba(255,150,0,0.7)',200);}],[800,()=>{if(SD.dragonPath)SD.dragonPath.forEach(p=>{p.vx=p.vx*3||6;});flash('rgba(255,200,50,0.5)',400);}],[2000,()=>{flash(rgba(pc(0),0.5),500);}],[5000,()=>{}]]);
    } else if(variant===1){
      // Second dragon appears — pearl whips wildly
      sequence([[0,()=>{if(SD.pearl){SD.pearl.ph+=Math.PI;};flash(rgba(pc(1),0.6),400);}],[1000,()=>{flash(rgba(pc(0),0.7),300);}],[2000,()=>{if(SD.fog)SD.fog.forEach(f=>f.speed*=5);}],[4000,()=>{if(SD.fog)SD.fog.forEach(f=>f.speed/=5);}],[6000,()=>{}]]);
    } else {
      sequence([[0,()=>{flash(rgba(pc(0),0.9),200);}],[300,()=>{if(SD.pearl)SD.pearl.ph+=Math.PI*0.5;}],[500,()=>{flash('rgba(255,180,0,0.6)',300);}],[1500,()=>{if(SD.fog)SD.fog.forEach(f=>f.speed*=3);flash(rgba(pc(1),0.5),400);}],[4000,()=>{if(SD.fog)SD.fog.forEach(f=>f.speed/=3);}]]);
    }
  }
else if(sc==='MOUNT_OLYMPUS'){
    if(variant===0){
      // A: Thunderstorm — sky fills with rapid bolts, Zeus goes berserk
      sequence([
        [0,()=>{
          flash('rgba(255,255,180,0.6)',200);
          if(SD.zeus)SD.zeus.angry=1;
          for(let i=0;i<5;i++)setTimeout(()=>{SD.lightnings&&SD.lightnings.push(mkLightning());flash('rgba(255,255,255,0.7)',60);},i*120);
        }],
        [800,()=>{
          for(let i=0;i<8;i++)setTimeout(()=>{SD.lightnings&&SD.lightnings.push(mkLightning());},i*80);
          flash('rgba(200,220,255,0.5)',300);
        }],
        [1800,()=>{
          for(let i=0;i<10;i++)setTimeout(()=>{SD.lightnings&&SD.lightnings.push(mkLightning());flash('rgba(255,255,255,0.5)',50);},i*90);
          if(SD.zeus)SD.zeus.tiltSpeed=0.02; // head thrashing
        }],
        [3500,()=>{flash('rgba(255,255,150,0.8)',200);}],
        [4500,()=>{
          for(let i=0;i<6;i++)setTimeout(()=>{SD.lightnings&&SD.lightnings.push(mkLightning());},i*120);
        }],
        [7000,()=>{if(SD.zeus){SD.zeus.tiltSpeed=0.004;SD.zeus.angry=0;}}],
      ]);
    } else if(variant===1){
      // B: Zeus rage — scene shakes, mountains flash, rapid-fire bolts at centerpiece
      sequence([
        [0,()=>{
          flash('rgba(255,255,100,0.9)',150);
          if(SD.zeus){SD.zeus.angry=1;SD.zeus.tiltSpeed=0.025;}
          beatFX.shockwaveR=0;beatFX.shockwaveA=0.9;
        }],
        [200,()=>{flash('rgba(255,200,50,0.7)',100);}],
        [400,()=>{
          flash('rgba(255,255,200,0.6)',150);
          beatFX.shockwaveR=0;beatFX.shockwaveA=0.7;
          // Rapid fire 3 bolts
          if(SD.cpTarget&&SD.cpTarget.alive&&SD.boltsComing){
            const tgt=SD.cpTarget,w2=W(),h2=H();
            for(let i=0;i<3;i++){
              setTimeout(()=>{
                const ex=w2/2+(i-1)*60,ey=h2*0.2;
                const dx=tgt.x-ex,dy=tgt.y-ey,dist=Math.hypot(dx,dy)||1;
                SD.boltsComing.push({x:ex,y:ey,vx:dx/dist*18,vy:dy/dist*18,size:18,life:1.3,ci:1,target:tgt,eyeOrigin:true});
              },i*250);
            }
          }
        }],
        [1800,()=>{
          for(let i=0;i<4;i++)setTimeout(()=>{SD.lightnings&&SD.lightnings.push(mkLightning());flash('rgba(255,255,100,0.5)',80);},i*150);
        }],
        [3500,()=>{flash('rgba(255,255,200,0.4)',500);}],
        [5000,()=>{
          if(SD.cpTarget&&SD.cpTarget.alive&&SD.boltsComing){
            const tgt=SD.cpTarget,w2=W(),h2=H();
            const ex=w2/2,ey=h2*0.2;
            const dx=tgt.x-ex,dy=tgt.y-ey,dist=Math.hypot(dx,dy)||1;
            SD.boltsComing.push({x:ex,y:ey,vx:dx/dist*20,vy:dy/dist*20,size:22,life:1.4,ci:1,target:tgt,eyeOrigin:true});
          }
        }],
        [8000,()=>{if(SD.zeus){SD.zeus.angry=0;SD.zeus.tiltSpeed=0.004;}}],
      ]);
    } else {
      // C: Clouds part, Zeus fully revealed, laughs and unleashes everything at once
      sequence([
        [0,()=>{
          // Clouds scatter outward
          if(SD.clouds)SD.clouds.forEach((cl,i)=>{cl.vx=(i%2===0?1:-1)*(2+Math.random()*2);});
          flash(rgba(pc(1),0.4),600);
        }],
        [800,()=>{
          flash('rgba(255,255,255,0.7)',200);
          if(SD.zeus){SD.zeus.angry=1;SD.zeus.tiltSpeed=0;SD.zeus.tilt=0;} // Face front, centered
        }],
        [1200,()=>{
          flash('rgba(255,255,200,0.9)',150);
          // Massive multi-bolt barrage
          if(SD.cpTarget&&SD.boltsComing){
            const tgt=SD.cpTarget,w2=W(),h2=H();
            const origins=[[-80,-28],[80,-28],[-40,-60],[40,-60],[0,-70]];
            origins.forEach(([ox,oy],i)=>{
              setTimeout(()=>{
                const ex=w2/2+ox,ey=h2*0.2+oy;
                const tx=tgt.alive?tgt.x:w2*0.3+Math.random()*w2*0.4;
                const ty=tgt.alive?tgt.y:h2*0.6;
                const dx=tx-ex,dy=ty-ey,dist=Math.hypot(dx,dy)||1;
                SD.boltsComing.push({x:ex,y:ey,vx:dx/dist*17,vy:dy/dist*17,size:16,life:1.2,ci:i%2===0?1:3,target:tgt.alive?tgt:null,eyeOrigin:true});
              },i*100);
            });
          }
        }],
        [2000,()=>{
          for(let i=0;i<8;i++)setTimeout(()=>{SD.lightnings&&SD.lightnings.push(mkLightning());flash('rgba(255,255,255,0.6)',60);},i*100);
        }],
        [3500,()=>{
          flash('rgba(200,220,255,0.5)',400);
          // Clouds drift back
          if(SD.clouds)SD.clouds.forEach(cl=>{cl.vx=(Math.random()-0.5)*0.2;});
          if(SD.zeus)SD.zeus.tiltSpeed=0.004;
        }],
        [6000,()=>{
          for(let i=0;i<5;i++)setTimeout(()=>{SD.lightnings&&SD.lightnings.push(mkLightning());},i*140);
        }],
        [9000,()=>{if(SD.zeus){SD.zeus.angry=0;}}],
      ]);
    }
  }
  else if(sc==='SUPER_MARIO'){
    if(variant===0){
      // Star power — rainbow flash, everything glows
      sequence([[0,()=>{for(let i=0;i<6;i++)setTimeout(()=>{flash(rgba(pc(i%4),0.6),100);},i*100);}],[700,()=>{beatFX.speedBoost=2;}],[1000,()=>{if(SD.goombas)SD.goombas.forEach(g=>g.vx*=3);}],[3000,()=>{if(SD.goombas)SD.goombas.forEach(g=>g.vx/=3);beatFX.speedBoost=0;}],[5000,()=>{for(let i=0;i<4;i++)setTimeout(()=>{flash(rgba(pc(i%4),0.5),100);},i*100);}]]);
    } else if(variant===1){
      // Bowser stomps in from right side
      sequence([[0,()=>{flash(rgba(pc(0),0.7),300);}],[400,()=>{for(let i=0;i<4;i++)setTimeout(()=>{beatFX.slamS=1.3;setTimeout(()=>beatFX.slamS=1,200);flash(rgba(pc(2),0.5),100);},i*600);}],[3000,()=>{flash('rgba(255,100,0,0.5)',400);}],[6000,()=>{}]]);
    } else {
      sequence([[0,()=>{for(let i=0;i<5;i++)setTimeout(()=>{flash(rgba(pc(i%4),0.5),80);},i*80);}],[500,()=>{beatFX.speedBoost=3;if(SD.coins)SD.coins.forEach(c=>c.ph+=Math.PI);}],[2000,()=>{beatFX.speedBoost=1;}],[4000,()=>{beatFX.speedBoost=0;flash(rgba(pc(1),0.5),400);}]]);
    }
  }
else if(sc==='ATLANTIS'){
    if(variant===0){
      // A: Giant neon whirlpool forms and sucks in fish
      sequence([
        [0,()=>{
          flash(rgba(pc(2),0.5),400);
          if(SD.atl&&!SD.atl.whirlpool){
            SD.atl.whirlpool={
              x:W()*0.5, y:H()*0.45,
              radius:20, maxR:Math.min(W(),H())*0.38,
              growSpeed:2.2, rot:0, speed:0.045,
              alpha:0, fading:false,
            };
          }
        }],
        [600,()=>{flash(rgba(pc(0),0.4),300);}],
        [1500,()=>{flash(rgba(pc(2),0.5),200);}],
        [3000,()=>{flash(rgba(pc(1),0.4),400);}],
        [5000,()=>{flash(rgba(pc(0),0.5),300);}],
        [7000,()=>{
          // Whirlpool starts fading
          if(SD.atl&&SD.atl.whirlpool)SD.atl.whirlpool.fading=true;
        }],
        [10000,()=>{if(SD.atl)SD.atl.whirlpool=null;}],
      ]);
    } else if(variant===1){
      // B: Giant kraken grabs the city with tentacles
      sequence([
        [0,()=>{
          flash(rgba(pc(0),0.7),300);
          if(SD.atl&&!SD.atl.kraken){
            const w2=W(),h2=H(),fl=h2*0.82;
            // Place eye above ruins on the right side
            SD.atl.kraken={
              eyeX:w2*0.78, eyeY:h2*0.18,
              eyeR:h2*0.06,
              age:0, alpha:0, retreating:false,
              tentacles:[
                // Each tentacle: originates near eye, targets a ruin element
                {originX:w2*0.7,  originY:h2*0.22, midX:w2*0.6,  midY:h2*0.45, targetX:w2*0.55, targetY:fl, thickness:14, ph:0, ci:0},
                {originX:w2*0.78, originY:h2*0.28, midX:w2*0.5,  midY:h2*0.5,  targetX:w2*0.38, targetY:fl, thickness:12, ph:1, ci:1},
                {originX:w2*0.85, originY:h2*0.25, midX:w2*0.72, midY:h2*0.55, targetX:w2*0.72, targetY:fl, thickness:10, ph:2, ci:2},
                {originX:w2*0.75, originY:h2*0.32, midX:w2*0.3,  midY:h2*0.4,  targetX:w2*0.25, targetY:fl, thickness:8,  ph:0.5,ci:3},
                {originX:w2*0.82, originY:h2*0.3,  midX:w2*0.62, midY:h2*0.6,  targetX:w2*0.15, targetY:fl, thickness:7,  ph:1.5,ci:0},
              ],
            };
          }
        }],
        [800,()=>{flash(rgba(pc(1),0.5),300);}],
        [1500,()=>{
          // Spawn column debris — kraken pulling things apart
          if(SD.atl){
            const w2=W(),h2=H(),fl=h2*0.82;
            for(let d=0;d<18;d++){
              SD.atl.debris.push({
                x:w2*(0.2+Math.random()*0.6), y:fl-Math.random()*h2*0.25,
                vx:(Math.random()-0.5)*5, vy:-(Math.random()*4+1),
                life:1, rot:Math.random()*Math.PI*2, rotS:(Math.random()-0.5)*0.08,
                sz:8+Math.random()*20, ci:Math.floor(Math.random()*4),
              });
            }
            flash(rgba(pc(0),0.6),200);
          }
        }],
        [3000,()=>{
          // More debris chunks
          if(SD.atl){
            const w2=W(),h2=H(),fl=h2*0.82;
            for(let d=0;d<12;d++){
              SD.atl.debris.push({
                x:w2*(0.3+Math.random()*0.5), y:fl-Math.random()*h2*0.3,
                vx:(Math.random()-0.5)*6, vy:-(Math.random()*5+2),
                life:1, rot:Math.random()*Math.PI*2, rotS:(Math.random()-0.5)*0.1,
                sz:6+Math.random()*16, ci:Math.floor(Math.random()*4),
              });
            }
          }
          flash(rgba(pc(2),0.5),300);
        }],
        [6000,()=>{
          flash(rgba(pc(1),0.4),400);
          if(SD.atl&&SD.atl.kraken)SD.atl.kraken.retreating=true;
        }],
        [9000,()=>{if(SD.atl)SD.atl.kraken=null;}],
      ]);
    } else {
      // C: Neon bubbles rise from bottom and take over screen
      sequence([
        [0,()=>{
          if(SD.atl)SD.atl.bubbleStorm=true;
          flash(rgba(pc(2),0.5),300);
          // Spawn many extra large bubbles from floor
          if(SD.atl){
            const w2=W(),h2=H();
            for(let b=0;b<40;b++){
              SD.atl.bubbles.push({
                x:Math.random()*w2, y:h2+20,
                vy:-(1.5+Math.random()*2.5), r:5+Math.random()*12,
                ph:Math.random()*Math.PI*2, ci:Math.floor(Math.random()*4),
                vx:(Math.random()-0.5)*0.8,
              });
            }
          }
        }],
        [400,()=>{flash(rgba(pc(0),0.4),200);}],
        [900,()=>{flash(rgba(pc(1),0.5),200);}],
        [1500,()=>{flash(rgba(pc(3),0.4),300);}],
        [2500,()=>{flash(rgba(pc(2),0.5),200);}],
        [4000,()=>{flash('rgba(255,255,255,0.3)',200);}],
        [6000,()=>{flash(rgba(pc(0),0.4),400);}],
        [8000,()=>{
          if(SD.atl)SD.atl.bubbleStorm=false;
          // Trim extra bubbles back to normal count
          if(SD.atl&&SD.atl.bubbles.length>35)SD.atl.bubbles.length=35;
        }],
      ]);
    }
  }
  else if(sc==='CARNIVAL'){
    if(variant===0){
      // Ferris wheel spins out of control
      sequence([[0,()=>{flash(rgba(pc(0),0.7),300);}],[400,()=>{if(SD.ferrisRot!=null)SD.ferrisRot+=0.5;flash(rgba(pc(1),0.5),300);}],[1000,()=>{beatFX.speedBoost=3;}],[3000,()=>{flash(rgba(pc(0),0.5),400);}],[5000,()=>{beatFX.speedBoost=0;}],[7000,()=>{}]]);
    } else if(variant===1){
      // Fireworks explosion
      sequence([[0,()=>{for(let i=0;i<5;i++)setTimeout(()=>{beatFX.shockwaveR=0;beatFX.shockwaveA=0.9;flash(rgba(pc(i%4),0.6),100);},i*250);}],[1500,()=>{if(SD.confetti)SD.confetti.forEach(c=>{c.vy*=5;c.vx=(Math.random()-0.5)*6;});}],[3000,()=>{if(SD.confetti)SD.confetti.forEach(c=>{c.vy/=5;c.vx=(Math.random()-0.5)*0.8;});}],[5000,()=>{for(let i=0;i<3;i++)setTimeout(()=>{beatFX.shockwaveR=0;beatFX.shockwaveA=0.7;},i*300);}]]);
    } else {
      sequence([[0,()=>{beatFX.speedBoost=2;flash(rgba(pc(0),0.7),200);}],[500,()=>{if(SD.confetti)SD.confetti.forEach(c=>{c.vy*=4;});flash(rgba(pc(1),0.5),300);}],[2000,()=>{for(let i=0;i<4;i++)setTimeout(()=>{beatFX.shockwaveR=0;beatFX.shockwaveA=0.8;},i*350);}],[5000,()=>{beatFX.speedBoost=0;if(SD.confetti)SD.confetti.forEach(c=>c.vy/=4);}]]);
    }
  }
  else if(sc==='EGYPTIAN_TOMB'){
    if(variant===0){
      // Mummy awakens — wrappings fly
      sequence([[0,()=>{flash(rgba(pc(1),0.6),400);}],[500,()=>{if(SD.hieroglyphs)SD.hieroglyphs.forEach(h=>{h.alpha=1;h.vy=-(1+Math.random()*3);});}],[1000,()=>{flash(rgba(pc(0),0.5),400);}],[2000,()=>{if(SD.traps)for(let i=0;i<6;i++)SD.traps.push({x:Math.random()*W(),y:0,vy:Math.random()*8+4,life:1,ci:Math.floor(Math.random()*4)});}],[4000,()=>{flash(rgba(pc(2),0.5),500);}],[7000,()=>{}]]);
    } else if(variant===1){
      // Trap triggers — spikes, boulders, poison
      sequence([[0,()=>{flash(rgba(pc(1),0.7),300);for(let i=0;i<8;i++)setTimeout(()=>{SD.traps&&SD.traps.push({x:Math.random()*W(),y:0,vy:Math.random()*10+6,life:1,ci:Math.floor(Math.random()*4)});},i*150);}],[1500,()=>{flash(rgba(pc(0),0.6),300);}],[3000,()=>{for(let i=0;i<6;i++)setTimeout(()=>{SD.traps&&SD.traps.push({x:Math.random()*W(),y:0,vy:8,life:1,ci:Math.floor(Math.random()*4)});},i*200);}],[6000,()=>{}]]);
    } else {
      sequence([[0,()=>{flash(rgba(pc(0),0.8),200);}],[300,()=>{if(SD.hieroglyphs)SD.hieroglyphs.forEach(h=>h.alpha=1);flash(rgba(pc(1),0.6),300);}],[1000,()=>{for(let i=0;i<5;i++)setTimeout(()=>{SD.traps&&SD.traps.push({x:Math.random()*W(),y:0,vy:6+i*1.5,life:1,ci:i%4});beatFX.shockwaveR=0;beatFX.shockwaveA=0.5;},i*300);}],[4000,()=>{flash(rgba(pc(2),0.5),500);}]]);
    }
  }
  else{flash(rgba(pc(0),0.7),600);}
}

function showGameOver(){const g=document.getElementById('gameOverScreen');g.style.display='flex';setTimeout(()=>g.style.display='none',2500);}
function doComicBurst(){const panel=document.getElementById('comicPanel');panel.style.display='block';const words=['POW!','ZAP!','BOOM!','WHAM!','KA-BAM!','CRASH!','SLAM!'];const cols=['#ff0','#f0f','#0ff','#f60','#0f0'];panel.innerHTML='';for(let i=0;i<3;i++){const d=document.createElement('div');d.style.cssText=`position:absolute;font-size:${Math.random()*5+4}rem;color:${cols[i%5]};text-shadow:3px 3px 0 #000;left:${Math.random()*70+5}%;top:${Math.random()*70+5}%;transform:rotate(${(Math.random()-0.5)*30}deg);font-family:monospace;font-weight:bold;`;d.textContent=words[Math.floor(Math.random()*words.length)];panel.appendChild(d);}setTimeout(()=>panel.style.display='none',2800);}


// ═══ STATE ═══
let token=null,lastTid=null,inTrans=false;
let THEME={scene:'WARP_SPEED',label:'',splashDesc:'',palette:['#06ffd8','#8338ec','#ff006e','#ffbe0b'],bgColor:'#000010',centerpiece:null,centerpieceScale:0.5,centerpieceBehavior:'rotate',beatReactions:['shockwave'],sceneSpeed:1,sceneIntensity:0.7,energy:0.5,chaos:0.3};
let aiCache={};
let MS={beatInterval:500,lastBeat:0,duration:180000,analysisStart:0,energy:0.5};
let SM={energy:0.5,beatPulse:0};
let SD={};
let songProg=0,progMult=0.6;
let cpRot=0,cpPh=0,cpOrbit=0;
let beatFX={shockwaveR:0,shockwaveA:0,crackLines:[],invertA:0,slamS:1,speedBoost:0,gravityWave:0};
let beatReactionIdx=0,beatCount=0;
let energyHist=[],surpriseFired=false,surpriseArmed=false,midShifted=false;
let gridGlitch=false;

// ═══ ENERGY SPIKE DETECTION ═══
function pushEnergy(e){energyHist.push(e);if(energyHist.length>60)energyHist.shift();}
function spikeDetected(){
  if(energyHist.length<12)return false;
  const recent=energyHist.slice(-3).reduce((a,b)=>a+b,0)/3;
  const base=energyHist.slice(-15,-5).reduce((a,b)=>a+b,0)/10;
  return recent>base+0.25&&recent>0.62;
}

// ═══ BEAT TRIGGER ═══
function triggerBeat(){
  SM.beatPulse=1;beatCount++;
  const reactions=THEME.beatReactions||['shockwave'];
  const reaction=reactions[beatReactionIdx%reactions.length];
  beatReactionIdx++;
  const intensity=0.5+progMult*0.7;
  switch(reaction){
    case 'speed_burst':beatFX.speedBoost=1.5*intensity;break;
    case 'shockwave':beatFX.shockwaveR=0;beatFX.shockwaveA=0.8*intensity;break;
    case 'color_invert':beatFX.invertA=0.45*intensity;break;
    case 'world_crack':spawnCracks();break;
    case 'bass_slam':beatFX.slamS=1+0.12*intensity;break;
    case 'strobe_cut':beatFX.invertA=THEME.energy>0.6?0.8*intensity:0.3;break;
    case 'creature_surge':if(SD.creatures)SD.creatures.push(mkDeepCreature(W(),H()));break;
    case 'cannon_fire':if(SD.cannonballs)SD.cannonballs.push(mkCannonball());break;
    case 'lightning_strike':if(SD.lightnings!=null)SD.lightnings.push(mkLightning());break;
    case 'gravity_wave':beatFX.gravityWave=1;break;
    case 'petal_burst':if(SD.petals)SD.petals.forEach(p=>{p.vx=(Math.random()-0.5)*5;p.vy=-(Math.random()*4+2);});break;
  }
  // Scene-specific beat actions
  const sc=THEME.scene;
  if(sc==='LAVA_WORLD'&&Math.random()<0.4&&SD.eruptions)SD.eruptions.push(mkEruption());
  if(sc==='STORM_CHASER'&&SD.lightnings!=null)SD.lightnings.push(mkLightning());
  if((sc==='MOUNT_OLYMPUS')&&SD.boltsComing&&Math.random()<0.5)SD.boltsComing.push(mkBolt());
  if(sc==='PIRATE_SHIP'&&SD.cannonballs&&Math.random()<0.3)SD.cannonballs.push(mkCannonball());
  if(sc==='JUNKYARD'&&SD.sparks)for(let i=0;i<8;i++)SD.sparks.push(mkSpark(false));
  if(sc==='CARNIVAL'&&SD.ferrisRot!=null)SD.ferrisRot+=0.15;
  if(sc==='OMNIA_NIGHTCLUB'&&SD.chandelierY!=null)SD.chandelierY=Math.max(H()*0.05,SD.chandelierY-20*(1+progMult));
  // Surprise detection
  pushEnergy(SM.energy);
  if(!surpriseFired&&songProg>0.2){
    surpriseArmed=true;
    if(spikeDetected()){setTimeout(fireSurprise,300);surpriseFired=true;}
  }
  if(!surpriseFired&&songProg>0.85){fireSurprise();surpriseFired=true;}
}
function spawnCracks(){const cx=W()/2,cy=H()/2;beatFX.crackLines=Array.from({length:8},()=>{const a=Math.random()*Math.PI*2,len=Math.random()*Math.max(W(),H())*0.7+100;const segs=[];let x2=cx,y2=cy;for(let i=0;i<6;i++){x2+=Math.cos(a+(Math.random()-0.5)*0.8)*len/6;y2+=Math.sin(a+(Math.random()-0.5)*0.8)*len/6;segs.push({x:x2,y:y2});}return{segs,life:1,ci:Math.floor(Math.random()*4)};});}

// ═══ SURPRISE SYSTEM ═══
function flash(color,ms){const o=document.getElementById('surpriseOverlay');o.style.background=color;o.style.transition='opacity 0.08s';o.style.opacity='1';setTimeout(()=>{o.style.transition=`opacity ${ms}ms ease`;o.style.opacity='0';},100);}
// fireSurprise defined above
function showGameOver(){const g=document.getElementById('gameOverScreen');g.style.display='flex';setTimeout(()=>g.style.display='none',2500);}
function doComicBurst(){const panel=document.getElementById('comicPanel');panel.style.display='block';const words=['POW!','ZAP!','BOOM!','WHAM!','KA-BAM!'];const cols=['#ff0','#f0f','#0ff','#f60'];panel.innerHTML='';for(let i=0;i<3;i++){const d=document.createElement('div');d.style.cssText=`position:absolute;font-size:${Math.random()*5+4}rem;color:${cols[i%4]};text-shadow:3px 3px 0 #000;left:${Math.random()*70+5}%;top:${Math.random()*70+5}%;transform:rotate(${(Math.random()-0.5)*30}deg)`;d.textContent=words[Math.floor(Math.random()*words.length)];panel.appendChild(d);}setTimeout(()=>panel.style.display='none',2200);}


// ═══ PARTICLE FACTORIES ═══
function mkEmber(init){return{x:Math.random()*W(),y:init?Math.random()*H():H()+10,vx:(Math.random()-0.5)*2,vy:-(Math.random()*3+1),r:Math.random()*4+1,life:Math.random()*0.6+0.4,ci:Math.floor(Math.random()*2)}}
function mkEruption(){return{x:Math.random()*W(),particles:Array.from({length:35},()=>({vx:(Math.random()-0.5)*10,vy:-(Math.random()*14+6),life:1,ci:Math.floor(Math.random()*2)})),life:1}}
function mkDeepCreature(w,h){return{x:-200,y:Math.random()*(h||H())*0.8+((h||H())*0.05),vx:Math.random()*0.8+0.2,sz:Math.random()*180+60,type:Math.floor(Math.random()*4),ci:Math.floor(Math.random()*4),ph:Math.random()*Math.PI*2,tentacles:Array.from({length:8},()=>({ph:Math.random()*Math.PI*2,len:Math.random()*0.8+0.4}))}}
function mkJungleCreature(w,h){return{x:(w||W())+100,y:((h||H())*0.3)+Math.random()*(h||H())*0.4,vx:-(Math.random()*1+0.3),sz:Math.random()*120+60,type:Math.floor(Math.random()*3),ci:Math.floor(Math.random()*4),ph:Math.random()*Math.PI*2}}
function mkSpark(init){return{x:Math.random()*W(),y:init?Math.random()*H():(H()*0.4+Math.random()*H()*0.3),vx:(Math.random()-0.5)*6,vy:-(Math.random()*8+2),life:Math.random()*0.6+0.2,ci:Math.floor(Math.random()*2)}}
function mkCannonball(){return{x:W()*0.15+Math.random()*W()*0.1,y:H()*0.55,vx:Math.random()*8+4,vy:-(Math.random()*4+2),r:8,life:1}}
function mkLightning(){const w=W(),h=H();let x2=Math.random()*w,y2=0;const segs=[];while(y2<h){const dy=Math.random()*50+20,dx=(Math.random()-0.5)*80;segs.push({x1:x2,y1:y2,x2:x2+dx,y2:y2+dy});x2+=dx;y2+=dy;}return{segs,life:1,ci:Math.floor(Math.random()*4)}}
function mkBolt(){const w=W(),h=H(),cx=w/2+(Math.random()-0.5)*w*0.4;return{x:cx,y:-50,vx:(Math.random()-0.5)*3,vy:Math.random()*8+5,size:Math.random()*30+15,ci:Math.floor(Math.random()*4),life:1}}
function mkDebris(){const a=Math.random()*Math.PI*2,spd=Math.random()*5+2;return{x:Math.random()*W(),y:Math.random()*H(),vx:Math.cos(a)*spd,vy:Math.sin(a)*spd,rot:Math.random()*Math.PI*2,rotS:(Math.random()-0.5)*0.2,sz:Math.random()*30+5,ci:Math.floor(Math.random()*4),type:Math.floor(Math.random()*3)}}

// ═══ SCENE INIT ═══
function initScene(){
  SD={};
  const w=W(),h=H(),sc=THEME.scene;
  if(sc==='WARP_SPEED'||sc==='SPACE_STATION')SD.stars=Array.from({length:500},()=>({x:(Math.random()-0.5)*2,y:(Math.random()-0.5)*2,z:Math.random(),ci:Math.floor(Math.random()*4),trail:[]}));
  if(sc==='LAVA_WORLD'){SD.embers=Array.from({length:200},()=>mkEmber(true));SD.eruptions=[];}
  if(sc==='CYBER_GRID'){SD.gridZ=0;SD.buildings=Array.from({length:30},(_,i)=>({x:(i%6-2.5)*w*0.18,h:Math.random()*h*0.6+h*0.15,w:Math.random()*80+30,z:i/30,ci:i%4}));SD.dataStreams=Array.from({length:40},()=>({x:Math.random()*w,y:Math.random()*h,speed:Math.random()*4+2,ci:Math.floor(Math.random()*4)}));}
  if(sc==='DEEP_SEA'){SD.creatures=Array.from({length:5},()=>mkDeepCreature(w,h));SD.plankton=Array.from({length:150},()=>({x:Math.random()*w,y:Math.random()*h,r:Math.random()*3+0.5,vy:-(Math.random()*0.4+0.1),vx:(Math.random()-0.5)*0.3,ci:Math.floor(Math.random()*4),ph:Math.random()*Math.PI*2}));}
  if(sc==='STORM_CHASER'){SD.debris=Array.from({length:80},()=>mkDebris());SD.lightnings=[];SD.ltTimer=0;SD.tornadoA=0;}
  if(sc==='JUNGLE_RAVE'){SD.plants=Array.from({length:25},(_,i)=>({x:w*(i/24),sz:Math.random()*150+60,ph:Math.random()*Math.PI*2,ci:i%4,type:i%3,glowMult:1}));SD.creatures=Array.from({length:3},()=>mkJungleCreature(w,h));SD.spores=Array.from({length:80},()=>({x:Math.random()*w,y:Math.random()*h,vx:(Math.random()-0.5)*0.8,vy:-(Math.random()*0.5+0.1),r:Math.random()*4+1,ph:Math.random()*Math.PI*2,ci:Math.floor(Math.random()*4)}));}
  if(sc==='DISCO_DIMENSION'){SD.tileZ=0;SD.chandeliers=Array.from({length:3},(_,i)=>({x:w*(0.2+i*0.3),y:h*0.05,rot:Math.random()*Math.PI*2,rotS:0.006+Math.random()*0.01,size:Math.random()*80+60,drop:false}));SD.beams=Array.from({length:20},()=>({x:Math.random()*w,ph:Math.random()*Math.PI*2,ci:Math.floor(Math.random()*4)}));}
  if(sc==='ACID_TRIP'){SD.fracPh=0;SD.colorCyc=0;SD.warpGrid=[];for(let gx=0;gx<=20;gx++)for(let gy=0;gy<=14;gy++)SD.warpGrid.push({gx,gy,ph:Math.random()*Math.PI*2});}
  if(sc==='SPACE_STATION'){SD.debris=Array.from({length:12},()=>({x:Math.random()*w,y:Math.random()*h,vx:(Math.random()-0.5)*0.5,vy:(Math.random()-0.5)*0.3,rot:Math.random()*Math.PI*2,rotS:(Math.random()-0.5)*0.01,sz:Math.random()*40+10,ci:Math.floor(Math.random()*4)}));}
  if(sc==='NEON_CATHEDRAL'){SD.arches=Array.from({length:6},(_,i)=>({depth:i/5,width:1-i*0.12,ci:i%4}));SD.rays=Array.from({length:12},()=>({x:Math.random()*w,width:Math.random()*60+20,alpha:Math.random()*0.3+0.05,ph:Math.random()*Math.PI*2}));SD.motes=Array.from({length:60},()=>({x:Math.random()*w,y:Math.random()*h,vy:-(Math.random()*0.8+0.2),r:Math.random()*2+0.5,ci:Math.floor(Math.random()*4),ph:Math.random()*Math.PI*2}));}
  if(sc==='CLASSIC_ARCADE'){SD.pixels=Array.from({length:200},()=>({x:Math.random()*w,y:Math.random()*h,vx:(Math.random()-0.5)*2,vy:(Math.random()-0.5)*2,size:Math.floor(Math.random()*3+1)*8,ci:Math.floor(Math.random()*4),type:Math.floor(Math.random()*4)}));SD.scanLine=0;SD.mazeLines=Array.from({length:20},()=>{const mx=Math.random()*w,my=Math.random()*h;return{x1:mx,y1:my,x2:mx+(Math.random()-0.5)*200,y2:my+(Math.random()-0.5)*200,ci:Math.floor(Math.random()*4)};});}
  if(sc==='ELECTRIC_FOREST'){SD.trees=Array.from({length:20},(_,i)=>({x:w*(i/19),sz:Math.random()*120+60,ph:Math.random()*Math.PI*2,ci:i%4,glowMult:1}));SD.fairies=Array.from({length:40},()=>({x:Math.random()*w,y:Math.random()*h,vx:(Math.random()-0.5)*1.2,vy:(Math.random()-0.5)*0.8,r:Math.random()*4+2,ph:Math.random()*Math.PI*2,ci:Math.floor(Math.random()*4)}));SD.mushrooms=Array.from({length:12},(_,i)=>({x:w*(i/11),sz:Math.random()*60+30,ci:i%4,ph:Math.random()*Math.PI*2}));}
  if(sc==='OMNIA_NIGHTCLUB'){SD.crowdPeople=Array.from({length:60},()=>({x:Math.random()*w,y:h*0.55+Math.random()*h*0.35,ph:Math.random()*Math.PI*2,sz:Math.random()*25+15,ci:Math.floor(Math.random()*4)}));SD.chandelierY=h*0.05;SD.chandelierRot=0;SD.beams=Array.from({length:24},(_,i)=>({angle:i/24*Math.PI*2,ci:i%4,ph:Math.random()*Math.PI*2,len:Math.random()*h*0.5+h*0.3}));}
  if(sc==='PIRATE_SHIP'){SD.waves=Array.from({length:5},(_,i)=>({ph:Math.random()*Math.PI*2,speed:0.002+i*0.001,amp:30+i*15}));SD.cannonballs=[];SD.stars=Array.from({length:80},()=>({x:Math.random()*w,y:Math.random()*h*0.45,br:Math.random()}));SD.seagulls=Array.from({length:6},()=>({x:Math.random()*w,y:Math.random()*h*0.3,vx:Math.random()*1.5+0.5,ph:0}));}
  if(sc==='JUNKYARD'){SD.sparks=Array.from({length:60},()=>mkSpark(true));SD.arms=Array.from({length:4},(_,i)=>({x:w*(0.15+i*0.23),baseY:h*0.6,angle:-Math.PI*0.6,targetAngle:-Math.PI*0.4,speed:0.02+i*0.005,sz:Math.random()*80+60,ci:i%4}));SD.carStacks=Array.from({length:8},(_,i)=>({x:i/7,cars:Math.floor(Math.random()*3+2),ci:i%4}));}
  if(sc==='SUPERHERO'){SD.cityBuildings=Array.from({length:20},(_,i)=>({x:i*w/19,h:Math.random()*h*0.55+h*0.1,w:Math.random()*60+25,ci:i%4,windows:[]}));SD.cityBuildings.forEach(b=>{for(let wy=5;wy<b.h;wy+=18)for(let wx=4;wx<b.w-4;wx+=14)if(Math.random()<0.6)b.windows.push({x:wx,y:wy,on:Math.random()<0.8});});SD.spotlightA=0;}
  if(sc==='DAY_OF_DEAD'){SD.petals=Array.from({length:120},()=>({x:Math.random()*w,y:Math.random()*h,vx:(Math.random()-0.5)*1.5,vy:Math.random()*1.5+0.3,rot:Math.random()*Math.PI*2,rotS:(Math.random()-0.5)*0.05,sz:Math.random()*10+4,ci:Math.floor(Math.random()*4)}));SD.candles=Array.from({length:12},(_,i)=>({x:w*(i/11),flicker:Math.random()*Math.PI*2,sz:Math.random()*15+10}));SD.skulls=Array.from({length:6},(_,i)=>({x:w*(0.1+i*0.16),y:h*0.4+Math.random()*h*0.2,ph:Math.random()*Math.PI*2,sz:Math.random()*40+25,ci:i%4}));}
  if(sc==='CHINESE_DRAGON'){SD.dragonEmerge=0;SD.fog=Array.from({length:8},()=>({x:Math.random()*w,y:Math.random()*h,r:Math.random()*150+80,ph:Math.random()*Math.PI*2,speed:0.001+Math.random()*0.002}));}
  if(sc==='MOUNT_OLYMPUS'){SD.lightnings=[];SD.ltTimer=0;SD.clouds=Array.from({length:8},()=>({x:Math.random()*w,y:Math.random()*h*0.6,r:Math.random()*120+60,vx:(Math.random()-0.5)*0.3,ci:Math.floor(Math.random()*2)}));SD.boltsComing=[];SD.zeusFace={alpha:0,scale:0.3};}
  if(sc==='SUPER_MARIO'){SD.platforms=Array.from({length:12},(_,i)=>({x:i*w/11,y:h*0.4+Math.sin(i)*h*0.2,w:Math.random()*120+60}));SD.coins=Array.from({length:20},()=>({x:Math.random()*w,y:Math.random()*h*0.7,ph:0}));SD.goombas=Array.from({length:5},()=>({x:Math.random()*w,y:h*0.75,vx:(Math.random()-0.5)*2}));SD.scrollX=0;SD.pipes=Array.from({length:4},(_,i)=>({x:w*(0.15+i*0.23),h:Math.random()*h*0.25+h*0.1}));}
  if(sc==='ATLANTIS'){SD.fish=Array.from({length:30},()=>({x:Math.random()*w,y:Math.random()*h,vx:(Math.random()-0.5)*1.5,vy:(Math.random()-0.5)*0.5,sz:Math.random()*20+8,ci:Math.floor(Math.random()*4)}));SD.bubbles=Array.from({length:60},()=>({x:Math.random()*w,y:Math.random()*h,r:Math.random()*8+2,vy:-(Math.random()*0.8+0.2),ph:Math.random()*Math.PI*2}));SD.ruins=Array.from({length:10},(_,i)=>({x:i/9,h:Math.random()*h*0.4+h*0.1,w:Math.random()*80+30,ci:i%4}));SD.lightShafts=Array.from({length:6},(_,i)=>({x:w*(0.05+i*0.18),ph:Math.random()*Math.PI*2}));}
  if(sc==='CARNIVAL'){SD.ferrisSegs=Array.from({length:12},(_,i)=>({angle:i/12*Math.PI*2,ci:i%4}));SD.ferrisRot=0;SD.confetti=Array.from({length:150},()=>({x:Math.random()*w,y:Math.random()*h,vx:(Math.random()-0.5)*2,vy:Math.random()*2+0.5,rot:Math.random()*Math.PI*2,rotS:(Math.random()-0.5)*0.1,sz:Math.random()*8+3,ci:Math.floor(Math.random()*4)}));SD.tentLights=Array.from({length:16},(_,i)=>({angle:i/16*Math.PI*2,ph:Math.random()*Math.PI*2,ci:i%4}));}
  if(sc==='EGYPTIAN_TOMB'){SD.hieroglyphs=Array.from({length:40},()=>({x:Math.random()*w,y:Math.random()*h,char:Math.floor(Math.random()*12),ci:Math.floor(Math.random()*4),alpha:Math.random()*0.5+0.2}));SD.torches=Array.from({length:6},(_,i)=>({x:(i/5)*0.9+0.05,ph:Math.random()*Math.PI*2}));SD.tunnelZ=0;SD.traps=[];}
  beatFX={shockwaveR:0,shockwaveA:0,crackLines:[],invertA:0,slamS:1,speedBoost:0,gravityWave:0};
  energyHist=[];surpriseFired=false;surpriseArmed=false;midShifted=false;beatReactionIdx=0;beatCount=0;cpRot=0;cpPh=0;cpOrbit=0;cpBounceX=0;cpBounceY=0;cpBounceVX=0.7+(Math.random()-0.5)*0.4;cpBounceVY=0.5+(Math.random()-0.5)*0.3;cpDriftX=0;cpDriftY=0;
}

// ═══ SCENE RENDERERS ═══
function drawWarpSpeed(t){
  const w=W(),h=H(),cx=w/2,cy=h/2;
  x0.fillStyle=THEME.bgColor;x0.fillRect(0,0,w,h);
  if(!SD.stars)return;
  const spd=THEME.sceneSpeed*(0.6+progMult*0.5)*(1+SM.energy)*(1+beatFX.speedBoost*1.5);
  for(const s of SD.stars){
    s.z-=0.0018*spd;if(s.z<0.01){s.z=1;s.x=(Math.random()-0.5)*2;s.y=(Math.random()-0.5)*2;s.trail=[];}
    const px=cx+(s.x/s.z)*cx,py=cy+(s.y/s.z)*cy;
    if(px<-30||px>w+30||py<-30||py>h+30)continue;
    const sz=(1-s.z)*6+0.3;
    if(s.trail.length>1){x0.beginPath();x0.moveTo(s.trail[0].x,s.trail[0].y);for(let i=1;i<s.trail.length;i++)x0.lineTo(s.trail[i].x,s.trail[i].y);x0.lineTo(px,py);x0.strokeStyle=rgba(pc(s.ci),(1-s.z)*0.6);x0.lineWidth=sz*0.5;x0.stroke();}
    s.trail.push({x:px,y:py});if(s.trail.length>8)s.trail.shift();
    x0.beginPath();x0.arc(px,py,sz,0,Math.PI*2);x0.fillStyle=rgba(pc(s.ci),(1-s.z)*0.95);x0.shadowBlur=sz*3;x0.shadowColor=pc(s.ci);x0.fill();x0.shadowBlur=0;
  }
  // INTEGRATED: centerpiece grows from vanishing point — you're flying toward it
  if(THEME.centerpiece){
    cpPh+=0.013;cpRot+=0.007*(1+SM.energy*0.2);
    const appr=Math.min(0.9,0.04+songProg*0.6+SM.beatPulse*0.1);
    const targetSz=Math.min(w,h)*appr*0.85;
    const ag=x0.createRadialGradient(cx,cy,0,cx,cy,targetSz*1.8);
    ag.addColorStop(0,rgba(pc(0),0.1*(1+SM.beatPulse)));ag.addColorStop(1,'transparent');
    x0.fillStyle=ag;x0.beginPath();x0.arc(cx,cy,targetSz*1.8,0,Math.PI*2);x0.fill();
    x0.globalAlpha=Math.min(1,appr*2.2);
    drawCPMini(x0,THEME.centerpiece,cx,cy,targetSz,cpRot);
    x0.globalAlpha=1;
  }
}
function drawLavaWorld(t){
  const w=W(),h=H(),cx=w/2;
  // Sky — deep red/orange gradient, darkens at top
  const sky=x0.createLinearGradient(0,0,0,h);
  sky.addColorStop(0,'rgba(10,0,0,1)');
  sky.addColorStop(0.4,rgba(pc(0),0.5));
  sky.addColorStop(0.7,rgba(pc(1),0.6));
  sky.addColorStop(1,'rgba(255,40,0,0.0)');
  x0.fillStyle=sky;x0.fillRect(0,0,w,h);
  // Ash particles drifting
  if(!SD.ashParts){SD.ashParts=Array.from({length:60},()=>({x:Math.random()*w,y:Math.random()*h,vx:(Math.random()-0.5)*0.4,vy:-(Math.random()*0.5+0.1),r:Math.random()*2.5+0.5,ph:Math.random()*Math.PI*2}));}
  for(const a of SD.ashParts){a.x+=a.vx;a.y+=a.vy;a.ph+=0.02;if(a.y<-5){a.y=h+5;a.x=Math.random()*w;}x0.fillStyle=`rgba(80,60,50,${0.25+Math.sin(a.ph)*0.15})`;x0.beginPath();x0.arc(a.x+Math.sin(a.ph)*2,a.y,a.r,0,Math.PI*2);x0.fill();}
  // Volcano silhouette — black mountain on left/right
  x0.fillStyle='rgba(5,2,2,0.97)';
  x0.beginPath();x0.moveTo(0,h);x0.lineTo(w*0.28,h*0.36);x0.lineTo(w*0.35,h*0.38);x0.lineTo(w*0.42,h*0.36);x0.lineTo(w*0.55,h);x0.closePath();x0.fill();
  x0.beginPath();x0.moveTo(w*0.5,h);x0.lineTo(w*0.65,h*0.45);x0.lineTo(w*0.72,h*0.42);x0.lineTo(w*0.79,h*0.44);x0.lineTo(w,h);x0.closePath();x0.fill();
  // Volcano crater glow
  const cg=x0.createRadialGradient(w*0.35,h*0.36,0,w*0.35,h*0.36,w*0.08*(1+SM.beatPulse*0.4));
  cg.addColorStop(0,rgba(pc(0),0.9*(1+SM.beatPulse*0.3)));cg.addColorStop(0.5,rgba(pc(1),0.4));cg.addColorStop(1,'transparent');
  x0.fillStyle=cg;x0.fillRect(0,0,w,h);
  // Lava rivers — flowing lava layers
  for(let lv=0;lv<4;lv++){
    x0.beginPath();
    for(let px=0;px<=w;px+=4){const py=h*(0.62+lv*0.07)+Math.sin(px*0.008+t*0.0015+lv*1.2)*18+Math.sin(px*0.025+t*0.002)*8;px===0?x0.moveTo(px,py):x0.lineTo(px,py);}
    x0.lineTo(w,h);x0.lineTo(0,h);x0.closePath();
    const lg=x0.createLinearGradient(0,h*0.62,0,h);
    const c0h=h2r(pc(0)),c1h=h2r(pc(1));
    lg.addColorStop(0,`rgba(${c0h.r},${c0h.g},${c0h.b},${0.8*(1+SM.beatPulse*0.15)})`);
    lg.addColorStop(0.4,`rgba(255,${80+lv*20},0,0.75)`);
    lg.addColorStop(1,'rgba(80,0,0,0.9)');
    x0.fillStyle=lg;x0.fill();
    // Lava surface shimmer
    x0.strokeStyle=`rgba(255,${150-lv*20},0,0.3)`;x0.lineWidth=1.5;
  }
  // Embers
  if(!SD.embers)SD.embers=Array.from({length:50},()=>mkEmber(true));
  for(let i=SD.embers.length-1;i>=0;i--){const e=SD.embers[i];e.x+=e.vx;e.y+=e.vy*(1+SM.energy*0.4);e.life-=0.004;if(e.life<=0||e.y<-20){SD.embers[i]=mkEmber(false);continue;}x0.beginPath();x0.arc(e.x,e.y,e.r*e.life,0,Math.PI*2);x0.fillStyle=rgba(pc(e.ci),e.life*0.9);x0.shadowBlur=8;x0.shadowColor=pc(e.ci);x0.fill();x0.shadowBlur=0;}
  // Eruptions — centerpiece-shaped lava balls arc through sky
  if(!SD.eruptions)SD.eruptions=[];
  if(!SD.lavaBalls)SD.lavaBalls=[];
  // Periodic auto-eruption
  SD.eruptTimer=(SD.eruptTimer||0)+16;
  if(SD.eruptTimer>3000+Math.random()*2000){SD.eruptTimer=0;fireLavaBalls();}
  // Lava balls in flight
  for(let i=SD.lavaBalls.length-1;i>=0;i--){
    const lb=SD.lavaBalls[i];
    lb.vx*=0.99;lb.vy+=0.18; // gravity
    lb.x+=lb.vx;lb.y+=lb.vy;
    lb.rot+=lb.rotS;lb.life-=0.008;
    if(lb.life<=0||lb.y>h+50){SD.lavaBalls.splice(i,1);continue;}
    // Draw as mini centerpiece with lava glow
    x0.shadowBlur=lb.sz*0.8;x0.shadowColor=rgba(pc(0),0.9);
    x0.globalAlpha=lb.life*0.9;
    drawCPMini(x0,THEME.centerpiece||'flame',lb.x,lb.y,lb.sz,lb.rot);
    x0.globalAlpha=1;x0.shadowBlur=0;
    // Drip trail
    x0.fillStyle=rgba(pc(1),lb.life*0.4);x0.beginPath();x0.arc(lb.x,lb.y+lb.sz*0.6,lb.sz*0.2,0,Math.PI*2);x0.fill();
  }
  // Old eruption particles
  for(let i=SD.eruptions.length-1;i>=0;i--){const er=SD.eruptions[i];er.life-=0.015;for(const p of er.particles){p.vx*=0.98;p.vy+=0.25;p.life-=0.018;if(p.life>0){x0.beginPath();x0.arc(er.x+p.vx*(1-p.life)*20,er.y-p.vy*(1-p.life)*20,p.life*5,0,Math.PI*2);x0.fillStyle=rgba(pc(p.ci),p.life*0.85);x0.shadowBlur=6;x0.shadowColor=pc(p.ci);x0.fill();x0.shadowBlur=0;}}if(er.life<=0)SD.eruptions.splice(i,1);}
}

function fireLavaBalls(){
  if(!SD.lavaBalls)SD.lavaBalls=[];
  const w=W(),h=H();
  const fromLeft=Math.random()<0.5;
  const startX=fromLeft?w*0.35:w*0.72;
  const startY=h*0.36;
  const count=2+Math.floor(Math.random()*3);
  for(let i=0;i<count;i++){
    const angle=-Math.PI*0.6+Math.random()*Math.PI*0.35;
    const speed=4+Math.random()*5;
    SD.lavaBalls.push({x:startX,y:startY,vx:Math.cos(angle)*speed*(fromLeft?1:-1),vy:Math.sin(angle)*speed,sz:18+Math.random()*22,rot:Math.random()*Math.PI*2,rotS:(Math.random()-0.5)*0.15,life:1,ci:Math.floor(Math.random()*2)});
  }
}

function drawCyberGrid(t){
  const w=W(),h=H(),vpy=h*0.45,vpx=w/2;
  x0.fillStyle=THEME.bgColor;x0.fillRect(0,0,w,h);
  // Grid corruption grows over song
  const corruption=songProg*0.4;
  if(gridGlitch||corruption>0.15){
    const glitchAmt=gridGlitch?0.3:corruption*0.15;
    x0.fillStyle=rgba(pc(0),glitchAmt);
    for(let i=0;i<(gridGlitch?12:3);i++)x0.fillRect(0,Math.random()*h,w,Math.random()*(gridGlitch?40:8)+2);
    if(gridGlitch)for(let i=0;i<5;i++){x0.fillStyle=rgba(pc(i%4),0.1);x0.fillRect(Math.random()*w,0,Math.random()*80+10,h);}
  }
  SD.gridZ=(SD.gridZ||0)+THEME.sceneSpeed*(1+beatFX.speedBoost)*0.012*(1+SM.energy*0.5)*progMult;
  const GRID=12,COLS=24;
  for(let row=0;row<GRID;row++){const z=((row/GRID+SD.gridZ)%1),py=lerp(vpy,h,z),px1=lerp(vpx,0,z),px2=lerp(vpx,w,z),alpha=(0.05+z*0.5)*THEME.sceneIntensity*(1+SM.beatPulse*0.3);
    // Grid color shifts as song progresses
    const ci=Math.floor(row/3+corruption*8)%4;
    x0.strokeStyle=rgba(pc(ci),alpha);x0.lineWidth=1+z*2;x0.shadowBlur=z>0.7?10+corruption*20:0;x0.shadowColor=pc(ci);x0.beginPath();x0.moveTo(px1,py);x0.lineTo(px2,py);x0.stroke();}
  x0.shadowBlur=0;
  for(let col=0;col<=COLS;col++){const nx=(col/COLS-0.5)*2;x0.beginPath();x0.moveTo(vpx+nx*vpx*0.01,vpy);x0.lineTo(vpx+nx*w*0.5,h);x0.strokeStyle=rgba(pc(1),(Math.abs(nx)<0.2?0.4:0.15)*THEME.sceneIntensity);x0.lineWidth=1;x0.stroke();}
  if(SD.buildings)for(const b of SD.buildings){const depth=((b.z+SD.gridZ*0.5)%1),scale=0.1+depth*0.9;const bx=vpx+b.x*(1-depth)*w*0.4,by=vpy+(h-vpy)*depth,bw=b.w*scale,bh=b.h*scale;x0.fillStyle=rgba(pc(b.ci),0.08+depth*0.12+corruption*0.1);x0.fillRect(bx-bw/2,by-bh,bw,bh);x0.strokeStyle=rgba(pc(b.ci),0.4*depth);x0.lineWidth=1;x0.shadowBlur=8*depth+corruption*15;x0.shadowColor=pc(b.ci);x0.strokeRect(bx-bw/2,by-bh,bw,2);x0.shadowBlur=0;}
  if(SD.dataStreams)for(const ds of SD.dataStreams){ds.y=(ds.y+ds.speed*(1+SM.energy*0.5+corruption*0.5))%h;x0.fillStyle=rgba(pc(ds.ci),0.5+corruption*0.3);x0.font='12px Share Tech Mono';x0.fillText(String.fromCharCode(0x30A0+Math.floor(Math.random()*96)),ds.x,ds.y);}
  // Centerpiece as watermark/texture on the grid floor
  if(THEME.centerpiece){
    // INTEGRATED: centerpiece watermark on grid floor horizon
    const gs=Math.min(w,h)*(0.16+SM.beatPulse*0.04)*(1+corruption*0.5);
    cpRot+=0.005; cpPh+=0.013;
    x0.globalAlpha=(0.07+SM.beatPulse*0.08)*(1+corruption*0.6);
    drawCPMini(x0,THEME.centerpiece,vpx,h*0.78,gs,cpRot+SD.gridZ*0.5);
    x0.globalAlpha=1;
  }
}
function drawDeepSea(t){
  const w=W(),h=H();
  x0.fillStyle=THEME.bgColor;x0.fillRect(0,0,w,h);
  // Depth glow evolves over song — gets brighter/more bioluminescent
  const depthGlow=0.3+songProg*0.7;
  for(let i=0;i<3;i++){const gx=w*(0.2+i*0.3)+Math.sin(t*0.0003+i)*w*0.1,gy=h*(0.3+i*0.2)+Math.cos(t*0.0002+i)*h*0.08;const gr=x0.createRadialGradient(gx,gy,0,gx,gy,w*0.25);const gc=h2r(pc(i%4));gr.addColorStop(0,`rgba(${gc.r},${gc.g},${gc.b},${0.06*THEME.sceneIntensity*(1+SM.beatPulse*0.2)*depthGlow})`);gr.addColorStop(1,'transparent');x0.fillStyle=gr;x0.fillRect(0,0,w,h);}
  // Light shafts from above grow as song progresses
  if(songProg>0.2){for(let ls=0;ls<4;ls++){const lx=w*(0.1+ls*0.25)+Math.sin(t*0.0002+ls)*30;x0.save();x0.globalAlpha=(songProg-0.2)*0.06*(1+SM.beatPulse*0.3);const lg=x0.createLinearGradient(lx,0,lx+40,h*0.6);const lc=h2r(pc(ls%4));lg.addColorStop(0,`rgba(${lc.r},${lc.g},${lc.b},1)`);lg.addColorStop(1,'transparent');x0.fillStyle=lg;x0.beginPath();x0.moveTo(lx,0);x0.lineTo(lx+80,0);x0.lineTo(lx+160,h*0.6);x0.lineTo(lx-80,h*0.6);x0.closePath();x0.fill();x0.restore();}}
  if(SD.plankton)for(const p of SD.plankton){p.x+=p.vx;p.y+=p.vy;p.ph+=0.04;if(p.y<-5){p.y=h+5;p.x=Math.random()*w;}const br=Math.sin(p.ph)*0.4+0.6;x0.beginPath();x0.arc(p.x,p.y,p.r*(0.7+br*0.3),0,Math.PI*2);x0.fillStyle=rgba(pc(p.ci),br*0.7*depthGlow);x0.shadowBlur=8*depthGlow;x0.shadowColor=pc(p.ci);x0.fill();x0.shadowBlur=0;}
  if(SD.creatures)for(let i=SD.creatures.length-1;i>=0;i--){const cr=SD.creatures[i];cr.x+=cr.vx*(1+SM.energy*0.3);cr.ph+=0.02;if(cr.x>w+cr.sz*2){SD.creatures[i]=mkDeepCreature(w,h);continue;}x0.save();x0.translate(cr.x,cr.y+Math.sin(cr.ph)*15);const scale=Math.max(0.1,cr.x/w);x0.scale(scale,scale);x0.shadowBlur=30*scale*depthGlow;x0.shadowColor=pc(cr.ci);const alpha=Math.min(1,cr.x/(w*0.3))*THEME.sceneIntensity;x0.strokeStyle=rgba(pc(cr.ci),alpha*0.8);x0.lineWidth=2;x0.beginPath();x0.ellipse(0,0,cr.sz*0.7,cr.sz*0.5*(0.8+Math.sin(cr.ph)*0.2),0,Math.PI,0);x0.stroke();if(cr.tentacles)for(const ten of cr.tentacles){ten.ph+=0.03;x0.beginPath();x0.moveTo(Math.cos(ten.ph)*cr.sz*0.5,0);x0.bezierCurveTo(Math.cos(ten.ph)*cr.sz*0.5+Math.sin(cr.ph+ten.ph)*20,cr.sz,Math.cos(ten.ph)*cr.sz*0.5,cr.sz*1.5*ten.len,Math.cos(ten.ph)*cr.sz*0.5+Math.sin(cr.ph)*10,cr.sz*2*ten.len);x0.strokeStyle=rgba(pc(cr.ci),alpha*0.4);x0.lineWidth=1.5;x0.stroke();}x0.shadowBlur=0;x0.restore();}
  // Centerpiece as the giant creature silhouette emerging from deep
  if(THEME.centerpiece){
    const emerge=0.1+songProg*0.6;
    const creatureSz=Math.min(w,h)*(0.3+emerge*0.4);
    // INTEGRATED: draw centerpiece AS the creature emerging from the deep
    cpPh+=0.013; cpRot+=0.003;
    x0.globalAlpha=emerge*0.82;
    drawCPMini(x0,THEME.centerpiece,w*0.5,h*(0.28+Math.sin(t*0.0004)*0.04),creatureSz,cpRot);
    x0.globalAlpha=1;
  }
}
function drawStormChaser(t){
  const w=W(),h=H(),cx=w/2,cy=h/2;
  const sg=x0.createRadialGradient(cx,cy*0.3,0,cx,h*0.5,h*0.8);const sc=h2r(pc(2));sg.addColorStop(0,`rgba(${sc.r},${sc.g},${sc.b},${0.15*progMult})`);sg.addColorStop(0.5,THEME.bgColor);sg.addColorStop(1,'rgba(0,0,0,0.9)');x0.fillStyle=sg;x0.fillRect(0,0,w,h);
  SD.tornadoA=(SD.tornadoA||0)+0.015*(1+SM.energy);
  for(let ring=0;ring<30;ring++){const z=ring/30,r=z*Math.min(w,h)*0.4*(1+SM.beatPulse*0.1),y2=cy*0.2+z*(h-cy*0.2);x0.beginPath();x0.ellipse(cx,y2,r*0.3,r*0.08,SD.tornadoA+ring*0.15,0,Math.PI*2);x0.strokeStyle=rgba(pc(ring%4),(1-z)*0.15*THEME.sceneIntensity);x0.lineWidth=1.5+z*2;x0.stroke();}
  if(SD.debris)for(const d of SD.debris){d.x+=d.vx*(1+SM.energy*0.5);d.y+=d.vy*(1+SM.energy*0.5);const dx=d.x-cx,dy=d.y-cy,dist=Math.sqrt(dx*dx+dy*dy);if(dist>0){d.x-=dy/dist*1.5;d.y+=dx/dist*1.5;}d.rot+=d.rotS;if(d.x<-60||d.x>w+60||d.y<-60||d.y>h+60)Object.assign(d,mkDebris());x0.save();x0.translate(d.x,d.y);x0.rotate(d.rot);x0.fillStyle=rgba(pc(d.ci),0.5);if(d.type===0)x0.fillRect(-d.sz/2,-d.sz*0.1,d.sz,d.sz*0.2);else{x0.beginPath();x0.arc(0,0,d.sz*0.3,0,Math.PI*2);x0.fill();}x0.restore();}
  // Storm worsens over song - more lightning, faster tornado, heavier rain
  const stormIntensity=0.2+songProg*0.8;
  SD.ltTimer=(SD.ltTimer||0)-16;
  const ltInterval=Math.max(100,600-songProg*400);
  if(SD.ltTimer<0&&SD.lightnings){SD.lightnings.push(mkLightning());if(stormIntensity>0.5)SD.lightnings.push(mkLightning());SD.ltTimer=ltInterval+Math.random()*300;}
  if(SD.lightnings)for(let i=SD.lightnings.length-1;i>=0;i--){const lt=SD.lightnings[i];lt.life-=0.08;if(lt.life<=0){SD.lightnings.splice(i,1);continue;}x0.shadowBlur=20*stormIntensity;x0.shadowColor=pc(lt.ci);for(const seg of lt.segs){x0.beginPath();x0.moveTo(seg.x1,seg.y1);x0.lineTo(seg.x2,seg.y2);x0.strokeStyle=rgba(pc(lt.ci),lt.life*stormIntensity);x0.lineWidth=lt.life*2;x0.stroke();}x0.shadowBlur=0;}
  const rainAlpha=0.1+stormIntensity*0.25;x0.strokeStyle=rgba(pc(2),rainAlpha);x0.lineWidth=0.8;
  for(let i=0;i<Math.floor(100+stormIntensity*200);i++){const rx=Math.random()*w,ry=Math.random()*h;x0.beginPath();x0.moveTo(rx,ry);x0.lineTo(rx-3*stormIntensity,ry+18);x0.stroke();}
  // Centerpiece orbiting the tornado at increasing speed
  if(THEME.centerpiece){
    cpOrbit+=0.015*(1+stormIntensity+SM.beatPulse*0.5);
    const tornadoX=cx,tornadoY=cy*1.2;
    const orbitR=Math.min(w,h)*(0.15+stormIntensity*0.1);
    const orbX=tornadoX+Math.cos(cpOrbit)*orbitR;
    const orbY=tornadoY+Math.sin(cpOrbit)*orbitR*0.4;
    // INTEGRATED: draw centerpiece orbiting tornado
    const osz=Math.min(w,h)*(0.055+SM.beatPulse*0.025);
    cpRot+=0.05; cpPh+=0.013;
    x0.globalAlpha=0.65+stormIntensity*0.35;
    drawCPMini(x0,THEME.centerpiece,orbX,orbY,osz,cpRot);
    x0.globalAlpha=1;
  }
}
function drawJungleRave(t){
  const w=W(),h=H(),cx=w/2;
  // Ground level — standing IN the jungle looking up
  // Floor
  const fl=x0.createLinearGradient(0,h*0.75,0,h);
  fl.addColorStop(0,rgba(pc(2),0.3));fl.addColorStop(1,'rgba(0,10,0,0.95)');
  x0.fillStyle=fl;x0.fillRect(0,h*0.75,w,h*0.25);
  // Root network on floor
  if(!SD.roots){SD.roots=Array.from({length:15},(_,i)=>({x:i/14*w,angle:Math.PI/2+((i%2===0?1:-1)*0.6+Math.random()*0.4),ci:i%4}));}
  x0.shadowBlur=8;
  for(const r of SD.roots){
    x0.strokeStyle=rgba(pc(r.ci),0.25+SM.beatPulse*0.1);x0.lineWidth=3+Math.random();x0.shadowColor=pc(r.ci);
    x0.beginPath();x0.moveTo(r.x,h);
    let rx=r.x,ry=h,ra=r.angle-Math.PI/2;
    for(let seg=0;seg<5;seg++){rx+=Math.cos(ra)*60;ry+=Math.sin(ra)*40;ra+=(Math.random()-0.5)*0.8;x0.lineTo(rx,ry);}
    x0.stroke();
  }
  x0.shadowBlur=0;
  // Massive jungle trees surrounding viewer — tall trunks from bottom, canopy at top
  if(!SD.trees){
    SD.trees=[];
    const positions=[-0.45,-0.3,-0.15,0.15,0.3,0.45,-0.55,0.55];
    for(let i=0;i<positions.length;i++){
      const px=cx+positions[i]*w;
      const scale=1.2-Math.abs(positions[i])*0.6;
      SD.trees.push({x:px,scale,ci:i%4,ph:Math.random()*Math.PI*2,glowMult:1});
    }
  }
  // Draw tree trunks (back to front)
  const sortedTrees=[...SD.trees].sort((a,b)=>b.scale-a.scale);
  for(const tr of sortedTrees){
    tr.ph+=0.006;const glm=tr.glowMult||1;
    const trunkW=30*tr.scale,trunkH=h*0.85*tr.scale;
    // Trunk
    const tg=x0.createLinearGradient(tr.x-trunkW,0,tr.x+trunkW,0);
    tg.addColorStop(0,'rgba(5,15,3,0.95)');tg.addColorStop(0.5,rgba(pc(tr.ci),0.08));tg.addColorStop(1,'rgba(5,15,3,0.95)');
    x0.fillStyle=tg;x0.fillRect(tr.x-trunkW/2,h*0.15,trunkW,h*0.85);
    // Bark detail lines
    x0.strokeStyle=rgba(pc(tr.ci),0.06*glm);x0.lineWidth=1;
    for(let b=0;b<5;b++){x0.beginPath();x0.moveTo(tr.x-trunkW/3+b*(trunkW/5),h*0.2);x0.lineTo(tr.x-trunkW/3+b*(trunkW/5)+Math.sin(b)*5,h*0.9);x0.stroke();}
    // Canopy spread at top
    x0.shadowBlur=25*glm;x0.shadowColor=pc(tr.ci);
    x0.fillStyle=rgba(pc(tr.ci),0.35*glm*(1+SM.beatPulse*0.15));
    x0.beginPath();x0.ellipse(tr.x,h*0.08,trunkW*3.5+Math.sin(tr.ph)*8,h*0.16,0,0,Math.PI*2);x0.fill();
    x0.fillStyle=rgba(pc(tr.ci),0.25*glm);
    x0.beginPath();x0.ellipse(tr.x+Math.sin(tr.ph)*20,h*0.12,trunkW*2.5,h*0.11,Math.sin(tr.ph)*0.1,0,Math.PI*2);x0.fill();
    x0.shadowBlur=0;if(tr.glowMult>1)tr.glowMult*=0.97;
  }
  // Vines hanging from canopy
  if(!SD.vines){SD.vines=Array.from({length:12},(_,i)=>({x:Math.random()*w,len:h*(0.3+Math.random()*0.4),swing:Math.random()*Math.PI*2,swingSpeed:0.01+Math.random()*0.01,ci:i%4}));}
  for(const v of SD.vines){v.swing+=v.swingSpeed;const offset=Math.sin(v.swing)*15;x0.strokeStyle=rgba(pc(v.ci),0.2);x0.lineWidth=2;x0.beginPath();x0.moveTo(v.x,0);for(let s=0;s<8;s++){const sy=s/7*v.len;x0.lineTo(v.x+Math.sin(v.swing+s*0.5)*offset,sy);}x0.stroke();// Leaf nodes
  for(let l=0;l<3;l++){const ly=v.len*(0.3+l*0.3);x0.fillStyle=rgba(pc(v.ci),0.25);x0.beginPath();x0.ellipse(v.x+Math.sin(v.swing+(l+2)*0.5)*offset,ly,8,5,v.swing*0.5,0,Math.PI*2);x0.fill();}}
  // Jungle creatures — birds, insects
  if(!SD.creatures){SD.creatures=Array.from({length:6},()=>mkJungleCreature(w,h));}
  for(let i=SD.creatures.length-1;i>=0;i--){const cr=SD.creatures[i];cr.x+=cr.vx*(1+SM.energy*0.3);cr.ph+=0.02;if(cr.x<-cr.sz*2){SD.creatures[i]=mkJungleCreature(w,h);continue;}x0.save();x0.translate(cr.x,cr.y+Math.sin(cr.ph)*cr.sz*0.08);x0.shadowBlur=20;x0.shadowColor=pc(cr.ci);x0.fillStyle=rgba(pc(cr.ci),0.5*THEME.sceneIntensity*(1+SM.beatPulse*0.15));x0.beginPath();x0.ellipse(0,0,cr.sz*0.5,cr.sz*0.3,0,0,Math.PI*2);x0.fill();x0.shadowBlur=0;x0.restore();}
  // Bioluminescent spores rising
  if(!SD.spores){SD.spores=Array.from({length:50},()=>({x:Math.random()*w,y:Math.random()*h,vx:(Math.random()-0.5)*0.3,vy:-(0.2+Math.random()*0.6),r:1.5+Math.random()*3,ph:Math.random()*Math.PI*2,ci:Math.floor(Math.random()*4)}));}
  for(const sp of SD.spores){sp.x+=sp.vx+Math.sin(sp.ph*0.5)*0.3;sp.y+=sp.vy*(1+SM.energy*0.2);sp.ph+=0.04;if(sp.y<-5){sp.y=h+5;sp.x=Math.random()*w;}const br=Math.sin(sp.ph)*0.4+0.6;x0.beginPath();x0.arc(sp.x,sp.y,sp.r*br,0,Math.PI*2);x0.fillStyle=rgba(pc(sp.ci),br*0.65*(0.4+songProg*0.7));x0.shadowBlur=8*(0.5+songProg);x0.shadowColor=pc(sp.ci);x0.fill();x0.shadowBlur=0;}
  // Centerpiece — bioluminescent fruit hanging at center
  if(THEME.centerpiece){
    cpPh+=0.013;cpRot+=0.015;
    const fruitX=cx+Math.sin(t*0.0006)*w*0.05;
    const fruitY=h*0.32+Math.sin(t*0.0008)*h*0.03;
    const fruitSz=Math.min(w,h)*(0.1+SM.beatPulse*0.04)*(0.4+songProg*0.7);
    // Stem from canopy
    x0.strokeStyle=rgba(pc(2),0.4);x0.lineWidth=3;
    x0.beginPath();x0.moveTo(fruitX,0);x0.bezierCurveTo(fruitX+20,fruitY*0.3,fruitX-15,fruitY*0.6,fruitX,fruitY-fruitSz);x0.stroke();
    // Bio glow halo
    const fg=x0.createRadialGradient(fruitX,fruitY,0,fruitX,fruitY,fruitSz*2.5);
    fg.addColorStop(0,rgba(pc(2),0.18*(1+SM.beatPulse*0.5)));fg.addColorStop(0.5,rgba(pc(0),0.06));fg.addColorStop(1,'transparent');
    x0.fillStyle=fg;x0.fillRect(0,0,w,h);
    x0.shadowBlur=fruitSz*0.9;x0.shadowColor=rgba(pc(2),0.8);
    drawCPMini(x0,THEME.centerpiece,fruitX,fruitY,fruitSz,cpRot);
    x0.shadowBlur=0;
    // Bioluminescent drips
    for(let d=0;d<3;d++){x0.fillStyle=rgba(pc(2),0.3*(1-d*0.3));x0.beginPath();x0.arc(fruitX+(d-1)*fruitSz*0.3,fruitY+fruitSz*(0.6+d*0.25),fruitSz*0.06*(1-d*0.25),0,Math.PI*2);x0.fill();}
  }
}
function drawDiscoDimension(t){
  const w=W(),h=H(),cx=w/2,cy=h/2;
  x0.fillStyle='rgba(5,0,15,1)';x0.fillRect(0,0,w,h);
  // Saturday Night Fever floor — bright illuminated grid squares
  if(!SD.discoFloor){
    const cols=14,rows=10;
    SD.discoFloor=[];
    for(let r=0;r<rows;r++)for(let c=0;c<cols;c++){
      SD.discoFloor.push({r,c,ci:Math.floor(Math.random()*4),ph:Math.random()*Math.PI*2,bright:Math.random()});
    }
    SD.discoFloorCols=cols;SD.discoFloorRows=rows;
  }
  // Draw floor in perspective — vanishing point at cy*0.7
  const vp=cy*0.55;
  const cols=SD.discoFloorCols,rows=SD.discoFloorRows;
  const tileW=w/cols;
  // Animate tile colors
  SD.tileZ=(SD.tileZ||0)+0.006*(1+SM.energy*0.3);
  for(const tile of SD.discoFloor){
    tile.ph+=0.025+SM.beatPulse*0.05;
    // Random flash on beat
    if(SM.beatPulse>0.5&&Math.random()<0.08)tile.ci=Math.floor(Math.random()*4);
    const z=((tile.r/rows+SD.tileZ)%1);
    const y1=lerp(vp,h,z);
    const y2=lerp(vp,h,((tile.r+1)/rows+SD.tileZ)%1);
    if(y1>=y2||y1>h||y2<vp)continue;
    const x1=lerp(cx,tile.c*tileW,z);
    const x2=lerp(cx,(tile.c+1)*tileW,z);
    const bright=0.3+Math.abs(Math.sin(tile.ph))*0.7*(1+SM.beatPulse*0.5);
    const c=h2r(pc(tile.ci));
    x0.fillStyle=`rgba(${c.r},${c.g},${c.b},${bright*0.85})`;
    x0.strokeStyle=`rgba(0,0,0,0.6)`;x0.lineWidth=1;
    x0.beginPath();x0.moveTo(x1,y1);x0.lineTo(x2,y1);x0.lineTo(x2,y2);x0.lineTo(x1,y2);x0.closePath();
    x0.fill();x0.stroke();
    // Inner glow on bright tiles
    if(bright>0.7){x0.shadowBlur=12;x0.shadowColor=pc(tile.ci);x0.fillStyle=`rgba(${c.r},${c.g},${c.b},${(bright-0.6)*0.5})`;x0.fill();x0.shadowBlur=0;}
  }
  // Wall mirrors on sides
  for(let side=0;side<2;side++){
    const mx=side===0?0:w*0.85;
    const mg=x0.createLinearGradient(mx,0,mx+(side===0?w*0.15:-w*0.15),0);
    mg.addColorStop(0,rgba(pc(side%4),0.08*(1+SM.beatPulse*0.3)));
    mg.addColorStop(1,'transparent');
    x0.fillStyle=mg;x0.fillRect(mx,0,side===0?w*0.15:-w*0.15,h);
  }
  // Light beams sweeping from disco ball
  if(!SD.beams)SD.beams=Array.from({length:8},(_,i)=>({angle:i/8*Math.PI*2,speed:(Math.random()-0.5)*0.015,ci:i%4}));
  for(const lb of SD.beams){
    lb.angle+=lb.speed*(1+SM.beatPulse*0.5);
    const bx=cx+Math.cos(lb.angle)*w*0.6;
    const by=h*0.12+Math.sin(lb.angle)*h*0.1;
    x0.save();x0.globalAlpha=0.04*(1+SM.beatPulse*0.6);
    const lg=x0.createLinearGradient(cx,h*0.12,bx,by);
    const lc=h2r(pc(lb.ci));
    lg.addColorStop(0,`rgba(${lc.r},${lc.g},${lc.b},1)`);lg.addColorStop(1,'transparent');
    x0.fillStyle=lg;x0.beginPath();x0.moveTo(cx-8,h*0.12);x0.lineTo(cx+8,h*0.12);x0.lineTo(bx+30,by);x0.lineTo(bx-30,by);x0.closePath();x0.fill();x0.restore();
  }
  // Central disco ball IS the centerpiece
  if(THEME.centerpiece){
    cpRot+=0.04*(1+SM.energy*0.3);cpPh+=0.013;
    const ballSz=Math.min(w,h)*(0.12+SM.beatPulse*0.03);
    x0.shadowBlur=ballSz*0.8;x0.shadowColor=pc(1);
    // Mounting wire
    x0.strokeStyle='rgba(180,180,180,0.6)';x0.lineWidth=2;
    x0.beginPath();x0.moveTo(cx,0);x0.lineTo(cx,h*0.12-ballSz);x0.stroke();
    // The disco ball AS the centerpiece, hanging from ceiling
    drawCPMini(x0,THEME.centerpiece,cx,h*0.12,ballSz,cpRot);
    x0.shadowBlur=0;
    // Cast colored reflections onto floor
    for(let ref=0;ref<12;ref++){
      const ra=ref/12*Math.PI*2+cpRot*2;
      const rd=Math.min(w,h)*(0.2+Math.random()*0.3);
      const rx=cx+Math.cos(ra)*rd,ry=h*0.5+Math.sin(ra)*h*0.2;
      x0.fillStyle=rgba(pc(ref%4),0.08*(1+SM.beatPulse*0.5));
      x0.shadowBlur=20;x0.shadowColor=pc(ref%4);
      x0.beginPath();x0.arc(rx,ry,8+SM.beatPulse*6,0,Math.PI*2);x0.fill();x0.shadowBlur=0;
    }
  }
  // Crowd silhouettes at bottom
  if(!SD.crowd)SD.crowd=Array.from({length:20},(_,i)=>({x:i/20*w+Math.random()*50-25,h:h*0.08+Math.random()*h*0.06,ph:Math.random()*Math.PI*2}));
  for(const p of SD.crowd){p.ph+=0.04*(1+SM.beatPulse*0.5);const bounce=Math.abs(Math.sin(p.ph))*p.h*0.3;x0.fillStyle='rgba(0,0,0,0.8)';x0.fillRect(p.x-8,h-p.h+bounce,16,p.h);x0.beginPath();x0.arc(p.x,h-p.h+bounce-8,9,0,Math.PI*2);x0.fill();}
}
function drawAcidTrip(t){
  const w=W(),h=H();
  SD.fracPh=(SD.fracPh||0)+0.015*(1+SM.energy*0.3);SD.colorCyc=(SD.colorCyc||0)+0.008;
  const ci1=Math.floor(SD.colorCyc)%4,ci2=(Math.floor(SD.colorCyc)+1)%4,frac=SD.colorCyc%1;
  const ac=h2r(pc(ci1)),bc=h2r(pc(ci2));
  x0.fillStyle=`rgb(${Math.round(lerp(ac.r,bc.r,frac)*0.07)},${Math.round(lerp(ac.g,bc.g,frac)*0.07)},${Math.round(lerp(ac.b,bc.b,frac)*0.07)})`;x0.fillRect(0,0,w,h);
  if(!SD.warpGrid)return;
  const gw=w/20,gh=h/14;
  for(const gp of SD.warpGrid){gp.ph+=0.02*(1+SM.energy*0.2);const wx=gp.gx*gw+Math.sin(gp.ph+gp.gy*0.5)*gw*0.7*(0.5+SD.fracPh%1),wy=gp.gy*gh+Math.cos(gp.ph+gp.gx*0.3)*gh*0.7*(0.5+SD.fracPh%1);const gc=Math.floor((gp.gx+gp.gy+SD.colorCyc)%4);x0.fillStyle=rgba(pc(gc),0.5*THEME.sceneIntensity);x0.fillRect(wx-2,wy-2,4,4);}
  for(let gx=0;gx<19;gx++)for(let gy=0;gy<13;gy++){const p1=SD.warpGrid[gy*20+gx],p2=SD.warpGrid[gy*20+gx+1],p3=SD.warpGrid[(gy+1)*20+gx];if(!p1||!p2||!p3)continue;const wx1=p1.gx*gw+Math.sin(p1.ph+p1.gy*0.5)*gw*0.7*(0.5+SD.fracPh%1),wy1=p1.gy*gh+Math.cos(p1.ph+p1.gx*0.3)*gh*0.7*(0.5+SD.fracPh%1);const wx2=p2.gx*gw+Math.sin(p2.ph+p2.gy*0.5)*gw*0.7*(0.5+SD.fracPh%1),wy2=p2.gy*gh+Math.cos(p2.ph+p2.gx*0.3)*gh*0.7*(0.5+SD.fracPh%1);const wx3=p3.gx*gw+Math.sin(p3.ph+p3.gy*0.5)*gw*0.7*(0.5+SD.fracPh%1),wy3=p3.gy*gh+Math.cos(p3.ph+p3.gx*0.3)*gh*0.7*(0.5+SD.fracPh%1);const gc=Math.floor((gx+gy+SD.colorCyc)%4);x0.strokeStyle=rgba(pc(gc),0.2*THEME.sceneIntensity);x0.lineWidth=1;x0.beginPath();x0.moveTo(wx1,wy1);x0.lineTo(wx2,wy2);x0.stroke();x0.beginPath();x0.moveTo(wx1,wy1);x0.lineTo(wx3,wy3);x0.stroke();}
  x0.save();x0.translate(w/2,h/2);for(let seg=0;seg<8;seg++){const r=SD.fracPh+seg/8*Math.PI*2;for(let ri=0;ri<5;ri++){x0.beginPath();x0.arc(0,0,ri*60+SM.beatPulse*20,r,r+Math.PI*2*0.9/8);x0.strokeStyle=rgba(pc((ri+seg)%4),(0.3-ri*0.04)*THEME.sceneIntensity*(1+SM.beatPulse*0.3));x0.lineWidth=3-ri*0.4;x0.stroke();}}x0.restore();
  // Centerpiece melts and warps into grid — appears as distorted ghost in the geometry
  if(THEME.centerpiece){
    // INTEGRATED: centerpiece melts into the warp grid
    const melt=Math.min(1,songProg*1.4);
    const meltX=w/2+Math.sin(SD.fracPh*1.3)*w*0.15*melt;
    const meltY=h/2+Math.cos(SD.fracPh)*h*0.1*melt;
    const ms=Math.min(w,h)*(0.12+SM.beatPulse*0.04);
    cpRot+=0.02*(1+melt);cpPh+=0.013;
    x0.save();
    x0.translate(meltX,meltY);
    x0.scale(1+Math.sin(SD.fracPh*2)*0.25*melt,1+Math.cos(SD.fracPh*1.5)*0.25*melt);
    x0.globalAlpha=(0.2+SM.beatPulse*0.12)*(1+melt*0.4);
    drawCP(x0,THEME.centerpiece,ms,cpPh*100);
    x0.globalAlpha=1;x0.restore();
  }
}
function drawSpaceStation(t){
  const w=W(),h=H(),cx=w/2,cy=h/2;
  x0.fillStyle=THEME.bgColor;x0.fillRect(0,0,w,h);
  const earthR=Math.min(w,h)*0.38;const eg=x0.createRadialGradient(w*0.12,h*0.88,0,w*0.12,h*0.88,earthR);const ec=h2r(pc(2));eg.addColorStop(0,`rgba(${ec.r},${ec.g},${ec.b},0.7)`);eg.addColorStop(0.7,'transparent');x0.fillStyle=eg;x0.fillRect(0,h*0.4,earthR*2,h);
  // Station hull panels - appear and glow as song progresses
  const hullAlpha=songProg*0.2+SM.beatPulse*0.05;
  x0.strokeStyle=rgba(pc(0),hullAlpha);x0.lineWidth=1;
  for(let px2=0;px2<w;px2+=80)for(let py2=0;py2<h;py2+=60){x0.strokeRect(px2,py2,80,60);}
  // Alert flicker as song peaks
  if(songProg>0.6&&SM.beatPulse>0.4){x0.fillStyle=rgba(pc(2),0.04*SM.beatPulse);x0.fillRect(0,0,w,h);}
  if(!SD.stars)return;
  for(const s of SD.stars){s.z-=0.0006*THEME.sceneSpeed*(1+beatFX.speedBoost*0.5);if(s.z<0.01){s.z=1;s.x=(Math.random()-0.5)*2;s.y=(Math.random()-0.5)*2;s.trail=[];}const px=cx+(s.x/s.z)*cx,py=cy+(s.y/s.z)*cy;if(px<-20||px>w+20||py<-20||py>h+20)continue;const sz=(1-s.z)*3+0.3;x0.beginPath();x0.arc(px,py,sz,0,Math.PI*2);x0.fillStyle=rgba(pc(s.ci),(1-s.z)*0.8);x0.fill();}
  if(SD.debris)for(const d of SD.debris){d.x+=d.vx*(1+songProg*0.3);d.y+=d.vy;d.rot+=d.rotS;if(d.x<-60)d.x=w+60;if(d.x>w+60)d.x=-60;if(d.y<-60)d.y=h+60;if(d.y>h+60)d.y=-60;x0.save();x0.translate(d.x,d.y);x0.rotate(d.rot);x0.fillStyle=rgba(pc(d.ci),0.4+songProg*0.2);x0.shadowBlur=songProg>0.5?8:0;x0.shadowColor=pc(d.ci);x0.fillRect(-d.sz/2,-d.sz*0.2,d.sz,d.sz*0.4);x0.shadowBlur=0;x0.restore();}
  // Hull breach effect - centerpiece as debris field symbol
  if(THEME.centerpiece&&SD.hullBreachActive){
    // INTEGRATED: centerpiece IS the station — visible through viewport
    const bs=Math.min(w,h)*(0.2+SM.beatPulse*0.04);
    cpRot+=0.01; cpPh+=0.013;
    x0.globalAlpha=0.2+SM.beatPulse*0.12+songProg*0.15;
    drawCPMini(x0,THEME.centerpiece,cx,cy*0.7,bs,cpRot);
    x0.globalAlpha=1;
  }
}
// Track hull breach state
if(typeof SD.hullBreachActive==='undefined'){}
function drawNeonCathedral(t){
  const w=W(),h=H(),cx=w/2;
  const holyLight=0.35+songProg*0.75;
  const beat=SM.beatPulse;

  // ── Background sky ───────────────────────────────────
  const sky=x0.createLinearGradient(0,0,0,h);
  const sc0=h2r(pc(0)),sc2=h2r(pc(2));
  sky.addColorStop(0,`rgba(${Math.round(sc0.r*0.05)},${Math.round(sc0.g*0.04)},${Math.round(sc0.b*0.08)},1)`);
  sky.addColorStop(0.5,rgba(pc(2),0.12));
  sky.addColorStop(1,'rgba(0,0,0,1)');
  x0.fillStyle=sky;x0.fillRect(0,0,w,h);

  // ── Cathedral state init ─────────────────────────────
  if(!SD.cathedralInit){
    SD.cathedralInit=true;
    // Gargoyles: 2 on each side of main towers, and 2 on buttresses
    SD.gargoyles=[
      {x:cx-w*0.31,y:h*0.32,side:-1,lunge:0,headAngle:0,wingFlare:0,ci:0,sz:90},
      {x:cx+w*0.31,y:h*0.32,side:1, lunge:0,headAngle:0,wingFlare:0,ci:1,sz:90},
      {x:cx-w*0.18,y:h*0.46,side:-1,lunge:0,headAngle:0,wingFlare:0,ci:2,sz:72},
      {x:cx+w*0.18,y:h*0.46,side:1, lunge:0,headAngle:0,wingFlare:0,ci:3,sz:72},
    ];
    SD.ghosts=[];
    SD.ghostSpawnTimer=0;
    SD.angel=null;
    SD.motes=Array.from({length:30},()=>({x:Math.random()*w,y:Math.random()*h,vy:-(0.3+Math.random()*0.5),r:1+Math.random()*2.5,ph:Math.random()*Math.PI*2,ci:Math.floor(Math.random()*4)}));
  }

  // ── Neon line style helper ───────────────────────────
  const neon=(ci,alpha=1,blur=15)=>{
    x0.strokeStyle=rgba(pc(ci),alpha);
    x0.shadowBlur=blur*(1+beat*0.3);
    x0.shadowColor=pc(ci);
  };
  const neonFill=(ci,alpha=1,blur=12)=>{
    x0.fillStyle=rgba(pc(ci),alpha);
    x0.shadowBlur=blur*(1+beat*0.3);
    x0.shadowColor=pc(ci);
  };

  // ── FACADE STRUCTURE ─────────────────────────────────
  // Layout: two tall side towers, central nave with big rose window,
  // flying buttresses, main pointed arch doorway open to interior

  const navW=w*0.36;   // central nave width
  const navH=h*0.82;   // nave height from bottom
  const towW=w*0.13;   // tower width
  const towH=h*0.9;    // tower height
  const ltX=cx-navW/2-towW/2;  // left tower center
  const rtX=cx+navW/2+towW/2;  // right tower center
  const groundY=h*0.95;

  // ── Interior visible through doorway (drawn first, behind facade) ──
  // Receding columns and pews — subtle, perspective
  const doorW=navW*0.42;
  const doorH=h*0.44;
  const doorX=cx-doorW/2;
  const doorTopY=groundY-doorH;

  // Deep dark interior fill
  x0.fillStyle='rgba(2,0,6,0.97)';
  x0.beginPath();
  x0.moveTo(doorX,groundY);
  x0.lineTo(doorX,doorTopY+doorW*0.15);
  x0.bezierCurveTo(doorX,doorTopY,doorX+doorW*0.5,doorTopY-doorW*0.25,doorX+doorW,doorTopY);
  x0.lineTo(doorX+doorW,groundY);
  x0.closePath();
  x0.fill();

  // Interior columns receding — 3 pairs, getting smaller
  for(let col=0;col<3;col++){
    const depth=col/3;
    const colScale=1-depth*0.65;
    const colX1=cx-doorW*0.35*colScale;
    const colX2=cx+doorW*0.35*colScale;
    const colY=groundY-doorH*0.12-col*(doorH*0.22);
    const colH=doorH*(0.5-depth*0.3)*colScale;
    const colAlpha=0.12-depth*0.04;
    x0.lineWidth=3*colScale;
    neon(2,colAlpha,6);
    for(const cx2 of [colX1,colX2]){
      x0.beginPath();x0.moveTo(cx2,colY);x0.lineTo(cx2,colY-colH);
      x0.bezierCurveTo(cx2,colY-colH-colH*0.2,cx2+(colX2-colX1)*0.08,colY-colH-colH*0.25,cx,colY-colH-colH*0.3);
      x0.stroke();
    }
    // Pew hints — horizontal lines
    if(col<2){
      x0.lineWidth=1.5*colScale;
      neon(3,0.06-depth*0.02,4);
      const pewY=groundY-col*doorH*0.08-doorH*0.06;
      x0.beginPath();x0.moveTo(colX1+5,pewY);x0.lineTo(colX2-5,pewY);x0.stroke();
      x0.beginPath();x0.moveTo(colX1+5,pewY-8*colScale);x0.lineTo(colX2-5,pewY-8*colScale);x0.stroke();
    }
  }

  // ── Centerpiece — floating where cross would be, deep in interior ──
  if(THEME.centerpiece){
    const cpX=cx;
    const cpY=groundY-doorH*0.72;
    const cpSz=Math.min(w,h)*(0.07+beat*0.025)*(0.5+holyLight*0.6);
    cpRot+=0.008;cpPh+=0.013;
    // Divine glow radiating from cross position
    const cpGlow=x0.createRadialGradient(cpX,cpY,0,cpX,cpY,cpSz*3);
    cpGlow.addColorStop(0,rgba(pc(0),0.18*(1+beat*0.4)));
    cpGlow.addColorStop(0.5,rgba(pc(1),0.06));
    cpGlow.addColorStop(1,'transparent');
    x0.fillStyle=cpGlow;x0.fillRect(0,0,w,h);
    x0.shadowBlur=cpSz*0.9;x0.shadowColor=rgba(pc(0),0.9);
    drawCPMini(x0,THEME.centerpiece,cpX,cpY,cpSz,cpRot);
    x0.shadowBlur=0;
  }

  // ── FACADE NEON LINES ────────────────────────────────
  // Draw order: far details → close structural

  // Flying buttresses — angled supports from towers to nave walls
  x0.lineWidth=2;
  for(const[bx1,by1,bx2,by2,ci2] of [
    [cx-navW/2,groundY-navH*0.55, ltX+towW*0.4,groundY-towH*0.5, 0],
    [cx+navW/2,groundY-navH*0.55, rtX-towW*0.4,groundY-towH*0.5, 0],
    [cx-navW/2,groundY-navH*0.38, ltX+towW*0.4,groundY-towH*0.32, 1],
    [cx+navW/2,groundY-navH*0.38, rtX-towW*0.4,groundY-towH*0.32, 1],
  ]){
    neon(ci2,0.25*(1+beat*0.2),8);
    x0.lineWidth=2;
    x0.beginPath();
    x0.moveTo(bx1,by1);
    x0.bezierCurveTo(bx1+(bx2-bx1)*0.3,by1-h*0.04,bx1+(bx2-bx1)*0.7,by2-h*0.04,bx2,by2);
    x0.stroke();
  }

  // Left tower
  x0.lineWidth=2.5;
  neon(0,0.55*(1+beat*0.15),12);
  // Tower outline
  x0.beginPath();
  x0.moveTo(ltX-towW/2,groundY);
  x0.lineTo(ltX-towW/2,groundY-towH*0.82);
  // Pointed spire
  x0.lineTo(ltX,groundY-towH);
  x0.lineTo(ltX+towW/2,groundY-towH*0.82);
  x0.lineTo(ltX+towW/2,groundY);
  x0.stroke();
  // Tower windows — lancet arch pairs
  for(let wn=0;wn<3;wn++){
    const wy=groundY-towH*(0.25+wn*0.2);
    const ww=towW*0.28;const wh=h*0.07;
    for(const wxOff of [-ww*0.7,ww*0.7]){
      neon(1,0.4*(1+beat*0.2),10);x0.lineWidth=1.5;
      x0.beginPath();x0.moveTo(ltX+wxOff-ww/2,wy);x0.lineTo(ltX+wxOff-ww/2,wy-wh*0.6);
      x0.bezierCurveTo(ltX+wxOff-ww/2,wy-wh,ltX+wxOff+ww/2,wy-wh,ltX+wxOff+ww/2,wy-wh*0.6);
      x0.lineTo(ltX+wxOff+ww/2,wy);x0.stroke();
    }
  }

  // Right tower (mirror)
  x0.lineWidth=2.5;neon(0,0.55*(1+beat*0.15),12);
  x0.beginPath();
  x0.moveTo(rtX-towW/2,groundY);x0.lineTo(rtX-towW/2,groundY-towH*0.82);
  x0.lineTo(rtX,groundY-towH);x0.lineTo(rtX+towW/2,groundY-towH*0.82);
  x0.lineTo(rtX+towW/2,groundY);x0.stroke();
  for(let wn=0;wn<3;wn++){
    const wy=groundY-towH*(0.25+wn*0.2);
    const ww=towW*0.28;const wh=h*0.07;
    for(const wxOff of [-ww*0.7,ww*0.7]){
      neon(1,0.4*(1+beat*0.2),10);x0.lineWidth=1.5;
      x0.beginPath();x0.moveTo(rtX+wxOff-ww/2,wy);x0.lineTo(rtX+wxOff-ww/2,wy-wh*0.6);
      x0.bezierCurveTo(rtX+wxOff-ww/2,wy-wh,rtX+wxOff+ww/2,wy-wh,rtX+wxOff+ww/2,wy-wh*0.6);
      x0.lineTo(rtX+wxOff+ww/2,wy);x0.stroke();
    }
  }

  // Central nave walls
  x0.lineWidth=2.5;neon(2,0.6*(1+beat*0.12),14);
  x0.beginPath();x0.moveTo(cx-navW/2,groundY);x0.lineTo(cx-navW/2,groundY-navH);x0.stroke();
  x0.beginPath();x0.moveTo(cx+navW/2,groundY);x0.lineTo(cx+navW/2,groundY-navH);x0.stroke();

  // Nave roofline — pointed gothic peak
  x0.lineWidth=3;neon(2,0.7*(1+beat*0.12),14);
  x0.beginPath();
  x0.moveTo(cx-navW/2,groundY-navH);
  x0.lineTo(cx,groundY-navH-h*0.1);
  x0.lineTo(cx+navW/2,groundY-navH);
  x0.stroke();
  // Small spire at nave peak
  neon(1,0.6,12);x0.lineWidth=2;
  x0.beginPath();x0.moveTo(cx,groundY-navH-h*0.1);x0.lineTo(cx,groundY-navH-h*0.17);x0.stroke();
  x0.beginPath();x0.arc(cx,groundY-navH-h*0.17,4,0,Math.PI*2);x0.fill();

  // Rose window — circular tracery above door
  const roseY=groundY-navH*0.72;
  const roseR=navW*0.24*(1+beat*0.05);
  neon(1,0.55*(1+beat*0.25),16);x0.lineWidth=2;
  x0.beginPath();x0.arc(cx,roseY,roseR,0,Math.PI*2);x0.stroke();
  // Inner ring
  neon(0,0.45*(1+beat*0.2),12);x0.lineWidth=1.5;
  x0.beginPath();x0.arc(cx,roseY,roseR*0.62,0,Math.PI*2);x0.stroke();
  // Tracery spokes — rotate slowly
  const traceRot=t*0.0003;
  for(let sp=0;sp<12;sp++){
    const sa=sp/12*Math.PI*2+traceRot;
    neon(sp%4,0.3*(1+beat*0.2),8);x0.lineWidth=1.5;
    x0.beginPath();x0.moveTo(cx,roseY);x0.lineTo(cx+Math.cos(sa)*roseR,roseY+Math.sin(sa)*roseR);x0.stroke();
    // Petal arcs between spokes
    if(sp%2===0){
      const sa2=sa+Math.PI/12;
      x0.beginPath();x0.arc(cx+Math.cos(sa+Math.PI/12)*roseR*0.62,roseY+Math.sin(sa+Math.PI/12)*roseR*0.62,roseR*0.22,0,Math.PI*2);
      neon(sp%4,0.2*(1+beat*0.3),6);x0.stroke();
    }
  }

  // Lancet windows flanking door — tall narrow pointed arches
  for(const[lx2,lci] of [[cx-navW*0.36,3],[cx+navW*0.36,3]]){
    const lwH=h*0.22;const lwW=navW*0.1;
    neon(lci,0.45*(1+beat*0.2),10);x0.lineWidth=2;
    x0.beginPath();x0.moveTo(lx2-lwW/2,groundY-navH*0.12);
    x0.lineTo(lx2-lwW/2,groundY-navH*0.12-lwH*0.55);
    x0.bezierCurveTo(lx2-lwW/2,groundY-navH*0.12-lwH,lx2+lwW/2,groundY-navH*0.12-lwH,lx2+lwW/2,groundY-navH*0.12-lwH*0.55);
    x0.lineTo(lx2+lwW/2,groundY-navH*0.12);x0.stroke();
    // Interior glow in window
    const wglow=x0.createRadialGradient(lx2,groundY-navH*0.12-lwH*0.5,0,lx2,groundY-navH*0.12-lwH*0.5,lwW);
    wglow.addColorStop(0,rgba(pc(lci),0.12*(1+beat*0.3)));wglow.addColorStop(1,'transparent');
    x0.fillStyle=wglow;x0.fillRect(0,0,w,h);
  }

  // Main door arch — big pointed gothic opening
  neon(2,0.8*(1+beat*0.15),18);x0.lineWidth=3;
  x0.beginPath();
  x0.moveTo(doorX,groundY);
  x0.lineTo(doorX,doorTopY+doorW*0.15);
  x0.bezierCurveTo(doorX,doorTopY,doorX+doorW*0.5,doorTopY-doorW*0.25,doorX+doorW,doorTopY);
  x0.lineTo(doorX+doorW,groundY);
  x0.stroke();
  // Door arch inner reveal
  neon(0,0.4*(1+beat*0.2),10);x0.lineWidth=1.5;
  const dInset=doorW*0.08;
  x0.beginPath();
  x0.moveTo(doorX+dInset,groundY);
  x0.lineTo(doorX+dInset,doorTopY+doorW*0.15+dInset*0.5);
  x0.bezierCurveTo(doorX+dInset,doorTopY+dInset,doorX+doorW*0.5,doorTopY-doorW*0.25+dInset*1.2,doorX+doorW-dInset,doorTopY+dInset);
  x0.lineTo(doorX+doorW-dInset,groundY);
  x0.stroke();

  // Ground line
  neon(3,0.35,8);x0.lineWidth=2;
  x0.beginPath();x0.moveTo(0,groundY);x0.lineTo(w,groundY);x0.stroke();

  // ── GARGOYLES ───────────────────────────────────────
  for(const g of SD.gargoyles){
    if(beat>0.5)g.lunge=Math.min(1,g.lunge+0.16);
    else g.lunge*=0.9;
    g.wingFlare+=(beat*0.7-g.wingFlare)*0.12;
    const cpX=cx,cpY=groundY-doorH*0.72;
    const dxa=cpX-g.x,dya=cpY-g.y;
    g.headAngle+=(Math.atan2(dya,dxa)-g.headAngle)*0.018;

    const lunge=g.lunge*22*g.side;
    const gSz=g.sz||85; // larger than before
    x0.save();x0.translate(g.x+lunge,g.y);

    // Full neon line style for this gargoyle
    const gn=(alpha,blur)=>{
      x0.strokeStyle=rgba(pc(g.ci),Math.min(1,alpha*(1+beat*0.2)));
      x0.shadowBlur=blur*(1+beat*0.25);x0.shadowColor=pc(g.ci);
    };
    const gnf=(alpha,blur)=>{
      x0.fillStyle=rgba(pc(g.ci),Math.min(1,alpha*(1+beat*0.2)));
      x0.shadowBlur=blur*(1+beat*0.25);x0.shadowColor=pc(g.ci);
    };

    // ── TAIL — curling behind body ──────────────────────
    gn(0.35,6);x0.lineWidth=2;
    x0.beginPath();
    x0.moveTo(-g.side*gSz*0.05,gSz*0.18);
    x0.bezierCurveTo(
      -g.side*gSz*0.35,gSz*0.35,
      -g.side*gSz*0.4,gSz*0.55+Math.sin(t*0.002)*gSz*0.05,
      -g.side*gSz*0.25,gSz*0.62
    );x0.stroke();

    // ── HAUNCHES & LEGS — crouched gargoyle stance ───────
    gn(0.65,14);x0.lineWidth=3;
    // Hip/haunch mass
    x0.beginPath();x0.ellipse(-g.side*gSz*0.04,gSz*0.15,gSz*0.22,gSz*0.15,0,0,Math.PI*2);x0.stroke();
    gnf(0.12,6);x0.fill();
    // Upper leg
    x0.lineWidth=4;gn(0.6,10);
    x0.beginPath();x0.moveTo(-g.side*gSz*0.08,gSz*0.18);x0.bezierCurveTo(-g.side*gSz*0.14,gSz*0.32,-g.side*gSz*0.2,gSz*0.38,-g.side*gSz*0.22,gSz*0.5);x0.stroke();
    x0.beginPath();x0.moveTo(-g.side*gSz*0.0,gSz*0.18);x0.bezierCurveTo(-g.side*gSz*0.04,gSz*0.32,g.side*gSz*0.06,gSz*0.38,g.side*gSz*0.1,gSz*0.5);x0.stroke();
    // Taloned feet gripping ledge
    gn(0.55,8);x0.lineWidth=2;
    for(const[fx,fy,side2] of [[-g.side*gSz*0.22,gSz*0.5,-1],[g.side*gSz*0.1,gSz*0.5,1]]){
      for(let tk=0;tk<3;tk++){
        const ta=-0.3+tk*0.3;
        x0.beginPath();x0.moveTo(fx,fy);x0.lineTo(fx+Math.cos(ta+Math.PI*0.5)*gSz*0.12*side2,fy+gSz*0.1);x0.stroke();
      }
    }

    // ── TORSO — hunched forward, muscular ─────────────────
    gn(0.72,16);x0.lineWidth=3.5;
    // Spine curve — hunched
    x0.beginPath();
    x0.moveTo(-g.side*gSz*0.04,gSz*0.06);
    x0.bezierCurveTo(-g.side*gSz*0.12,-gSz*0.08,-g.side*gSz*0.2,-gSz*0.22,-g.side*gSz*0.3,-gSz*0.32);
    x0.stroke();
    // Chest / rib cage
    gn(0.6,12);x0.lineWidth=2.5;
    x0.beginPath();x0.ellipse(-g.side*gSz*0.14,-gSz*0.12,gSz*0.2,gSz*0.14,g.side*0.3,0,Math.PI*2);x0.stroke();
    gnf(0.08,4);x0.fill();
    // Belly scales — rows of chevron lines
    gn(0.3,5);x0.lineWidth=1.2;
    for(let sc=0;sc<3;sc++){
      const sy=-gSz*0.02+sc*gSz*0.07;
      x0.beginPath();
      x0.moveTo(-g.side*gSz*0.06,sy);
      x0.bezierCurveTo(-g.side*gSz*0.12,sy-gSz*0.035,g.side*gSz*0.06,sy-gSz*0.035,g.side*gSz*0.1,sy);
      x0.stroke();
    }

    // ── ARMS — forward reaching, clawed ──────────────────
    gn(0.65,12);x0.lineWidth=3.5;x0.lineCap='round';
    // Upper arm
    x0.beginPath();x0.moveTo(-g.side*gSz*0.18,-gSz*0.08);x0.bezierCurveTo(-g.side*gSz*0.3,-gSz*0.16,-g.side*gSz*0.4,-gSz*0.08,-g.side*gSz*0.44,gSz*0.04);x0.stroke();
    // Forearm — reaching forward
    x0.beginPath();x0.moveTo(-g.side*gSz*0.44,gSz*0.04);x0.bezierCurveTo(-g.side*gSz*0.5,gSz*0.14,-g.side*gSz*0.52,gSz*0.24,-g.side*gSz*0.5,gSz*0.34);x0.stroke();
    // Claws gripping ledge
    gn(0.55,8);x0.lineWidth=2;
    for(let cl=0;cl<4;cl++){
      const ca=-0.4+cl*0.28;
      x0.beginPath();x0.moveTo(-g.side*gSz*0.5,gSz*0.34);x0.lineTo(-g.side*gSz*0.5+Math.cos(ca)*gSz*0.1,-g.side*gSz*0.5+Math.sin(ca+Math.PI*0.6)*gSz*0.1+gSz*0.42);x0.stroke();
    }
    // Second arm — slightly raised
    gn(0.58,10);x0.lineWidth=3;
    x0.beginPath();x0.moveTo(-g.side*gSz*0.08,-gSz*0.18);x0.bezierCurveTo(-g.side*gSz*0.18,-gSz*0.3,-g.side*gSz*0.3,-gSz*0.28,-g.side*gSz*0.36,-gSz*0.18);x0.stroke();
    x0.lineCap='butt';

    // ── WINGS — large, membrane, beat-reactive ────────────
    const wf=0.4+g.wingFlare*0.7;
    // Wing membrane — filled translucent
    gnf(0.18+beat*0.08,4);
    x0.beginPath();
    x0.moveTo(g.side*gSz*0.06,-gSz*0.08);
    x0.bezierCurveTo(g.side*gSz*(0.28+wf*0.32),-gSz*(0.38+wf*0.22),g.side*gSz*(0.5+wf*0.28),-gSz*(0.12-wf*0.18),g.side*gSz*(0.45+wf*0.2),gSz*0.22);
    x0.bezierCurveTo(g.side*gSz*0.3,gSz*0.3,g.side*gSz*0.1,gSz*0.22,g.side*gSz*0.0,gSz*0.1);
    x0.fill();
    // Wing outline — primary strokes
    gn(0.52+beat*0.15,10);x0.lineWidth=2.2;
    x0.beginPath();
    x0.moveTo(g.side*gSz*0.06,-gSz*0.08);
    x0.bezierCurveTo(g.side*gSz*(0.28+wf*0.32),-gSz*(0.38+wf*0.22),g.side*gSz*(0.5+wf*0.28),-gSz*(0.12-wf*0.18),g.side*gSz*(0.45+wf*0.2),gSz*0.22);
    x0.stroke();
    // Wing finger bones — 3 spars
    gn(0.4,7);x0.lineWidth=1.5;
    for(let wb=0;wb<3;wb++){
      const wt=(wb+1)/3;
      x0.beginPath();
      x0.moveTo(g.side*gSz*0.06,-gSz*0.08);
      x0.lineTo(g.side*gSz*(0.18+wf*0.3*wt),-gSz*(0.22+wf*0.15*wt));
      x0.lineTo(g.side*gSz*(0.35+wf*0.22*wt),gSz*(0.05+wt*0.12));
      x0.stroke();
    }
    // Wing lower edge
    gn(0.42,8);x0.lineWidth=2;
    x0.beginPath();
    x0.moveTo(g.side*gSz*(0.45+wf*0.2),gSz*0.22);
    x0.bezierCurveTo(g.side*gSz*0.28,gSz*0.3,g.side*gSz*0.1,gSz*0.22,g.side*gSz*0.0,gSz*0.1);
    x0.stroke();

    // ── HEAD — large, horned, detailed ───────────────────
    const hx=-g.side*gSz*0.28+Math.cos(g.headAngle)*gSz*0.08;
    const hy=-gSz*0.42+Math.sin(g.headAngle)*gSz*0.05;
    const hSz=gSz*0.36; // head size

    // Neck
    gn(0.6,10);x0.lineWidth=3;
    x0.beginPath();x0.moveTo(-g.side*gSz*0.2,-gSz*0.28);x0.lineTo(hx+g.side*hSz*0.12,hy+hSz*0.4);x0.stroke();

    // Head mass — angular, reptilian skull
    gn(0.78,18);x0.lineWidth=2.8;
    x0.beginPath();
    x0.moveTo(hx,hy-hSz*0.5);           // crown
    x0.bezierCurveTo(hx+g.side*hSz*0.3,hy-hSz*0.48,hx+g.side*hSz*0.48,hy-hSz*0.25,hx+g.side*hSz*0.45,hy-hSz*0.0);
    x0.bezierCurveTo(hx+g.side*hSz*0.5, hy+hSz*0.22,hx+g.side*hSz*0.35,hy+hSz*0.38,hx+g.side*hSz*0.15,hy+hSz*0.42); // jaw
    x0.bezierCurveTo(hx-g.side*hSz*0.08,hy+hSz*0.45,hx-g.side*hSz*0.3,hy+hSz*0.35,hx-g.side*hSz*0.38,hy+hSz*0.15);
    x0.bezierCurveTo(hx-g.side*hSz*0.42,hy-hSz*0.08,hx-g.side*hSz*0.28,hy-hSz*0.42,hx,hy-hSz*0.5);
    x0.stroke();
    gnf(0.08,3);x0.fill();

    // Brow ridge — heavy
    gn(0.7,12);x0.lineWidth=2.8;
    x0.beginPath();
    x0.moveTo(hx-g.side*hSz*0.38,hy-hSz*0.16);
    x0.bezierCurveTo(hx-g.side*hSz*0.15,hy-hSz*0.3,hx+g.side*hSz*0.15,hy-hSz*0.3,hx+g.side*hSz*0.38,hy-hSz*0.18);
    x0.stroke();

    // Horns — two main curved horns + smaller brow nubs
    gn(0.75,14);x0.lineWidth=2.5;
    // Main left horn
    x0.beginPath();x0.moveTo(hx-g.side*hSz*0.22,hy-hSz*0.44);
    x0.bezierCurveTo(hx-g.side*hSz*0.32,hy-hSz*0.78,hx-g.side*hSz*0.18,hy-hSz*0.98,hx-g.side*hSz*0.08,hy-hSz*1.08);x0.stroke();
    // Main right horn
    x0.beginPath();x0.moveTo(hx+g.side*hSz*0.12,hy-hSz*0.42);
    x0.bezierCurveTo(hx+g.side*hSz*0.24,hy-hSz*0.72,hx+g.side*hSz*0.38,hy-hSz*0.88,hx+g.side*hSz*0.32,hy-hSz*1.0);x0.stroke();
    // Brow nubs
    gn(0.55,8);x0.lineWidth=2;
    x0.beginPath();x0.moveTo(hx-g.side*hSz*0.28,hy-hSz*0.26);x0.lineTo(hx-g.side*hSz*0.36,hy-hSz*0.42);x0.stroke();
    x0.beginPath();x0.moveTo(hx+g.side*hSz*0.08,hy-hSz*0.26);x0.lineTo(hx+g.side*hSz*0.14,hy-hSz*0.4);x0.stroke();

    // Eye socket
    x0.fillStyle='rgba(0,0,0,0.7)';x0.shadowBlur=0;
    x0.beginPath();x0.ellipse(hx+g.side*hSz*0.08,hy-hSz*0.06,hSz*0.18,hSz*0.15,g.headAngle*0.2,0,Math.PI*2);x0.fill();
    // Eye glow — fiery on beat
    gnf(0.55+beat*0.45,12+beat*8);
    x0.strokeStyle=rgba(pc((g.ci+2)%4),0.8+beat*0.2);x0.lineWidth=1.5;x0.shadowColor=pc((g.ci+2)%4);
    x0.beginPath();x0.ellipse(hx+g.side*hSz*0.08,hy-hSz*0.06,hSz*0.12*(1+beat*0.18),hSz*0.09*(1+beat*0.18),0,0,Math.PI*2);x0.stroke();
    gnf(0.9+beat*0.1,15);x0.shadowColor=rgba(pc((g.ci+1)%4),1);
    x0.beginPath();x0.arc(hx+g.side*hSz*0.08,hy-hSz*0.06,hSz*0.065*(1+beat*0.3),0,Math.PI*2);x0.fill();
    // Pupil slit
    x0.fillStyle='rgba(0,0,0,0.92)';x0.shadowBlur=0;
    x0.beginPath();x0.ellipse(hx+g.side*hSz*0.08,hy-hSz*0.06,hSz*0.02,hSz*0.07,0,0,Math.PI*2);x0.fill();

    // Snout / muzzle — protruding
    gn(0.65,12);x0.lineWidth=2.5;
    x0.beginPath();
    x0.moveTo(hx+g.side*hSz*0.28,hy-hSz*0.05);
    x0.bezierCurveTo(hx+g.side*hSz*0.5,hy-hSz*0.1,hx+g.side*hSz*0.55,hy+hSz*0.1,hx+g.side*hSz*0.42,hy+hSz*0.18);
    x0.stroke();
    x0.beginPath();
    x0.moveTo(hx+g.side*hSz*0.28,hy+hSz*0.16);
    x0.bezierCurveTo(hx+g.side*hSz*0.42,hy+hSz*0.22,hx+g.side*hSz*0.5,hy+hSz*0.3,hx+g.side*hSz*0.38,hy+hSz*0.38);
    x0.stroke();
    // Teeth
    gn(0.6,6);x0.lineWidth=1.8;
    for(let tk=0;tk<3;tk++){
      const ty=hy+hSz*(0.16+tk*0.04);
      x0.beginPath();x0.moveTo(hx+g.side*hSz*(0.32+tk*0.06),ty);x0.lineTo(hx+g.side*hSz*(0.32+tk*0.06),ty+hSz*0.1);x0.stroke();
    }
    // Nostril
    gn(0.45,5);x0.lineWidth=1.5;
    x0.beginPath();x0.arc(hx+g.side*hSz*0.44,hy,hSz*0.04,0,Math.PI*2);x0.stroke();

    x0.shadowBlur=0;x0.restore();
  }

    // ── GHOSTS — spawn over time, float toward centerpiece ──
  SD.ghostSpawnTimer+=16;
  const maxGhosts=Math.floor(songProg*12)+1;
  if(SD.ghosts.length<maxGhosts&&SD.ghostSpawnTimer>2500-songProg*1500){
    SD.ghostSpawnTimer=0;
    // Spawn from edges or top
    const side=Math.floor(Math.random()*3);
    const spawnX=side===0?-40:side===1?w+40:Math.random()*w;
    const spawnY=side<2?h*(0.2+Math.random()*0.5):-40;
    SD.ghosts.push({
      x:spawnX,y:spawnY,
      targetX:cx,targetY:groundY-doorH*0.72,
      speed:0.3+Math.random()*0.4,
      wobble:Math.random()*Math.PI*2,
      wobbleSpeed:0.02+Math.random()*0.02,
      orbitAngle:Math.random()*Math.PI*2,
      orbitR:navW*(0.25+Math.random()*0.25),
      orbitting:false,
      alpha:0,
      ci:Math.floor(Math.random()*4),
      fleeing:false,
      fleeVx:0,fleeVy:0,
      sz:0.6+Math.random()*0.7,
    });
  }

  const cpCX=cx,cpCY=groundY-doorH*0.72;
  for(let i=SD.ghosts.length-1;i>=0;i--){
    const g=SD.ghosts[i];
    g.alpha=Math.min(0.7,g.alpha+0.005);
    g.wobble+=g.wobbleSpeed*(1+beat*0.4);

    if(g.fleeing){
      g.x+=g.fleeVx*(1+songProg*0.3);
      g.y+=g.fleeVy*(1+songProg*0.3);
      g.alpha-=0.015;
      if(g.alpha<=0||g.x<-200||g.x>w+200||g.y<-200||g.y>h+200){SD.ghosts.splice(i,1);continue;}
    } else if(!g.orbitting){
      // Float toward centerpiece
      const dx=cpCX-g.x,dy=cpCY-g.y;
      const dist=Math.hypot(dx,dy)||1;
      if(dist<g.orbitR){
        g.orbitting=true;
        g.orbitAngle=Math.atan2(g.y-cpCY,g.x-cpCX);
      } else {
        g.x+=dx/dist*g.speed*(1+beat*0.3);
        g.y+=dy/dist*g.speed*(1+beat*0.3);
      }
    } else {
      // Orbit centerpiece
      g.orbitAngle+=0.008*(1+SM.energy*0.3)*(1+beat*0.3);
      g.orbitR=Math.max(g.orbitR*0.998,navW*0.12); // slowly tighten orbit
      g.x=cpCX+Math.cos(g.orbitAngle)*g.orbitR;
      g.y=cpCY+Math.sin(g.orbitAngle)*g.orbitR*0.55;
    }

    // Draw ghost — teardrop wisp shape
    const gs=35*g.sz;
    const wobX=Math.sin(g.wobble)*6;
    const wobY=Math.cos(g.wobble*0.7)*4;
    x0.save();x0.translate(g.x+wobX,g.y+wobY);x0.globalAlpha=g.alpha;
    x0.shadowBlur=20+beat*10;x0.shadowColor=rgba(pc(g.ci),0.8);

    // Ghost strobing in surprise
    if(SD.ghostStrobe){
      x0.globalAlpha=g.alpha*(0.3+Math.abs(Math.sin(t*0.05+i))*0.7);
      x0.shadowBlur=40+beat*20;
    }

    // Body
    x0.fillStyle=rgba(pc(g.ci),0.35);
    x0.beginPath();
    x0.moveTo(0,-gs*0.55);
    x0.bezierCurveTo(-gs*0.55,-gs*0.55,-gs*0.55,gs*0.2,-gs*0.45,gs*0.5);
    x0.bezierCurveTo(-gs*0.3,gs*0.75,-gs*0.1,gs*0.55,0,gs*0.7);
    x0.bezierCurveTo(gs*0.1,gs*0.55,gs*0.3,gs*0.75,gs*0.45,gs*0.5);
    x0.bezierCurveTo(gs*0.55,gs*0.2,gs*0.55,-gs*0.55,0,-gs*0.55);
    x0.fill();
    // Outline glow
    x0.strokeStyle=rgba(pc(g.ci),0.7);x0.lineWidth=1.5;x0.stroke();
    // Eyes
    x0.fillStyle=rgba(pc((g.ci+2)%4),0.9);
    x0.beginPath();x0.arc(-gs*0.18,-gs*0.1,gs*0.1,0,Math.PI*2);x0.fill();
    x0.beginPath();x0.arc(gs*0.18,-gs*0.1,gs*0.1,0,Math.PI*2);x0.fill();
    x0.fillStyle='rgba(0,0,0,0.8)';
    x0.beginPath();x0.arc(-gs*0.18,-gs*0.1,gs*0.05,0,Math.PI*2);x0.fill();
    x0.beginPath();x0.arc(gs*0.18,-gs*0.1,gs*0.05,0,Math.PI*2);x0.fill();

    x0.shadowBlur=0;x0.restore();
  }

  // ── ANGEL — drawn when active ────────────────────────
  if(SD.angel){
    const ang=SD.angel;
    ang.y+=ang.vy;
    ang.x+=ang.vx;
    ang.vy*=0.96;
    ang.vx*=0.97;
    ang.alpha=Math.min(1,ang.alpha+(ang.entering?0.04:-0.018));
    ang.tilt+=ang.tiltDir*0.006;
    if(Math.abs(ang.tilt)>0.12)ang.tiltDir*=-1;
    ang.wingFlap+=0.04*(1+beat*0.5);

    if(!ang.entering&&ang.alpha<=0){SD.angel=null;}

    x0.save();x0.translate(ang.x,ang.y);x0.rotate(ang.tilt);x0.globalAlpha=ang.alpha;
    const faceR=h*0.14;
    x0.strokeStyle='rgba(255,255,220,0.9)';x0.shadowBlur=30+beat*20;x0.shadowColor='rgba(200,230,255,0.9)';

    // Wings — large, spread, flapping
    const wFlap=Math.sin(ang.wingFlap)*0.18;
    x0.lineWidth=2.5;
    // Left wing
    x0.beginPath();
    x0.moveTo(-faceR*0.3,faceR*0.1);
    x0.bezierCurveTo(-faceR*1.2,-faceR*(0.4+wFlap),-faceR*1.8,-faceR*(0.1-wFlap),-faceR*1.6,faceR*0.5);
    x0.bezierCurveTo(-faceR*1.3,faceR*0.7,-faceR*0.6,faceR*0.6,-faceR*0.3,faceR*0.3);
    x0.stroke();
    // Wing feather lines
    for(let f=0;f<5;f++){
      const fa=f/4;
      x0.lineWidth=1;x0.shadowBlur=8;
      x0.beginPath();
      x0.moveTo(-faceR*(0.3+fa*1.3),faceR*(0.1-fa*0.1+wFlap*fa));
      x0.lineTo(-faceR*(0.5+fa*1.2),faceR*(0.4+fa*0.05));
      x0.stroke();
    }
    // Right wing (mirror)
    x0.lineWidth=2.5;x0.shadowBlur=30+beat*20;
    x0.beginPath();
    x0.moveTo(faceR*0.3,faceR*0.1);
    x0.bezierCurveTo(faceR*1.2,-faceR*(0.4+wFlap),faceR*1.8,-faceR*(0.1-wFlap),faceR*1.6,faceR*0.5);
    x0.bezierCurveTo(faceR*1.3,faceR*0.7,faceR*0.6,faceR*0.6,faceR*0.3,faceR*0.3);
    x0.stroke();
    for(let f=0;f<5;f++){
      const fa=f/4;x0.lineWidth=1;x0.shadowBlur=8;
      x0.beginPath();
      x0.moveTo(faceR*(0.3+fa*1.3),faceR*(0.1-fa*0.1+wFlap*fa));
      x0.lineTo(faceR*(0.5+fa*1.2),faceR*(0.4+fa*0.05));x0.stroke();
    }

    // Robe
    x0.lineWidth=2.5;x0.shadowBlur=20;
    x0.beginPath();x0.moveTo(-faceR*0.35,faceR*0.3);
    x0.bezierCurveTo(-faceR*0.5,faceR*0.9,-faceR*0.55,faceR*1.3,-faceR*0.3,faceR*1.8);
    x0.lineTo(faceR*0.3,faceR*1.8);
    x0.bezierCurveTo(faceR*0.55,faceR*1.3,faceR*0.5,faceR*0.9,faceR*0.35,faceR*0.3);
    x0.stroke();
    // Robe flowing lines
    x0.lineWidth=1.5;x0.shadowBlur=8;
    for(let r=0;r<4;r++){const rx=-faceR*0.2+r*(faceR*0.14);x0.beginPath();x0.moveTo(rx,faceR*0.5);x0.bezierCurveTo(rx+Math.sin(r)*8,faceR*1.1,rx+Math.sin(r+1)*6,faceR*1.5,rx+Math.sin(r*0.7)*4,faceR*1.8);x0.stroke();}

    // Face oval
    x0.lineWidth=2;x0.shadowBlur=25;
    x0.beginPath();x0.ellipse(0,-faceR*0.55,faceR*0.4,faceR*0.52,0,0,Math.PI*2);x0.stroke();
    // Serene eyes (closed, peaceful arcs)
    x0.lineWidth=2;x0.shadowBlur=12;
    x0.beginPath();x0.arc(-faceR*0.16,-faceR*0.62,faceR*0.1,Math.PI*1.1,Math.PI*1.9);x0.stroke();
    x0.beginPath();x0.arc(faceR*0.16,-faceR*0.62,faceR*0.1,Math.PI*1.1,Math.PI*1.9);x0.stroke();
    // Halo
    x0.lineWidth=1.5;x0.shadowBlur=18;
    x0.beginPath();x0.arc(0,-faceR*1.15,faceR*0.45,0,Math.PI*2);x0.stroke();

    x0.shadowBlur=0;x0.restore();

    // Radiant light from angel banishes ghosts
    if(ang.entering&&ang.alpha>0.5){
      const angelGlow=x0.createRadialGradient(ang.x,ang.y,0,ang.x,ang.y,w*0.5);
      angelGlow.addColorStop(0,'rgba(255,255,220,0.08)');angelGlow.addColorStop(1,'transparent');
      x0.fillStyle=angelGlow;x0.fillRect(0,0,w,h);
    }
  }

  // ── Floating motes ───────────────────────────────────
  for(const p of SD.motes){
    p.y+=p.vy*(0.5+holyLight*0.4);p.ph+=0.04;
    if(p.y<-5){p.y=h+5;p.x=Math.random()*w;}
    const br=Math.sin(p.ph)*0.4+0.6;
    x0.beginPath();x0.arc(p.x,p.y,p.r*br,0,Math.PI*2);
    x0.fillStyle=rgba(pc(p.ci),br*0.35*holyLight);
    x0.shadowBlur=4;x0.shadowColor=pc(p.ci);x0.fill();x0.shadowBlur=0;
  }
}
function mkTetPiece(w,h){
  const shapes=[[[0,0],[1,0],[0,1],[1,1]],[[0,0],[1,0],[2,0],[1,1]],[[0,0],[1,0],[2,0],[2,1]],[[0,1],[1,1],[1,0],[2,0]]];
  const s=shapes[Math.floor(Math.random()*shapes.length)];
  return{x:Math.random()*w*0.8+w*0.1,y:-50,vy:0.5+Math.random()*0.8,rot:0,rotS:(Math.random()-0.5)*0.01,blocks:s,ci:Math.floor(Math.random()*4)};
}

function drawGalaShip(ctx,x,y,ci){
  ctx.save();ctx.translate(x,y);
  ctx.fillStyle=rgba(pc(ci),0.85);ctx.shadowBlur=10;ctx.shadowColor=pc(ci);
  ctx.beginPath();ctx.moveTo(0,-14);ctx.lineTo(10,8);ctx.lineTo(5,5);ctx.lineTo(0,10);ctx.lineTo(-5,5);ctx.lineTo(-10,8);ctx.closePath();ctx.fill();
  ctx.fillStyle=rgba(pc((ci+1)%4),0.7);ctx.beginPath();ctx.arc(0,-2,5,0,Math.PI*2);ctx.fill();
  ctx.shadowBlur=0;ctx.restore();
}

function drawClassicArcade(t){
  const w=W(),h=H(),cx=w/2,cy=h/2;
  // CRT background — dark with scanlines
  x0.fillStyle='rgba(0,4,12,1)';x0.fillRect(0,0,w,h);
  // CRT scanlines
  x0.fillStyle='rgba(0,0,0,0.25)';
  for(let y2=0;y2<h;y2+=3)x0.fillRect(0,y2,w,1);
  // Score bar
  x0.fillStyle=rgba(pc(0),0.9);x0.font='bold 18px monospace';x0.textAlign='left';
  x0.fillText(`SCORE: ${Math.floor(songProg*99999).toString().padStart(6,'0')}`,20,30);
  x0.textAlign='right';x0.fillText(`LIVES: ♥♥♥`,w-20,30);x0.textAlign='left';
  x0.fillStyle=rgba(pc(1),0.5);x0.fillRect(0,38,w,2);
  // Maze walls (Pac-Man style blue neon walls)
  if(!SD.mazeLines){
    SD.mazeLines=[];
    const segs=[[0.1,0.15,0.4,0.15],[0.6,0.15,0.9,0.15],[0.1,0.45,0.35,0.45],[0.65,0.45,0.9,0.45],[0.1,0.7,0.45,0.7],[0.55,0.7,0.9,0.7],[0.1,0.15,0.1,0.45],[0.9,0.15,0.9,0.45],[0.4,0.55,0.6,0.55]];
    for(const[x1,y1,x2,y2]of segs)SD.mazeLines.push({x1:x1*w,y1:y1*h+50,x2:x2*w,y2:y2*h+50,ci:2});
  }
  for(const ml of SD.mazeLines){x0.beginPath();x0.moveTo(ml.x1,ml.y1);x0.lineTo(ml.x2,ml.y2);x0.strokeStyle=rgba(pc(2),0.5);x0.lineWidth=3;x0.shadowBlur=8;x0.shadowColor=pc(2);x0.stroke();x0.shadowBlur=0;}
  // Pac-Man — chomps across screen
  if(!SD.pacman)SD.pacman={x:w*0.15,y:h*0.35,dir:1,mouthA:0,mouthS:0.08};
  const pm=SD.pacman;
  pm.x+=1.2*(1+SM.energy*0.4)*pm.dir*(1+beatFX.speedBoost*0.3);
  pm.mouthA+=pm.mouthS*(1+SM.energy*0.3);
  if(pm.mouthA>0.35||pm.mouthA<0)pm.mouthS*=-1;
  if(pm.x>w+40){pm.x=-40;pm.dir=1;pm.y=h*(0.3+Math.random()*0.35);}
  if(pm.x<-40){pm.x=w+40;pm.dir=-1;}
  const mouth=Math.abs(Math.sin(pm.mouthA))*0.45;
  x0.fillStyle='rgba(255,220,0,0.95)';x0.shadowBlur=15;x0.shadowColor='rgba(255,200,0,0.8)';
  x0.beginPath();x0.moveTo(pm.x,pm.y);x0.arc(pm.x,pm.y,22,mouth*(pm.dir>0?1:-1),(Math.PI*2-mouth)*(pm.dir>0?1:-1));x0.closePath();x0.fill();x0.shadowBlur=0;
  // Dots for Pac-Man to eat
  if(!SD.dots){SD.dots=Array.from({length:20},()=>({x:Math.random()*w*0.8+w*0.1,y:h*(0.15+Math.random()*0.6)+50,eaten:false,ph:Math.random()*Math.PI*2}));}
  for(const d of SD.dots){if(d.eaten)continue;d.ph+=0.04;const dist=Math.hypot(pm.x-d.x,pm.y-d.y);if(dist<26){d.eaten=true;continue;}x0.fillStyle=rgba(pc(3),0.9);x0.beginPath();x0.arc(d.x,d.y,5,0,Math.PI*2);x0.fill();}
  if(SD.dots.every(d=>d.eaten))SD.dots.forEach(d=>{d.eaten=false;});
  // Tetris pieces falling
  if(!SD.tetPieces){SD.tetPieces=Array.from({length:5},()=>mkTetPiece(w,h));}
  for(const tp of SD.tetPieces){
    tp.y+=tp.vy*(1+SM.energy*0.3);tp.rot+=tp.rotS;
    if(tp.y>h+100)Object.assign(tp,mkTetPiece(w,h));
    x0.save();x0.translate(tp.x,tp.y);x0.rotate(tp.rot);x0.fillStyle=rgba(pc(tp.ci),0.7);x0.strokeStyle=rgba(pc(tp.ci),0.9);x0.lineWidth=2;
    for(const[bx,by]of tp.blocks){x0.fillRect(bx*20-2,by*20-2,18,18);x0.strokeRect(bx*20-2,by*20-2,18,18);}
    x0.restore();
  }
  // Galaga ships flying in formation
  if(!SD.galaShips){SD.galaShips=Array.from({length:8},(_,i)=>({x:w*0.1+i%4*(w*0.2),y:h*(0.1+Math.floor(i/4)*0.1),ph:i*0.5,ci:i%4}));}
  for(const gs of SD.galaShips){
    gs.ph+=0.015*(1+SM.beatPulse*0.3);
    const sx=gs.x+Math.sin(gs.ph)*30,sy=gs.y+Math.sin(gs.ph*0.5)*10;
    drawGalaShip(x0,sx,sy,gs.ci);
  }
  // Boss in surprise mode
  if(SD.bossActive){
    SD.bossX=(SD.bossX||w*0.7);SD.bossY=(SD.bossY||h*0.3);
    SD.bossX+=Math.sin(t*0.002)*1.5;SD.bossY+=Math.cos(t*0.0015)*1;
    x0.shadowBlur=30;x0.shadowColor=pc(0);
    x0.fillStyle=rgba(pc(0),0.9);
    x0.beginPath();x0.ellipse(SD.bossX,SD.bossY,80,55,0,0,Math.PI*2);x0.fill();
    // Boss eyes
    x0.fillStyle='rgba(255,0,0,0.95)';x0.shadowBlur=15;x0.shadowColor='red';
    for(const[ex,ey]of[[-30,-15],[30,-15]]){x0.beginPath();x0.arc(SD.bossX+ex,SD.bossY+ey,12*(1+SM.beatPulse*0.3),0,Math.PI*2);x0.fill();}
    x0.shadowBlur=0;
    // Shoot at player
    if(!SD.bossShots)SD.bossShots=[];
    if(Math.random()<0.03*(1+SM.energy)){SD.bossShots.push({x:SD.bossX,y:SD.bossY+55,vy:3+SM.energy*2,ci:0});}
    for(let i=SD.bossShots.length-1;i>=0;i--){const bs=SD.bossShots[i];bs.y+=bs.vy;if(bs.y>h){SD.bossShots.splice(i,1);continue;}x0.fillStyle=rgba(pc(bs.ci),0.9);x0.fillRect(bs.x-3,bs.y,6,12);}
  }
  // Centerpiece IS the player ship at bottom
  if(THEME.centerpiece){
    cpPh+=0.013;
    // Ship moves side to side
    const shipX=cx+Math.sin(t*0.0008)*w*0.25;
    const shipY=h*0.82;
    const shipSz=Math.min(w,h)*0.06*(1+SM.beatPulse*0.15);
    // Player ship exhaust
    x0.fillStyle=rgba(pc(1),0.6+Math.sin(t*0.01)*0.3);
    x0.shadowBlur=15;x0.shadowColor=pc(1);
    x0.beginPath();x0.ellipse(shipX,shipY+shipSz*0.8,shipSz*0.15,shipSz*0.4*(0.5+Math.random()*0.5),0,0,Math.PI*2);x0.fill();
    x0.shadowBlur=0;
    drawCPMini(x0,THEME.centerpiece,shipX,shipY,shipSz,0);
    // Player bullets
    if(!SD.playerBullets)SD.playerBullets=[];
    if(Math.random()<0.06*(1+SM.energy)){SD.playerBullets.push({x:shipX,y:shipY-shipSz,vy:-8,ci:1});}
    for(let i=SD.playerBullets.length-1;i>=0;i--){const pb=SD.playerBullets[i];pb.y+=pb.vy;if(pb.y<0){SD.playerBullets.splice(i,1);continue;}x0.fillStyle=rgba(pc(pb.ci),0.9);x0.shadowBlur=8;x0.shadowColor=pc(pb.ci);x0.fillRect(pb.x-2,pb.y,4,12);x0.shadowBlur=0;}
  }
  // CRT vignette
  const cvg=x0.createRadialGradient(cx,cy,h*0.2,cx,cy,h*0.75);cvg.addColorStop(0,'transparent');cvg.addColorStop(1,'rgba(0,0,0,0.65)');x0.fillStyle=cvg;x0.fillRect(0,0,w,h);
  // Scanline sweep
  SD.scanLine=(SD.scanLine||0)+3;SD.scanLine%=h;
  x0.fillStyle='rgba(255,255,255,0.012)';x0.fillRect(0,SD.scanLine,w,2);
}
function drawElectricForest(t){
  const w=W(),h=H();
  const fantasy=Math.min(1,songProg*1.5);
  x0.fillStyle=THEME.bgColor;x0.fillRect(0,0,w,h);
  const gg=x0.createLinearGradient(0,h*0.75,0,h);gg.addColorStop(0,rgba(pc(2),0.2*(1+SM.beatPulse*0.3)));gg.addColorStop(1,'transparent');x0.fillStyle=gg;x0.fillRect(0,h*0.75,w,h*0.25);
  if(SD.trees)for(const tr of SD.trees){tr.ph+=0.008;const glm=tr.glowMult||1;x0.save();x0.translate(tr.x,h*0.78);x0.shadowBlur=20*(fantasy+0.3)*glm;x0.shadowColor=pc(tr.ci);x0.strokeStyle=rgba(pc(tr.ci),0.6+fantasy*0.3);function drawTree(x2,y2,len,angle,depth){if(depth<1||len<8)return;const nx=x2+Math.cos(angle)*len,ny=y2-len;x0.beginPath();x0.moveTo(x2,y2);x0.lineTo(nx,ny);x0.lineWidth=depth*1.5;x0.stroke();drawTree(nx,ny,len*0.65,angle-0.45+Math.sin(tr.ph)*0.1,depth-1);drawTree(nx,ny,len*0.65,angle+0.45+Math.sin(tr.ph+1)*0.1,depth-1);}drawTree(0,0,tr.sz*0.4,0,5);x0.restore();if(tr.glowMult>1)tr.glowMult*=0.99;}
  for(let i=0;SD.trees&&i<SD.trees.length-1;i++){const t1=SD.trees[i],t2=SD.trees[i+1];for(let j=0;j<8;j++){const jx=lerp(t1.x,t2.x,j/7),jy=h*0.5+Math.sin(j/7*Math.PI)*40;x0.beginPath();x0.arc(jx,jy,2+SM.beatPulse*2,0,Math.PI*2);x0.fillStyle=rgba(pc((i+j)%4),0.7+SM.beatPulse*0.3);x0.shadowBlur=8;x0.shadowColor=pc((i+j)%4);x0.fill();x0.shadowBlur=0;}}
  if(fantasy>0.3&&SD.mushrooms)for(const m of SD.mushrooms){m.ph+=0.01;x0.save();x0.translate(m.x,h*0.78);x0.shadowBlur=20*fantasy;x0.shadowColor=pc(m.ci);x0.fillStyle=rgba(pc(m.ci),fantasy*0.8);x0.beginPath();x0.ellipse(0,-m.sz*0.6,m.sz*0.5,m.sz*0.35,0,0,Math.PI*2);x0.fill();x0.fillStyle=rgba(pc((m.ci+1)%4),fantasy*0.6);x0.fillRect(-m.sz*0.1,-m.sz*0.25,m.sz*0.2,m.sz*0.3);x0.restore();}
  if(SD.fairies)for(const f of SD.fairies){f.x+=f.vx+Math.sin(t*0.001+f.ph)*0.5;f.y+=f.vy+Math.cos(t*0.0008+f.ph)*0.5;f.ph+=0.06;if(f.x<0||f.x>w)f.vx*=-1;if(f.y<0||f.y>h)f.vy*=-1;const br=Math.sin(f.ph)*0.4+0.6;x0.beginPath();x0.arc(f.x,f.y,f.r*(0.6+br*0.6),0,Math.PI*2);x0.fillStyle=rgba(pc(f.ci),br*(0.4+fantasy*0.5));x0.shadowBlur=12*fantasy;x0.shadowColor=pc(f.ci);x0.fill();x0.shadowBlur=0;}
}
function drawOmniaNightclub(t){
  const w=W(),h=H(),cx=w/2;
  const beat=SM.beatPulse,energy=SM.energy;

  // ── Init ────────────────────────────────────────────
  if(!SD.omnia){
    // 6 chandelier rings — each independent
    SD.omnia={
      rings:[
        {r:0.08, rot:0,    rotSpeed:0.012,  dir:1,  tilt:0,    ci:0, nodes:16, haywire:false},
        {r:0.15, rot:0.5,  rotSpeed:0.009,  dir:-1, tilt:0.04, ci:1, nodes:24, haywire:false},
        {r:0.22, rot:1.0,  rotSpeed:0.007,  dir:1,  tilt:0.07, ci:2, nodes:32, haywire:false},
        {r:0.29, rot:1.5,  rotSpeed:0.005,  dir:-1, tilt:0.05, ci:3, nodes:40, haywire:false},
        {r:0.37, rot:2.0,  rotSpeed:0.004,  dir:1,  tilt:0.08, ci:0, nodes:50, haywire:false},
        {r:0.46, rot:2.5,  rotSpeed:0.003,  dir:-1, tilt:0.06, ci:1, nodes:60, haywire:false},
      ],
      chanY: h*0.06,
      dropTarget: h*0.06,
      dropPhase: 'resting', // resting | dropping | holding | rising
      dropTimer: 8000 + Math.random()*6000,
      dropCount: 0,
      // Drop triggers: song has 3 planned drops
      dropSchedule: [0.22, 0.48, 0.74],
      lastDropProg: -1,
      laserActive: false,
      co2Active: false,
      co2Alpha: 0,
      haywireActive: false,
      beamRot: 0,
    };
    // Club crowd silhouettes
    SD.crowd = Array.from({length:28},(_,i)=>({
      x: i/27*w*1.1 - w*0.05,
      y: h*0.78 + Math.random()*h*0.06,
      sz: 28+Math.random()*20,
      ph: Math.random()*Math.PI*2,
      phSpeed: 0.03+Math.random()*0.04,
      ci: i%4,
      armL: Math.random()*Math.PI*0.5,
      armR: Math.random()*Math.PI*0.5,
    }));
    // Booth bottle lights
    SD.bottles = Array.from({length:12},(_,i)=>({
      x: (i%6)/5*w*0.85+w*0.075,
      side: i<6 ? 0 : 1,
      ph: Math.random()*Math.PI*2,
      ci: i%4,
    }));
  }
  const O = SD.omnia;

  // ── Background — dark club void ──────────────────────
  x0.fillStyle='rgba(2,0,6,1)';x0.fillRect(0,0,w,h);

  // ── Club perimeter — ceiling grid, walls, LED panels ──
  // Ceiling receding grid from edges toward center vanishing point
  const vanY = h*0.18;
  x0.lineWidth=1;
  for(let g=0;g<8;g++){
    const gx = g/7*w;
    x0.strokeStyle = rgba(pc(g%4), 0.06*(1+beat*0.2));
    x0.shadowBlur = 3; x0.shadowColor = pc(g%4);
    x0.beginPath();x0.moveTo(gx,0);x0.lineTo(cx,vanY);x0.stroke();
  }
  for(let gy=0;gy<5;gy++){
    const yFrac = gy/4;
    const ly = yFrac*vanY;
    const lx1 = cx - cx*yFrac;
    const lx2 = cx + cx*yFrac;
    x0.strokeStyle = rgba(pc(gy%4), 0.05*(1+beat*0.15));
    x0.beginPath();x0.moveTo(lx1,ly);x0.lineTo(lx2,ly);x0.stroke();
  }
  x0.shadowBlur=0;

  // LED wall panels — left and right walls in perspective
  const wallColors = [pc(0),pc(1),pc(2),pc(3)];
  for(let side=0;side<2;side++){
    for(let panel=0;panel<5;panel++){
      const depth = panel/4;
      const panelW = w*0.08*(1-depth*0.6);
      const panelH = h*0.28*(1-depth*0.4);
      const px = side===0 ? w*0.02+panel*(w*0.06) : w*0.98-panel*(w*0.06)-panelW;
      const py = h*0.28-depth*h*0.1;
      const ci = (panel+side*2+Math.floor(t*0.0005))%4;
      const panAlpha = (0.08+depth*0.06)*(1+beat*0.3);
      // LED panel fill
      x0.fillStyle = rgba(pc(ci), panAlpha);
      x0.fillRect(px,py,panelW,panelH);
      // Panel border glow
      x0.strokeStyle = rgba(pc(ci), panAlpha*2.5);
      x0.lineWidth = 1.5; x0.shadowBlur=8; x0.shadowColor=pc(ci);
      x0.strokeRect(px,py,panelW,panelH);
      // Horizontal scan line moving through panel
      const scanY = py+(((t*0.05+panel*30)%panelH));
      x0.strokeStyle = rgba(pc(ci),0.25*(1+beat*0.3));
      x0.lineWidth=2; x0.beginPath();
      x0.moveTo(px,scanY);x0.lineTo(px+panelW,scanY);x0.stroke();
      x0.shadowBlur=0;
    }
  }

  // Upper balcony rail — stretches across top sides
  for(let side=0;side<2;side++){
    const rx = side===0 ? 0 : cx+w*0.08;
    const rw = cx-w*0.08;
    x0.strokeStyle = rgba(pc(side),0.3*(1+beat*0.1));
    x0.lineWidth=2; x0.shadowBlur=6; x0.shadowColor=pc(side);
    x0.beginPath();x0.moveTo(rx,h*0.32);x0.lineTo(rx+rw,h*0.32);x0.stroke();
    // Rail posts
    for(let rp=0;rp<6;rp++){
      const rpx=rx+rp*(rw/5);
      x0.beginPath();x0.moveTo(rpx,h*0.32);x0.lineTo(rpx,h*0.45);x0.stroke();
    }
    x0.shadowBlur=0;
  }

  // ── VIP booths — tiered seating perimeter ───────────
  // Back booth (elevated)
  const boothY = h*0.45;
  x0.fillStyle='rgba(10,5,20,0.9)';
  x0.fillRect(0, boothY, w*0.14, h*0.3);
  x0.fillRect(w*0.86, boothY, w*0.14, h*0.3);
  // Booth top rail with glow
  for(const[bx,bw2,bci] of [[0,w*0.14,2],[w*0.86,w*0.14,3]]){
    x0.strokeStyle=rgba(pc(bci),0.5*(1+beat*0.2));
    x0.lineWidth=3; x0.shadowBlur=12; x0.shadowColor=pc(bci);
    x0.beginPath();x0.moveTo(bx,boothY);x0.lineTo(bx+bw2,boothY);x0.stroke();
    x0.shadowBlur=0;
    // Booth interior — deep couch curve
    x0.strokeStyle=rgba(pc(bci),0.15);x0.lineWidth=2;
    x0.beginPath();x0.moveTo(bx+5,boothY+15);x0.bezierCurveTo(bx+bw2*0.3,boothY+30,bx+bw2*0.7,boothY+30,bx+bw2-5,boothY+15);x0.stroke();
  }

  // Bottle service tables — center stage area top
  for(const bt of SD.bottles){
    bt.ph += 0.04*(1+beat*0.3);
    const btX = bt.x;
    const btY = bt.side===0 ? boothY+h*0.04 : boothY+h*0.04;
    // Bottle glow
    const btAlpha = 0.4+Math.sin(bt.ph)*0.2+beat*0.3;
    x0.shadowBlur=10; x0.shadowColor=pc(bt.ci);
    x0.fillStyle=rgba(pc(bt.ci),btAlpha*0.6);
    x0.fillRect(btX-3,btY-18,6,18);
    // Ice bucket glow
    x0.fillStyle=rgba(pc(bt.ci),btAlpha*0.3);
    x0.beginPath();x0.ellipse(btX,btY,8,4,0,0,Math.PI*2);x0.fill();
    x0.shadowBlur=0;
  }

  // ── Dance floor ──────────────────────────────────────
  const floorY = h*0.74;
  // Floor base fill
  const floorG=x0.createLinearGradient(0,floorY,0,h);
  floorG.addColorStop(0,'rgba(10,5,22,0.98)');floorG.addColorStop(1,'rgba(2,1,6,1)');
  x0.fillStyle=floorG;x0.fillRect(0,floorY,w,h-floorY);

  // Perspective tile grid — converges toward vanishing point (center top of floor)
  const vanPX=cx,vanPY=floorY;
  x0.shadowBlur=0;
  // Diagonal tile lines converging
  for(let col=0;col<=18;col++){
    const px=col/18*w;
    x0.strokeStyle=rgba(pc(col%4),0.11*(1+beat*0.35));
    x0.lineWidth=col%3===0?1.5:0.8;
    x0.shadowBlur=col%3===0?4:1;x0.shadowColor=pc(col%4);
    x0.beginPath();x0.moveTo(px,h);x0.lineTo(vanPX+(px-vanPX)*0.04,vanPY+2);x0.stroke();
  }
  // Horizontal depth lines
  for(let row=0;row<8;row++){
    const rowFrac=row/7;
    const rowY=floorY+(h-floorY)*rowFrac;
    const spread=0.04+(1-rowFrac)*0.96;
    x0.strokeStyle=rgba(pc(row%4),0.1*(1+beat*0.25));
    x0.lineWidth=row===0?2:1;x0.shadowBlur=row===0?6:2;x0.shadowColor=pc(row%4);
    x0.beginPath();x0.moveTo(cx-(cx*spread),rowY);x0.lineTo(cx+(cx*spread),rowY);x0.stroke();
  }
  x0.shadowBlur=0;

  // Tile fill — checkerboard pattern on floor
  for(let row=0;row<7;row++){
    const y1=floorY+(h-floorY)*row/7;
    const y2=floorY+(h-floorY)*(row+1)/7;
    for(let col=0;col<16;col++){
      if((row+col)%2!==0)continue;
      const x1=col/16*w,x2=(col+1)/16*w;
      x0.fillStyle=rgba(pc((row+col)%4),(0.04+beat*0.04)*(1-row*0.08));
      x0.fillRect(x1,y1,x2-x1,y2-y1);
    }
  }

  // Beat-reactive radial pulse from center
  if(beat>0.3){
    const pg=x0.createRadialGradient(cx,floorY+4,0,cx,floorY+4,w*(0.12+beat*0.4));
    pg.addColorStop(0,rgba(pc(0),(beat-0.3)*0.55));
    pg.addColorStop(0.4,rgba(pc(1),(beat-0.3)*0.2));
    pg.addColorStop(1,'transparent');
    x0.fillStyle=pg;x0.fillRect(0,floorY,w,h-floorY);
  }

  // Chandelier light pool on floor — moves with chandelier height
  const poolSize=w*(0.3+O.chanY/h*0.2);
  const poolG=x0.createRadialGradient(cx,floorY+10,0,cx,floorY+10,poolSize);
  poolG.addColorStop(0,rgba(pc(0),0.22*(1+beat*0.4)));
  poolG.addColorStop(0.3,rgba(pc(1),0.1));
  poolG.addColorStop(1,'transparent');
  x0.fillStyle=poolG;x0.fillRect(0,floorY,w,h-floorY);

  // Chandelier reflection rings on floor
  x0.shadowBlur=6;
  for(const ring of O.rings){
    const rSz=ring.r*w*0.55*(1+beat*0.04);
    x0.strokeStyle=rgba(pc(ring.ci),0.22*(1+beat*0.4)*(1-ring.r*0.55));
    x0.lineWidth=1.5; x0.shadowColor=pc(ring.ci);
    x0.beginPath();x0.ellipse(cx,floorY+12,rSz,rSz*0.11,0,0,Math.PI*2);x0.stroke();
  }
  x0.shadowBlur=0;

    // ── Chandelier drop logic ────────────────────────────
  // Check scheduled drops based on song progress
  for(const dp of O.dropSchedule){
    if(songProg>dp && O.lastDropProg<dp){
      O.lastDropProg=dp;
      if(O.dropPhase==='resting'){
        O.dropPhase='dropping';
        O.dropTarget=h*(0.48+Math.random()*0.12); // how far it drops
      }
    }
  }

  // Phase transitions
  if(O.dropPhase==='dropping'){
    O.chanY+=(O.dropTarget-O.chanY)*0.008;
    if(Math.abs(O.chanY-O.dropTarget)<3){
      O.dropPhase='holding';
      O.holdTimer=12000; // hold for 12s (surprise fires here from fireSurprise)
    }
  } else if(O.dropPhase==='holding'){
    O.holdTimer-=16;
    if(O.holdTimer<=0){O.dropPhase='rising';}
  } else if(O.dropPhase==='rising'){
    O.chanY+=(h*0.06-O.chanY)*0.006;
    if(Math.abs(O.chanY-h*0.06)<3){O.dropPhase='resting';}
  } else {
    // Gentle breathing drift
    O.chanY = h*0.06+Math.sin(t*0.0003)*h*0.01;
  }

  // ── CO2 effect ───────────────────────────────────────
  if(O.co2Active){
    O.co2Alpha=Math.min(1,O.co2Alpha+0.025);
    // Billows down from chandelier position
    const co2G=x0.createRadialGradient(cx,O.chanY,0,cx,O.chanY,w*0.7);
    co2G.addColorStop(0,`rgba(240,245,255,${O.co2Alpha*0.92})`);
    co2G.addColorStop(0.4,`rgba(220,235,255,${O.co2Alpha*0.7})`);
    co2G.addColorStop(0.75,`rgba(200,220,255,${O.co2Alpha*0.35})`);
    co2G.addColorStop(1,'transparent');
    x0.fillStyle=co2G;x0.fillRect(0,0,w,h);
    // Billowing turbulence details
    for(let bl=0;bl<8;bl++){
      const bph=t*0.001+bl*0.7;
      const bx=cx+(Math.cos(bph)*w*0.35);
      const by=O.chanY+Math.sin(bph*0.6)*h*0.2+bl*h*0.04;
      const br=80+Math.sin(bph*1.3)*40;
      const bg=x0.createRadialGradient(bx,by,0,bx,by,br);
      bg.addColorStop(0,`rgba(255,255,255,${O.co2Alpha*0.15})`);
      bg.addColorStop(1,'transparent');
      x0.fillStyle=bg;x0.fillRect(0,0,w,h);
    }
  } else {
    O.co2Alpha=Math.max(0,O.co2Alpha-0.015);
    if(O.co2Alpha>0){
      const co2G=x0.createRadialGradient(cx,O.chanY,0,cx,O.chanY,w*0.7);
      co2G.addColorStop(0,`rgba(240,245,255,${O.co2Alpha*0.92})`);
      co2G.addColorStop(1,'transparent');
      x0.fillStyle=co2G;x0.fillRect(0,0,w,h);
    }
  }

  // ── Chain from ceiling ───────────────────────────────
  x0.strokeStyle='rgba(180,160,120,0.6)';x0.lineWidth=4;
  x0.shadowBlur=6;x0.shadowColor='rgba(255,220,150,0.4)';
  x0.beginPath();x0.moveTo(cx,0);x0.lineTo(cx,O.chanY);x0.stroke();
  // Chain links
  for(let cl=0;cl<Math.floor(O.chanY/18);cl++){
    const cly=cl*18+9;
    x0.strokeStyle=`rgba(180,160,120,${0.3+cl/20*0.3})`;x0.lineWidth=3;
    x0.beginPath();x0.ellipse(cx,cly,5,3,cl%2===0?0:Math.PI/2,0,Math.PI*2);x0.stroke();
  }
  x0.shadowBlur=0;

  // ── CHANDELIER ───────────────────────────────────────
  x0.save();x0.translate(cx,O.chanY);

  // Center sphere — faceted crystal ball
  const coreR=Math.min(w,h)*0.04*(1+beat*0.08);
  for(let lat=0;lat<8;lat++){
    for(let lon=0;lon<12;lon++){
      const la=(lat/8-0.5)*Math.PI;
      const lo=lon/12*Math.PI*2;
      const fx=Math.cos(la)*Math.cos(lo)*coreR;
      const fy=Math.sin(la)*coreR;
      const fz=Math.cos(la)*Math.sin(lo);
      if(fz<0.05)continue;
      const fsz=(4+fz*6)*(1+beat*0.2);
      x0.fillStyle=rgba(pc((lat+lon)%4),(0.5+fz*0.5)*0.9);
      x0.shadowBlur=8+beat*4;x0.shadowColor=pc((lat+lon)%4);
      x0.fillRect(fx-fsz/2,fy-fsz/2,fsz,fsz);
    }
  }
  x0.shadowBlur=0;

  // The 6 concentric rings
  for(let ri=0;ri<O.rings.length;ri++){
    const ring=O.rings[ri];
    // Normal rotation — haywire overrides
    if(ring.haywire){
      ring.rot+=ring.haywireSpeed*(1+beat*0.5);
    } else {
      ring.rot+=ring.rotSpeed*ring.dir*(1+beat*0.3);
    }

    const rSz=ring.r*Math.min(w,h)*(1.1+beat*0.04);
    // Ring structure — ellipse (perspective tilt)
    x0.strokeStyle=rgba(pc(ring.ci),0.35*(1+beat*0.2));
    x0.lineWidth=1.5;x0.shadowBlur=10+beat*5;x0.shadowColor=pc(ring.ci);
    x0.beginPath();x0.ellipse(0,0,rSz,rSz*0.22,ring.tilt,0,Math.PI*2);x0.stroke();
    // Inner ring wire
    x0.strokeStyle=rgba(pc(ring.ci),0.15);x0.lineWidth=1;
    x0.beginPath();x0.ellipse(0,0,rSz*0.85,rSz*0.18,ring.tilt,0,Math.PI*2);x0.stroke();
    x0.shadowBlur=0;

    // Crystal nodes on ring
    const nodeCount=ring.nodes;
    for(let n=0;n<nodeCount;n++){
      const na=n/nodeCount*Math.PI*2+ring.rot;
      const nx=Math.cos(na)*rSz;
      const ny=Math.sin(na)*rSz*0.22;
      // Only draw front-facing nodes (simulate 3D)
      if(Math.sin(na+ring.tilt)<-0.1)continue;
      const nVis=0.5+Math.sin(na+ring.tilt)*0.5;
      const nSz=(3+nVis*4)*(1+beat*0.25);
      x0.fillStyle=rgba(pc((ring.ci+n)%4),(0.5+nVis*0.5)*0.85);
      x0.shadowBlur=12*nVis+beat*8;x0.shadowColor=pc((ring.ci+n)%4);
      x0.fillRect(nx-nSz/2,ny-nSz/2,nSz,nSz);

      // Hanging crystal drops — every 4th node has a pendant
      if(n%4===0){
        const pendLen=rSz*0.12+Math.sin(na*3+t*0.002)*rSz*0.04;
        x0.strokeStyle=rgba(pc(ring.ci),0.3*nVis);x0.lineWidth=1;
        x0.beginPath();x0.moveTo(nx,ny);x0.lineTo(nx,ny+pendLen);x0.stroke();
        x0.fillStyle=rgba(pc((ring.ci+2)%4),(0.6+nVis*0.4)*0.8);
        x0.shadowBlur=8;x0.shadowColor=pc((ring.ci+2)%4);
        x0.beginPath();x0.arc(nx,ny+pendLen,2.5*(1+beat*0.3),0,Math.PI*2);x0.fill();
        x0.shadowBlur=0;
      }
    }

    // Light beams from ring outward — wide colored cones
    if(ri%2===0){
      for(let b=0;b<4;b++){
        const ba=b/4*Math.PI*2+ring.rot*0.5;
        const bLen=Math.min(w,h)*(0.35+ri*0.08)*(1+beat*0.2);
        const bx=Math.cos(ba)*rSz*0.8;
        const by2=Math.sin(ba)*rSz*0.2;
        // World coords for beam endpoint
        const worldX=cx+bx+Math.cos(ba)*bLen;
        const worldY=O.chanY+by2+Math.sin(ba+0.3)*bLen*0.4;
        x0.save();
        x0.globalAlpha=0.04*(1+beat*0.4)*(1+ri*0.15);
        const bg=x0.createLinearGradient(cx+bx,O.chanY+by2,worldX,worldY);
        const bc=h2r(pc(ring.ci));
        bg.addColorStop(0,`rgba(${bc.r},${bc.g},${bc.b},1)`);bg.addColorStop(1,'transparent');
        x0.strokeStyle=bg;x0.lineWidth=6+ri*2;
        x0.beginPath();x0.moveTo(bx,by2);x0.lineTo(bx+Math.cos(ba)*bLen,by2+Math.sin(ba+0.3)*bLen*0.4);x0.stroke();
        x0.restore();
      }
    }
  }
  x0.restore(); // end chandelier translate

  // ── LASER SHOW — from chandelier position ─────────────
  if(O.laserActive){
    O.beamRot+=0.025*(1+beat*0.5);
    const laserOriginX=cx, laserOriginY=O.chanY;
    // Fan patterns — 3 rotating fans of different colors
    for(let fan=0;fan<3;fan++){
      const fanOffset=fan/3*Math.PI*2;
      for(let beam=0;beam<7;beam++){
        const ba=beam/6*Math.PI*1.2-Math.PI*0.6+fanOffset+O.beamRot*(fan%2===0?1:-1);
        const bLen=Math.max(w,h)*1.4;
        const bc=h2r(pc(fan%4));
        x0.save();
        x0.strokeStyle=`rgba(${bc.r},${bc.g},${bc.b},${0.7+beat*0.25})`;
        x0.lineWidth=1.5;
        x0.shadowBlur=8+beat*4;x0.shadowColor=pc(fan%4);
        x0.beginPath();x0.moveTo(laserOriginX,laserOriginY);
        x0.lineTo(laserOriginX+Math.cos(ba)*bLen,laserOriginY+Math.sin(ba)*bLen);
        x0.stroke();x0.shadowBlur=0;x0.restore();
      }
    }
    // X-pattern fixed
    for(const xa of [Math.PI*0.25,Math.PI*0.75,-Math.PI*0.25,-Math.PI*0.75]){
      const bc=h2r(pc(2));
      x0.strokeStyle=`rgba(${bc.r},${bc.g},${bc.b},${0.5+beat*0.3})`;
      x0.lineWidth=1.5;x0.shadowBlur=6;x0.shadowColor=pc(2);
      x0.beginPath();x0.moveTo(laserOriginX,laserOriginY);
      x0.lineTo(laserOriginX+Math.cos(xa+O.beamRot*0.3)*w,laserOriginY+Math.sin(xa+O.beamRot*0.3)*h);
      x0.stroke();x0.shadowBlur=0;
    }
    // Grid pattern — horizontal/vertical sweeping beams
    for(let grd=0;grd<3;grd++){
      const gba=O.beamRot*1.5+grd*Math.PI/3;
      x0.strokeStyle=rgba(pc(3),0.3+beat*0.2);x0.lineWidth=1;x0.shadowBlur=4;x0.shadowColor=pc(3);
      x0.beginPath();x0.moveTo(0,laserOriginY+Math.sin(gba)*h*0.3);
      x0.lineTo(w,laserOriginY+Math.sin(gba+0.5)*h*0.3);x0.stroke();
      x0.shadowBlur=0;
    }
  }

  // ── CROWD silhouettes ────────────────────────────────
  for(const p of SD.crowd){
    p.ph+=p.phSpeed*(1+beat*0.5);
    const bounce=Math.abs(Math.sin(p.ph))*p.sz*0.12*(1+beat*0.5);
    const sway=Math.sin(p.ph*0.5)*p.sz*0.06;
    // Body
    x0.fillStyle=`rgba(0,0,0,0.92)`;
    x0.fillRect(p.x-p.sz*0.12+sway,p.y-p.sz*0.65+bounce,p.sz*0.24,p.sz*0.65);
    // Head
    x0.beginPath();x0.arc(p.x+sway,p.y-p.sz*0.72+bounce,p.sz*0.14,0,Math.PI*2);x0.fill();
    // Arms raised (vary per person)
    const armSwing=Math.sin(p.ph+0.5)*0.4;
    x0.lineWidth=p.sz*0.07;x0.strokeStyle=`rgba(0,0,0,0.92)`;x0.lineCap='round';
    x0.beginPath();x0.moveTo(p.x-p.sz*0.12+sway,p.y-p.sz*0.45+bounce);
    x0.lineTo(p.x-p.sz*(0.25+p.armL*0.3)+sway,p.y-p.sz*(0.6+p.armL*0.2)+bounce+armSwing*p.sz*0.1);x0.stroke();
    x0.beginPath();x0.moveTo(p.x+p.sz*0.12+sway,p.y-p.sz*0.45+bounce);
    x0.lineTo(p.x+p.sz*(0.25+p.armR*0.3)+sway,p.y-p.sz*(0.6+p.armR*0.2)+bounce-armSwing*p.sz*0.1);x0.stroke();
    x0.lineCap='butt';
    // Edge color glow from chandelier light hitting them
    x0.fillStyle=rgba(pc(p.ci),0.08*(1+beat*0.3));
    x0.fillRect(p.x-p.sz*0.12+sway,p.y-p.sz*0.65+bounce,2,p.sz*0.65);
  }

  // ── Floor glow from chandelier light ─────────────────
  const fglow=x0.createRadialGradient(cx,floorY,0,cx,floorY,w*0.45);
  fglow.addColorStop(0,rgba(pc(0),0.08*(1+beat*0.4)));
  fglow.addColorStop(0.5,rgba(pc(1),0.04));
  fglow.addColorStop(1,'transparent');
  x0.fillStyle=fglow;x0.fillRect(0,0,w,h);
}
function drawPirateShip(t){
  const w=W(),h=H();
  x0.fillStyle=THEME.bgColor;x0.fillRect(0,0,w,h);
  if(SD.stars)for(const s of SD.stars){x0.fillStyle=`rgba(255,255,255,${s.br*0.8})`;x0.fillRect(s.x,s.y,1.5,1.5);}
  const hor=h*0.6;
  if(SD.waves)for(let wv=0;wv<5;wv++){const wave=SD.waves[wv];wave.ph+=wave.speed*(1+SM.energy*0.3);x0.beginPath();for(let px=0;px<=w;px+=4){const py=hor+wv*25+Math.sin(px*0.01+wave.ph)*wave.amp*(1+SM.beatPulse*0.2);px===0?x0.moveTo(px,py):x0.lineTo(px,py);}x0.lineTo(w,h);x0.lineTo(0,h);x0.closePath();const wg=x0.createLinearGradient(0,hor,0,h);const wc=h2r(pc(wv%4));wg.addColorStop(0,`rgba(${wc.r},${wc.g},${wc.b},${0.3*(1+SM.beatPulse*0.2)})`);wg.addColorStop(1,'rgba(0,20,60,0.9)');x0.fillStyle=wg;x0.fill();}
  x0.fillStyle='rgba(20,10,5,0.95)';x0.beginPath();x0.moveTo(w*0.1,hor*0.98);x0.lineTo(w*0.9,hor*0.98);x0.lineTo(w*0.85,h*0.55);x0.lineTo(w*0.15,h*0.55);x0.closePath();x0.fill();
  x0.strokeStyle='rgba(40,20,5,0.9)';x0.lineWidth=8;x0.beginPath();x0.moveTo(w*0.35,h*0.55);x0.lineTo(w*0.35,h*0.05);x0.stroke();x0.beginPath();x0.moveTo(w*0.65,h*0.55);x0.lineTo(w*0.65,h*0.12);x0.stroke();
  x0.fillStyle=rgba(pc(1),0.3+SM.beatPulse*0.1);x0.beginPath();x0.moveTo(w*0.35,h*0.08);x0.lineTo(w*0.52,h*0.18+Math.sin(t*0.001)*10);x0.lineTo(w*0.35,h*0.38);x0.closePath();x0.fill();x0.beginPath();x0.moveTo(w*0.65,h*0.15);x0.lineTo(w*0.82,h*0.25+Math.sin(t*0.001)*10);x0.lineTo(w*0.65,h*0.45);x0.closePath();x0.fill();
  // Centerpiece emblem on main sail
  if(THEME.centerpiece){
    // INTEGRATED: centerpiece emblem on main sail
    const sailCX=w*0.43,sailCY=h*0.23+Math.sin(t*0.001)*5;
    const emblemSz=Math.min(w,h)*(0.07+SM.beatPulse*0.012);
    cpRot+=0.004;cpPh+=0.013;
    x0.globalAlpha=0.65+SM.beatPulse*0.2;
    drawCPMini(x0,THEME.centerpiece,sailCX,sailCY,emblemSz,cpRot);
    x0.globalAlpha=1;
  }
  if(SD.seagulls)for(const sg of SD.seagulls){sg.x+=sg.vx;sg.ph+=0.08;if(sg.x>w+20)sg.x=-20;x0.beginPath();x0.moveTo(sg.x-10,sg.y+Math.sin(sg.ph)*3);x0.quadraticCurveTo(sg.x,sg.y-5,sg.x+10,sg.y+Math.sin(sg.ph)*3);x0.strokeStyle='rgba(255,255,255,0.5)';x0.lineWidth=1.5;x0.stroke();}
  if(SD.cannonballs)for(let i=SD.cannonballs.length-1;i>=0;i--){const cb=SD.cannonballs[i];cb.x+=cb.vx;cb.y+=cb.vy;cb.vy+=0.3;cb.life-=0.02;if(cb.life<=0||cb.y>h){SD.cannonballs.splice(i,1);continue;}x0.beginPath();x0.arc(cb.x,cb.y,cb.r,0,Math.PI*2);x0.fillStyle=rgba(pc(0),cb.life*0.9);x0.shadowBlur=15;x0.shadowColor=pc(0);x0.fill();x0.shadowBlur=0;}
}
function drawJunkyard(t){
  const w=W(),h=H();
  x0.fillStyle=THEME.bgColor;x0.fillRect(0,0,w,h);
  const ig=x0.createLinearGradient(0,0,0,h*0.5);ig.addColorStop(0,rgba(pc(1),0.1));ig.addColorStop(1,'transparent');x0.fillStyle=ig;x0.fillRect(0,0,w,h*0.5);
  x0.fillStyle='rgba(20,15,10,0.9)';x0.fillRect(0,h*0.7,w,h*0.3);
  if(SD.carStacks)for(const cs of SD.carStacks){const cx2=cs.x*w;for(let c=0;c<cs.cars;c++){const cy2=h*0.7-(c+1)*h*0.08;const cw=w*0.08,ch2=h*0.07;x0.fillStyle=rgba(pc(cs.ci),0.3+c*0.05);x0.fillRect(cx2-cw/2,cy2,cw,ch2);x0.strokeStyle=rgba(pc(cs.ci),0.5);x0.lineWidth=1;x0.strokeRect(cx2-cw/2,cy2,cw,ch2);}}
  if(SD.arms)for(const arm of SD.arms){arm.angle+=(arm.targetAngle-arm.angle)*arm.speed;if(Math.abs(arm.angle-arm.targetAngle)<0.05)arm.targetAngle=-Math.PI*0.3-Math.random()*0.5;x0.save();x0.translate(arm.x,arm.baseY);x0.strokeStyle=rgba(pc(arm.ci),0.7);x0.lineWidth=8;x0.lineCap='round';const ax=Math.cos(arm.angle)*arm.sz,ay=Math.sin(arm.angle)*arm.sz;x0.beginPath();x0.moveTo(0,0);x0.lineTo(ax,ay);x0.stroke();x0.lineCap='butt';x0.shadowBlur=15;x0.shadowColor=pc(arm.ci);x0.fillStyle=rgba(pc(arm.ci),0.8);x0.beginPath();x0.arc(ax,ay,8,0,Math.PI*2);x0.fill();x0.shadowBlur=0;x0.restore();}
  if(SD.sparks)for(let i=SD.sparks.length-1;i>=0;i--){const sp=SD.sparks[i];sp.x+=sp.vx;sp.y+=sp.vy;sp.vy+=0.4;sp.life-=0.025;if(sp.life<=0){SD.sparks.splice(i,1);continue;}x0.beginPath();x0.arc(sp.x,sp.y,2*sp.life,0,Math.PI*2);x0.fillStyle=rgba(pc(sp.ci),sp.life*0.9);x0.shadowBlur=6;x0.shadowColor=pc(sp.ci);x0.fill();x0.shadowBlur=0;}
  // Centerpiece as wrecking ball on crane arm - swings and smashes
  if(THEME.centerpiece){
    const armX=W()*0.6,armY=H()*0.1;
    const swingAng=Math.sin(t*0.0012*(1+songProg))*0.9*(1+SM.beatPulse*0.3);
    const chainLen=H()*(0.25+songProg*0.15);
    const ballX=armX+Math.sin(swingAng)*chainLen;
    const ballY=armY+Math.cos(swingAng)*chainLen;
    const ballR=Math.min(W(),H())*(0.06+SM.beatPulse*0.025);
    // INTEGRATED: chain from crane arm
    x0.strokeStyle='rgba(180,160,100,0.7)';x0.lineWidth=5;
    x0.setLineDash([8,5]);x0.beginPath();x0.moveTo(armX,armY);x0.lineTo(ballX,ballY);x0.stroke();x0.setLineDash([]);
    // Wrecking ball IS the centerpiece
    cpRot+=0.03; cpPh+=0.013;
    x0.globalAlpha=0.92+SM.beatPulse*0.08;
    drawCPMini(x0,THEME.centerpiece,ballX,ballY,ballR,cpRot);
    x0.globalAlpha=1;
    // Smash effect - when ball swings to extreme, shoot sparks
    if(Math.abs(swingAng)>0.75&&SD.sparks&&Math.random()<0.3){SD.sparks.push({x:ballX,y:ballY,vx:(Math.random()-0.5)*12,vy:-(Math.random()*6+2),life:0.8,ci:Math.floor(Math.random()*4)});}
  }
}
function drawSuperhero(t){
  const w=W(),h=H(),cx=w/2;
  // Neon Gotham — dark rainy city night
  x0.fillStyle='rgba(2,4,18,1)';x0.fillRect(0,0,w,h);
  // Rain
  if(!SD.rainDrops){SD.rainDrops=Array.from({length:150},()=>({x:Math.random()*w,y:Math.random()*h,vy:8+Math.random()*6,len:8+Math.random()*15,alpha:0.1+Math.random()*0.2}));}
  x0.strokeStyle='rgba(100,140,200,0.2)';x0.lineWidth=0.8;
  for(const rd of SD.rainDrops){rd.y+=rd.vy*(1+SM.energy*0.3);if(rd.y>h){rd.y=-20;rd.x=Math.random()*w;}x0.beginPath();x0.moveTo(rd.x,rd.y);x0.lineTo(rd.x-rd.vy*0.15,rd.y+rd.len);x0.stroke();}
  // City buildings — neon-lit Gotham
  if(!SD.cityBuildings){
    SD.cityBuildings=Array.from({length:18},(_,i)=>{
      const bw=30+Math.random()*60;
      return{x:i*(w/18),w:bw,h:h*(0.35+Math.random()*0.45),ci:i%4,windows:Array.from({length:Math.floor(Math.random()*20+10)},()=>({x:Math.random()*bw*0.7+bw*0.1,y:Math.random()*h*0.4+20,on:Math.random()>0.35})),neon:Math.random()>0.5};
    });
  }
  for(const b of SD.cityBuildings){
    const bh=h-b.h;
    x0.fillStyle='rgba(5,8,25,0.97)';x0.fillRect(b.x,bh,b.w,b.h);
    // Neon signs on buildings
    if(b.neon){x0.strokeStyle=rgba(pc(b.ci),0.6+SM.beatPulse*0.2);x0.lineWidth=2;x0.shadowBlur=8;x0.shadowColor=pc(b.ci);x0.strokeRect(b.x+2,bh+5,b.w-4,15);x0.shadowBlur=0;}
    // Windows
    for(const wn of b.windows){if(!wn.on)continue;if(SM.beatPulse>0.4&&Math.random()<0.02)wn.on=!wn.on;x0.fillStyle=rgba(pc(b.ci),0.45+SM.beatPulse*0.15);x0.fillRect(b.x+wn.x,bh+wn.y,7,10);}
    // Building outline
    x0.strokeStyle=rgba(pc(b.ci),0.1);x0.lineWidth=1;x0.strokeRect(b.x,bh,b.w,b.h);
  }
  // Street reflections
  x0.fillStyle='rgba(0,0,0,0.6)';x0.fillRect(0,h*0.88,w,h*0.12);
  for(const b of SD.cityBuildings){
    for(const wn of b.windows){if(!wn.on)continue;const c=h2r(pc(b.ci));x0.fillStyle=`rgba(${c.r},${c.g},${c.b},0.1)`;x0.fillRect(b.x+wn.x,h*0.88,7,h*0.12);}
  }
  // Bat signal — sweeps across sky, projects centerpiece silhouette
  if(!SD.batSignal){SD.batSignal={angle:Math.PI*0.4,rotDir:1,speed:0.004,x:w*0.15,y:h*0.92};}
  const bs=SD.batSignal;
  bs.angle+=bs.rotDir*bs.speed*(1+SM.beatPulse*0.5);
  if(bs.angle>Math.PI*0.85||bs.angle<Math.PI*0.15)bs.rotDir*=-1;
  // Beam
  const beamX=bs.x+Math.cos(bs.angle)*w*1.2;
  const beamY=bs.y+Math.sin(bs.angle-Math.PI)*h*0.8;
  x0.save();x0.globalAlpha=0.06+SM.beatPulse*0.04;
  const bg=x0.createLinearGradient(bs.x,bs.y,beamX,beamY);bg.addColorStop(0,'rgba(220,220,255,0.8)');bg.addColorStop(1,'transparent');
  x0.fillStyle=bg;x0.beginPath();x0.moveTo(bs.x-10,bs.y);x0.lineTo(bs.x+10,bs.y);x0.lineTo(beamX+40,beamY);x0.lineTo(beamX-40,beamY);x0.closePath();x0.fill();x0.restore();
  // Cloud at beam end — centerpiece silhouette projected IN the cloud
  const cloudX=beamX,cloudY=Math.max(h*0.05,Math.min(h*0.45,beamY));
  // Cloud puff
  x0.fillStyle='rgba(180,190,220,0.12)';x0.shadowBlur=30;x0.shadowColor='rgba(200,210,255,0.3)';
  for(let cl=0;cl<5;cl++){x0.beginPath();x0.arc(cloudX+Math.cos(cl/5*Math.PI*2)*35,cloudY+Math.sin(cl/5*Math.PI*2)*15,25,0,Math.PI*2);x0.fill();}
  x0.shadowBlur=0;
  // Centerpiece silhouette in the signal
  if(THEME.centerpiece){
    cpPh+=0.013;cpRot+=0.008;
    const sigSz=Math.min(w,h)*0.1*(1+SM.beatPulse*0.15);
    x0.globalAlpha=0.55+SM.beatPulse*0.25;
    x0.shadowBlur=sigSz*0.8;x0.shadowColor='rgba(200,220,255,0.8)';
    // Draw in white/blue tint to look like signal projection
    x0.filter='brightness(3) saturate(0) sepia(0.2) hue-rotate(200deg)';
    drawCPMini(x0,THEME.centerpiece,cloudX,cloudY,sigSz,cpRot);
    x0.filter='none';x0.shadowBlur=0;x0.globalAlpha=1;
  }
  // Projector light source on rooftop
  x0.fillStyle='rgba(220,230,255,0.8)';x0.shadowBlur=20;x0.shadowColor='rgba(200,220,255,1)';
  x0.beginPath();x0.arc(bs.x,bs.y,8,0,Math.PI*2);x0.fill();x0.shadowBlur=0;
}
function drawDayOfDead(t){
  const w=W(),h=H(),cx=w/2;
  const beat=SM.beatPulse,energy=SM.energy;

  // ── Init ────────────────────────────────────────────
  if(!SD.dotd){
    SD.dotd={
      // Floating background candles
      bgCandles:Array.from({length:22},(_,i)=>({
        x:Math.random()*w, y:Math.random()*h,
        vx:(Math.random()-0.5)*0.3, vy:-(0.1+Math.random()*0.2),
        sz:12+Math.random()*22, ph:Math.random()*Math.PI*2,
        ci:i%4, flicker:Math.random()*Math.PI*2,
      })),
      // Floating sugar masks in background
      bgMasks:Array.from({length:8},(_,i)=>({
        x:Math.random()*w, y:Math.random()*h,
        vx:(Math.random()-0.5)*0.25, vy:(Math.random()-0.5)*0.15,
        sz:28+Math.random()*42, rot:Math.random()*Math.PI*2,
        rotSpeed:(Math.random()-0.5)*0.006, ph:Math.random()*Math.PI*2,
        ci:i%4, alpha:0.12+Math.random()*0.18,
      })),
      // Main mask spin state
      maskRot:0,        // Y-axis rotation (0=front, PI=back)
      maskRotSpeed:0.008,
      maskPulse:0,
      // Zombies
      zombies:[],
      zombieActive:false,
      // Sombrero
      sombrero:null,
      sombreroWorn:false,
      // Marigold petals
      petals:Array.from({length:50},()=>({
        x:Math.random()*w, y:Math.random()*h*0.5+h*0.5,
        vx:(Math.random()-0.5)*0.6, vy:-(0.2+Math.random()*0.4),
        sz:4+Math.random()*6, rot:Math.random()*Math.PI*2,
        rotSpeed:(Math.random()-0.5)*0.04, ci:1, alpha:0.5+Math.random()*0.4,
      })),
    };
  }
  const D=SD.dotd;

  // ── Sky background — deep indigo ──────────────────────
  const sky=x0.createLinearGradient(0,0,0,h);
  const sc0=h2r(pc(0)),sc2=h2r(pc(2));
  sky.addColorStop(0,`rgba(${Math.round(sc0.r*0.06)},${Math.round(sc0.g*0.04)},${Math.round(sc0.b*0.12)},1)`);
  sky.addColorStop(0.5,`rgba(${Math.round(sc2.r*0.04)},${Math.round(sc2.g*0.03)},${Math.round(sc2.b*0.1)},1)`);
  sky.addColorStop(1,'rgba(4,1,8,1)');
  x0.fillStyle=sky;x0.fillRect(0,0,w,h);

  // ── Floating background candles ───────────────────────
  for(const c of D.bgCandles){
    c.x+=c.vx;c.y+=c.vy;c.ph+=0.04;c.flicker+=0.12+Math.random()*0.05;
    if(c.y<-30)c.y=h+30;if(c.x<-30)c.x=w+30;if(c.x>w+30)c.x=-30;
    const flk=0.6+Math.sin(c.flicker)*0.4+Math.random()*0.1;
    const alpha=(0.18+Math.sin(c.ph)*0.08)*flk;
    // Candle body
    x0.fillStyle=rgba(pc(c.ci),alpha*0.7);
    x0.fillRect(c.x-c.sz*0.15,c.y,c.sz*0.3,c.sz*0.7);
    // Flame
    const fH=c.sz*0.45*flk;
    const fg=x0.createRadialGradient(c.x,c.y-fH*0.3,0,c.x,c.y,fH);
    fg.addColorStop(0,'rgba(255,255,180,0.9)');
    fg.addColorStop(0.4,rgba(pc(c.ci),0.6*alpha));
    fg.addColorStop(1,'transparent');
    x0.fillStyle=fg;x0.beginPath();
    x0.moveTo(c.x,c.y-fH);
    x0.bezierCurveTo(c.x+c.sz*0.15,c.y-fH*0.5,c.x+c.sz*0.1,c.y,c.x,c.y);
    x0.bezierCurveTo(c.x-c.sz*0.1,c.y,c.x-c.sz*0.15,c.y-fH*0.5,c.x,c.y-fH);
    x0.fill();
    // Glow halo
    const hg=x0.createRadialGradient(c.x,c.y-fH*0.4,0,c.x,c.y-fH*0.4,c.sz*1.2*flk);
    hg.addColorStop(0,rgba(pc(c.ci),0.08*flk));hg.addColorStop(1,'transparent');
    x0.fillStyle=hg;x0.fillRect(0,0,w,h);
  }

  // ── Floating background sugar masks ───────────────────
  for(const m of D.bgMasks){
    m.x+=m.vx;m.y+=m.vy;m.rot+=m.rotSpeed;m.ph+=0.015;
    if(m.x<-80)m.x=w+80;if(m.x>w+80)m.x=-80;
    if(m.y<-80)m.y=h+80;if(m.y>h+80)m.y=-80;
    const alpha=m.alpha*(0.7+Math.sin(m.ph)*0.3);
    x0.save();x0.translate(m.x,m.y);x0.rotate(m.rot);x0.globalAlpha=alpha;
    drawSugarMask(x0,0,0,m.sz,m.ci,t,0,false);
    x0.restore();
  }

  // ── Marigold petals ───────────────────────────────────
  for(const p of D.petals){
    p.x+=p.vx;p.y+=p.vy;p.rot+=p.rotSpeed;
    if(p.y<-20)p.y=h+20;
    x0.save();x0.translate(p.x,p.y);x0.rotate(p.rot);
    x0.fillStyle=rgba(pc(1),p.alpha*(0.5+beat*0.2));
    x0.beginPath();x0.ellipse(0,0,p.sz*0.4,p.sz,0,0,Math.PI*2);x0.fill();
    x0.restore();
  }

  // ── MAIN GIANT SUGAR MASK ─────────────────────────────
  D.maskRot+=D.maskRotSpeed*(1+beat*0.4);
  D.maskPulse+=(beat*0.08-D.maskPulse)*0.15;
  const maskSz=Math.min(w,h)*(0.42+D.maskPulse*0.06+songProg*0.04);
  const maskX=cx;
  const maskY=h*0.38;
  // Y-axis spin — use cos for width scale (coin-flip rotation)
  const spinScale=Math.cos(D.maskRot);
  const absScale=Math.abs(spinScale);
  const facingFront=spinScale>=0;

  // Outer glow
  const maskGlow=x0.createRadialGradient(maskX,maskY,0,maskX,maskY,maskSz*1.1);
  maskGlow.addColorStop(0,rgba(pc(0),0.06*(1+beat*0.4)));
  maskGlow.addColorStop(0.5,rgba(pc(2),0.04));
  maskGlow.addColorStop(1,'transparent');
  x0.fillStyle=maskGlow;x0.fillRect(0,0,w,h);

  x0.save();
  x0.translate(maskX,maskY);
  x0.scale(spinScale,1); // Y-axis rotation via horizontal scale
  drawSugarMask(x0,0,0,maskSz,facingFront?0:2,t,beat,true);
  // Centerpieces in eyes
  if(THEME.centerpiece){
    cpRot+=0.02;cpPh+=0.013;
    const eyeOffX=maskSz*0.28;
    const eyeOffY=maskSz*(-0.12);
    const cpSz=maskSz*(0.13+beat*0.025);
    for(const ex of [-eyeOffX,eyeOffX]){
      x0.save();
      x0.shadowBlur=cpSz*0.8;x0.shadowColor=rgba(pc(facingFront?1:3),0.9);
      drawCPMini(x0,THEME.centerpiece,ex,eyeOffY,cpSz,cpRot*(facingFront?1:-1));
      x0.shadowBlur=0;
      x0.restore();
    }
  }
  x0.restore();

  // ── Sombrero ──────────────────────────────────────────
  if(D.sombrero){
    const som=D.sombrero;
    if(!som.worn){
      // Spinning down from above
      som.y+=som.vy;som.vy*=0.94;
      som.rot+=som.rotSpeed;
      som.rotSpeed*=0.97;
      if(som.y>=maskY-maskSz*0.55){
        som.y=maskY-maskSz*0.55;
        som.vy=0;som.worn=true;
        D.sombreroWorn=true;
      }
    } else {
      // Worn — bounces with beat, wobbles proudly
      som.y=maskY-maskSz*0.55+Math.sin(t*0.002)*8*(1+beat*0.5);
      som.wobble=Math.sin(t*0.003)*0.08*(1+beat*0.4);
      som.rot+=0.005*(1+beat*0.3);
    }
    x0.save();
    x0.translate(som.x,som.y);
    x0.rotate(som.worn?som.wobble:som.rot);
    x0.scale(spinScale,1); // match mask's Y-axis spin
    drawSombrero(x0,0,0,maskSz*0.85,t,beat);
    x0.restore();
  }

  // ── ZOMBIES ───────────────────────────────────────────
  for(let i=D.zombies.length-1;i>=0;i--){
    const z=D.zombies[i];
    z.ph+=z.phSpeed*(1+beat*0.6);
    z.x+=z.vx*(1+energy*0.2);
    z.alpha=Math.min(0.9,z.alpha+0.008);
    if(z.x<-100||z.x>w+100){D.zombies.splice(i,1);continue;}
    // Dance — bounce and sway
    const bounce=Math.abs(Math.sin(z.ph))*z.sz*0.15*(1+beat*0.5);
    const sway=Math.sin(z.ph*0.5)*z.sz*0.08;
    x0.save();x0.translate(z.x+sway,z.y-bounce);x0.globalAlpha=z.alpha;
    drawZombie(x0,0,0,z.sz,z.ci,z.ph,beat);
    x0.restore();
  }

  // ── ALTAR at bottom ───────────────────────────────────
  const altW=w*0.42;
  const altX=cx-altW/2;
  const altY=h*0.72;
  const altH=h*0.28;

  // Altar backdrop glow
  const altGlow=x0.createRadialGradient(cx,altY,0,cx,altY,altW*0.7);
  altGlow.addColorStop(0,rgba(pc(0),0.15*(1+beat*0.3)));
  altGlow.addColorStop(1,'transparent');
  x0.fillStyle=altGlow;x0.fillRect(0,0,w,h);

  // Altar body — 3 tiers, skulls embedded
  for(let tier=0;tier<3;tier++){
    const tFrac=tier/2;
    const tw=altW*(1-tFrac*0.2);
    const th=altH*0.3;
    const tx=cx-tw/2;
    const ty=altY+tier*th;
    // Stone fill
    x0.fillStyle=`rgba(${22+tier*6},${10+tier*4},${18+tier*6},0.95)`;
    x0.fillRect(tx,ty,tw,th);
    // Stone border
    x0.strokeStyle=rgba(pc(tier%4),0.35*(1+beat*0.15));
    x0.lineWidth=2;x0.shadowBlur=8;x0.shadowColor=pc(tier%4);
    x0.strokeRect(tx,ty,tw,th);x0.shadowBlur=0;
    // Decorative neon line detail on altar face
    x0.strokeStyle=rgba(pc((tier+2)%4),0.2);x0.lineWidth=1;
    for(let ld=1;ld<4;ld++){
      x0.beginPath();x0.moveTo(tx+tw*0.05,ty+th*ld*0.25);x0.lineTo(tx+tw*0.95,ty+th*ld*0.25);x0.stroke();
    }
    // Embedded skulls across each tier
    const skullCount=Math.floor(tw/(h*0.055));
    for(let sk=0;sk<skullCount;sk++){
      const skX=tx+tw*(sk+0.5)/skullCount;
      const skY=ty+th*0.5;
      const skSz=h*0.022;
      x0.save();x0.globalAlpha=0.55+beat*0.2;
      drawMiniSkull(x0,skX,skY,skSz,sk%4,t);
      x0.restore();
    }
  }

  // Altar top — marigold arrangement
  x0.fillStyle=rgba(pc(1),0.6*(1+beat*0.2));
  for(let fl=0;fl<9;fl++){
    const flX=altX+altW*(fl+0.5)/9;
    const flY=altY-8;
    x0.beginPath();x0.arc(flX,flY,6+beat*3,0,Math.PI*2);x0.fill();
    x0.beginPath();x0.arc(flX,flY-10,4+beat*2,0,Math.PI*2);x0.fill();
  }

  // Altar candles — tall, on top
  for(let ac=0;ac<5;ac++){
    const acX=altX+altW*(ac+0.5)/5;
    const acY=altY;
    const acH=h*0.07*(0.7+Math.random()*0.3);
    const flk=0.7+Math.sin(t*0.01+ac*1.3)*0.3+Math.random()*0.1;
    // Candle
    x0.fillStyle=`rgba(240,230,200,0.85)`;
    x0.fillRect(acX-4,acY-acH,8,acH);
    // Flame
    x0.fillStyle=`rgba(255,200,50,${0.8*flk})`;
    x0.shadowBlur=12*flk;x0.shadowColor='rgba(255,150,0,0.8)';
    x0.beginPath();x0.moveTo(acX,acY-acH-12*flk);
    x0.bezierCurveTo(acX+6,acY-acH-4,acX+4,acY-acH,acX,acY-acH);
    x0.bezierCurveTo(acX-4,acY-acH,acX-6,acY-acH-4,acX,acY-acH-12*flk);
    x0.fill();x0.shadowBlur=0;
  }

  // Ground / floor line
  x0.fillStyle='rgba(8,3,14,0.9)';x0.fillRect(0,altY+altH,w,h);
  x0.strokeStyle=rgba(pc(2),0.25);x0.lineWidth=2;
  x0.beginPath();x0.moveTo(0,altY+altH);x0.lineTo(w,altY+altH);x0.stroke();
}



function drawSugarMask(ctx,x,y,sz,ci,t,beat,isMain){
  // Face oval
  ctx.fillStyle=rgba(pc(ci),isMain?0.12:0.06);
  ctx.beginPath();ctx.ellipse(x,y,sz*0.52,sz*0.62,0,0,Math.PI*2);ctx.fill();
  ctx.strokeStyle=rgba(pc(ci),isMain?0.9:0.5);
  ctx.lineWidth=isMain?3:1.5;
  ctx.shadowBlur=isMain?20+beat*15:8;ctx.shadowColor=pc(ci);
  ctx.beginPath();ctx.ellipse(x,y,sz*0.52,sz*0.62,0,0,Math.PI*2);ctx.stroke();
  ctx.shadowBlur=0;

  // Forehead arch decoration
  ctx.strokeStyle=rgba(pc((ci+1)%4),isMain?0.7:0.35);
  ctx.lineWidth=isMain?2:1;ctx.shadowBlur=isMain?12:4;ctx.shadowColor=pc((ci+1)%4);
  ctx.beginPath();ctx.arc(x,y-sz*0.28,sz*0.28,Math.PI*1.15,Math.PI*1.85);ctx.stroke();
  // Diamond on forehead
  ctx.fillStyle=rgba(pc((ci+2)%4),isMain?0.8:0.4);
  ctx.shadowBlur=isMain?10:4;ctx.shadowColor=pc((ci+2)%4);
  ctx.beginPath();ctx.moveTo(x,y-sz*0.52);ctx.lineTo(x+sz*0.06,y-sz*0.44);
  ctx.lineTo(x,y-sz*0.36);ctx.lineTo(x-sz*0.06,y-sz*0.44);ctx.closePath();ctx.fill();
  ctx.shadowBlur=0;

  // Eye sockets — large teardrop shaped
  const eyeX=sz*0.28,eyeY=y-sz*0.1;
  for(const ex of [x-eyeX,x+eyeX]){
    // Socket dark fill
    ctx.fillStyle=`rgba(0,0,0,${isMain?0.7:0.5})`;
    ctx.beginPath();ctx.ellipse(ex,eyeY,sz*0.16,sz*0.19,0,0,Math.PI*2);ctx.fill();
    // Socket decorative ring
    ctx.strokeStyle=rgba(pc((ci+2)%4),isMain?0.8:0.4);
    ctx.lineWidth=isMain?2.5:1;ctx.shadowBlur=isMain?14:5;ctx.shadowColor=pc((ci+2)%4);
    ctx.beginPath();ctx.ellipse(ex,eyeY,sz*0.16,sz*0.19,0,0,Math.PI*2);ctx.stroke();
    // Flower petals around eye
    for(let p=0;p<8;p++){
      const pa=p/8*Math.PI*2+(isMain?t*0.0004:0);
      const pr=sz*0.22;
      ctx.strokeStyle=rgba(pc((ci+p)%4),isMain?0.5:0.2);
      ctx.lineWidth=isMain?1.5:0.8;ctx.shadowBlur=isMain?6:2;
      ctx.beginPath();
      ctx.arc(ex+Math.cos(pa)*pr,eyeY+Math.sin(pa)*pr,sz*0.045,0,Math.PI*2);
      ctx.stroke();
    }
    ctx.shadowBlur=0;
  }

  // Nose — small decorative diamond
  ctx.fillStyle=rgba(pc((ci+1)%4),isMain?0.6:0.3);
  ctx.shadowBlur=isMain?8:3;ctx.shadowColor=pc((ci+1)%4);
  ctx.beginPath();ctx.moveTo(x,y+sz*0.1);ctx.lineTo(x+sz*0.06,y+sz*0.17);
  ctx.lineTo(x,y+sz*0.24);ctx.lineTo(x-sz*0.06,y+sz*0.17);ctx.closePath();ctx.fill();
  ctx.shadowBlur=0;

  // Mouth — teeth grin with decorative lines above/below
  ctx.strokeStyle=rgba(pc(ci),isMain?0.7:0.35);
  ctx.lineWidth=isMain?2:1;ctx.shadowBlur=isMain?10:3;ctx.shadowColor=pc(ci);
  // Lips outline
  ctx.beginPath();ctx.ellipse(x,y+sz*0.35,sz*0.2,sz*0.1,0,0,Math.PI*2);ctx.stroke();
  // Teeth
  ctx.fillStyle=`rgba(240,240,220,${isMain?0.85:0.45})`;
  for(let tooth=0;tooth<5;tooth++){
    const tx2=x-sz*0.16+tooth*sz*0.08;
    ctx.fillRect(tx2,y+sz*0.28,sz*0.065,sz*0.1);
  }
  ctx.shadowBlur=0;

  // Cheek swirl decorations
  for(const sx of [x-sz*0.32,x+sz*0.32]){
    const sDir=sx<x?1:-1;
    ctx.strokeStyle=rgba(pc((ci+3)%4),isMain?0.6:0.25);
    ctx.lineWidth=isMain?2:0.8;ctx.shadowBlur=isMain?8:3;ctx.shadowColor=pc((ci+3)%4);
    ctx.beginPath();
    ctx.moveTo(sx,y+sz*0.05);
    ctx.bezierCurveTo(sx+sDir*sz*0.1,y-sz*0.08,sx+sDir*sz*0.18,y+sz*0.05,sx+sDir*sz*0.08,y+sz*0.15);
    ctx.stroke();
    // Dots along cheek
    for(let d=0;d<3;d++){
      ctx.fillStyle=rgba(pc((ci+d)%4),isMain?0.5:0.2);
      ctx.beginPath();ctx.arc(sx+sDir*d*sz*0.05,y+sz*(0.08+d*0.06),isMain?3:1.5,0,Math.PI*2);ctx.fill();
    }
    ctx.shadowBlur=0;
  }

  // Crown of flowers at top
  if(isMain){
    for(let fl=0;fl<7;fl++){
      const fa=fl/7*Math.PI+Math.PI*0.05;
      const fr=sz*0.52;
      const fx=x+Math.cos(fa-Math.PI*0.5)*sz*0.52;
      const fy=y+Math.sin(fa-Math.PI*0.5)*sz*0.62;
      ctx.fillStyle=rgba(pc(fl%4),0.7+beat*0.2);
      ctx.shadowBlur=8+beat*6;ctx.shadowColor=pc(fl%4);
      ctx.beginPath();ctx.arc(fx,fy,sz*0.048*(1+beat*0.2),0,Math.PI*2);ctx.fill();
      ctx.strokeStyle=rgba(pc((fl+2)%4),0.5);ctx.lineWidth=1.5;
      ctx.beginPath();ctx.arc(fx,fy,sz*0.075,0,Math.PI*2);ctx.stroke();
      ctx.shadowBlur=0;
    }
  }
}

function drawMiniSkull(ctx,x,y,sz,ci,t){
  ctx.fillStyle=rgba(pc(ci),0.5);
  ctx.shadowBlur=5;ctx.shadowColor=pc(ci);
  ctx.beginPath();ctx.ellipse(x,y-sz*0.2,sz*0.45,sz*0.4,0,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='rgba(0,0,0,0.8)';
  ctx.beginPath();ctx.ellipse(x-sz*0.14,y-sz*0.22,sz*0.12,sz*0.14,0,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.ellipse(x+sz*0.14,y-sz*0.22,sz*0.12,sz*0.14,0,0,Math.PI*2);ctx.fill();
  ctx.fillStyle=rgba(pc(ci),0.6);
  ctx.beginPath();ctx.rect(x-sz*0.28,y+sz*0.05,sz*0.56,sz*0.3);ctx.fill();
  ctx.fillStyle='rgba(0,0,0,0.7)';
  for(let t2=0;t2<4;t2++)ctx.fillRect(x-sz*0.22+t2*sz*0.15,y+sz*0.06,sz*0.08,sz*0.25);
  ctx.shadowBlur=0;
}

function drawSombrero(ctx,x,y,sz,t,beat){
  const brimW=sz*0.85;
  const crownH=sz*0.28;
  const crownW=sz*0.32;
  // Brim — wide ellipse
  ctx.fillStyle=rgba(pc(0),0.85);
  ctx.shadowBlur=20+beat*10;ctx.shadowColor=pc(1);
  ctx.beginPath();ctx.ellipse(x,y,brimW,brimW*0.22,0,0,Math.PI*2);ctx.fill();
  // Brim underside shade
  ctx.fillStyle=rgba(pc(2),0.4);
  ctx.beginPath();ctx.ellipse(x,y+4,brimW*0.9,brimW*0.18,0,0,Math.PI*2);ctx.fill();
  // Crown
  ctx.fillStyle=rgba(pc(0),0.9);
  ctx.beginPath();ctx.ellipse(x,y,crownW,crownW*0.22,0,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.moveTo(x-crownW,y);ctx.lineTo(x-crownW*0.85,-crownH);
  ctx.bezierCurveTo(x-crownW*0.5,-crownH*1.15,x+crownW*0.5,-crownH*1.15,x+crownW*0.85,-crownH);
  ctx.lineTo(x+crownW,y);ctx.fill();
  // Decorative band
  ctx.strokeStyle=rgba(pc(1),0.9);ctx.lineWidth=3;ctx.shadowBlur=12;ctx.shadowColor=pc(1);
  ctx.beginPath();ctx.ellipse(x,y-crownH*0.12,crownW*0.95,crownW*0.21,0,-Math.PI,0,true);ctx.stroke();
  // Pompom / tassel at top
  ctx.fillStyle=rgba(pc(3),0.95);ctx.shadowBlur=15;ctx.shadowColor=pc(3);
  ctx.beginPath();ctx.arc(x,-crownH*1.1,sz*0.04*(1+beat*0.3),0,Math.PI*2);ctx.fill();
  // Brim decorative dots
  ctx.shadowBlur=6;
  for(let d=0;d<14;d++){
    const da=d/14*Math.PI*2;
    const dr=brimW*0.75;
    ctx.fillStyle=rgba(pc(d%4),0.7+beat*0.2);
    ctx.beginPath();ctx.arc(x+Math.cos(da)*dr,y+Math.sin(da)*dr*0.22,sz*0.018,0,Math.PI*2);ctx.fill();
  }
  ctx.shadowBlur=0;
}

function drawZombie(ctx,x,y,sz,ci,ph,beat){
  const bounce=Math.abs(Math.sin(ph))*sz*0.08;
  const sway=Math.sin(ph*0.5)*sz*0.06;
  // Legs shuffle
  const lLeg=Math.sin(ph)*sz*0.15;
  const rLeg=-Math.sin(ph)*sz*0.15;
  ctx.strokeStyle=rgba(pc(ci),0.8);ctx.lineWidth=sz*0.09;ctx.lineCap='round';
  ctx.beginPath();ctx.moveTo(x,y);ctx.lineTo(x-sz*0.12+sway,y+sz*0.4+lLeg);ctx.stroke();
  ctx.beginPath();ctx.moveTo(x,y);ctx.lineTo(x+sz*0.12+sway,y+sz*0.4+rLeg);ctx.stroke();
  // Body
  ctx.fillStyle=rgba(pc(ci),0.55);
  ctx.fillRect(x-sz*0.16+sway,y-sz*0.5+bounce,sz*0.32,sz*0.5);
  // Arms outstretched (zombie style)
  const lArmA=Math.sin(ph*0.7)*0.3-0.2;
  const rArmA=-Math.sin(ph*0.7)*0.3+0.2;
  ctx.lineWidth=sz*0.07;
  ctx.beginPath();ctx.moveTo(x-sz*0.16+sway,y-sz*0.3+bounce);
  ctx.lineTo(x-sz*0.45+sway,y-sz*(0.3-lArmA*0.3)+bounce);ctx.stroke();
  ctx.beginPath();ctx.moveTo(x+sz*0.16+sway,y-sz*0.3+bounce);
  ctx.lineTo(x+sz*0.45+sway,y-sz*(0.3-rArmA*0.3)+bounce);ctx.stroke();
  ctx.lineCap='butt';
  // Head with mini sugar mask look
  ctx.fillStyle=rgba(pc(ci),0.7);ctx.shadowBlur=8;ctx.shadowColor=pc(ci);
  ctx.beginPath();ctx.ellipse(x+sway,y-sz*0.65+bounce,sz*0.16,sz*0.18,0,0,Math.PI*2);ctx.fill();
  // X eyes
  ctx.strokeStyle='rgba(0,0,0,0.9)';ctx.lineWidth=1.5;ctx.shadowBlur=0;
  for(const ex of [x-sz*0.06+sway,x+sz*0.06+sway]){
    const ey=y-sz*0.67+bounce;
    ctx.beginPath();ctx.moveTo(ex-3,ey-3);ctx.lineTo(ex+3,ey+3);ctx.stroke();
    ctx.beginPath();ctx.moveTo(ex+3,ey-3);ctx.lineTo(ex-3,ey+3);ctx.stroke();
  }
  // Dots / decoration on face
  ctx.fillStyle=rgba(pc((ci+2)%4),0.7);ctx.shadowBlur=3;ctx.shadowColor=pc((ci+2)%4);
  ctx.beginPath();ctx.arc(x+sway,y-sz*0.55+bounce,sz*0.04,0,Math.PI*2);ctx.fill();
  ctx.shadowBlur=0;
}

function drawChineseDragon(t){
  const w=W(),h=H(),cx=w/2,cy=h/2;
  x0.fillStyle=THEME.bgColor;x0.fillRect(0,0,w,h);
  // Fog banks
  if(!SD.fog){SD.fog=Array.from({length:8},(_,i)=>({x:Math.random()*w,y:h*(0.3+Math.random()*0.5),r:150+Math.random()*200,ph:Math.random()*Math.PI*2,speed:0.003+Math.random()*0.003}));}
  for(const fg of SD.fog){fg.ph+=fg.speed;const fx=fg.x+Math.sin(fg.ph)*60,fy=fg.y+Math.cos(fg.ph*0.7)*30;const gr=x0.createRadialGradient(fx,fy,0,fx,fy,fg.r);const gc=h2r(pc(1));gr.addColorStop(0,`rgba(${gc.r},${gc.g},${gc.b},0.07)`);gr.addColorStop(1,'transparent');x0.fillStyle=gr;x0.fillRect(0,0,w,h);}
  // Pearl — the centerpiece glowing orb the dragon chases
  if(!SD.pearl){SD.pearl={x:w*0.3,y:h*0.4,vx:1.5,vy:0.5,ph:0};}
  const pearl=SD.pearl;
  // Pearl moves in figure-8 pattern
  pearl.ph+=0.012*(1+SM.energy*0.2);
  pearl.x=cx+Math.sin(pearl.ph)*w*0.3;
  pearl.y=cy+Math.sin(pearl.ph*2)*h*0.2;
  // Draw pearl as centerpiece
  const pearlSz=Math.min(w,h)*(0.09+SM.beatPulse*0.04);
  const pg=x0.createRadialGradient(pearl.x,pearl.y,0,pearl.x,pearl.y,pearlSz*1.5);
  pg.addColorStop(0,rgba(pc(0),0.3*(1+SM.beatPulse*0.3)));pg.addColorStop(1,'transparent');
  x0.fillStyle=pg;x0.fillRect(0,0,w,h);
  cpPh+=0.013;cpRot+=0.04*(1+SM.energy*0.2);
  x0.shadowBlur=pearlSz*0.9;x0.shadowColor=rgba(pc(0),0.9);
  drawCPMini(x0,THEME.centerpiece,pearl.x,pearl.y,pearlSz,cpRot);
  x0.shadowBlur=0;
  // Dragon body — sinuous segments chasing the pearl
  SD.dragonEmerge=Math.min(1,(SD.dragonEmerge||0)+0.004*(1+SM.energy*0.2));
  const emerge=SD.dragonEmerge;
  if(!SD.dragonPath){SD.dragonPath=Array.from({length:30},()=>({x:cx,y:cy}));}
  // Head moves toward pearl
  const head=SD.dragonPath[0];
  const dx=pearl.x-head.x,dy=pearl.y-head.y;
  const dist=Math.hypot(dx,dy)||1;
  head.x+=dx/dist*2.5*(1+SM.energy*0.4);
  head.y+=dy/dist*2.5*(1+SM.energy*0.4);
  // Body follows head
  for(let s=1;s<SD.dragonPath.length;s++){
    const prev=SD.dragonPath[s-1],curr=SD.dragonPath[s];
    const ddx=curr.x-prev.x,ddy=curr.y-prev.y;
    const dd=Math.hypot(ddx,ddy)||1;
    if(dd>22){curr.x=prev.x+ddx/dd*22;curr.y=prev.y+ddy/dd*22;}
  }
  // Draw body
  x0.save();x0.globalAlpha=emerge;
  for(let s=SD.dragonPath.length-1;s>=0;s--){
    const seg=SD.dragonPath[s];
    const segR=(28-s*0.7)*(1-s/(SD.dragonPath.length*1.5))*emerge;
    if(segR<1)continue;
    x0.beginPath();x0.arc(seg.x,seg.y,segR,0,Math.PI*2);
    x0.fillStyle=rgba(pc(s%4),(0.65-s*0.015)*Math.min(1,emerge*2));
    x0.shadowBlur=8;x0.shadowColor=pc(s%4);
    x0.fill();x0.shadowBlur=0;
    // Scales glint
    if(s%3===0){x0.fillStyle=rgba(pc((s+2)%4),0.25);x0.beginPath();x0.arc(seg.x,seg.y,segR*0.6,0,Math.PI*2);x0.fill();}
  }
  // Dragon head
  const dh=SD.dragonPath[0];
  const headDir=Math.atan2(SD.dragonPath[0].y-SD.dragonPath[1].y,SD.dragonPath[0].x-SD.dragonPath[1].x);
  x0.save();x0.translate(dh.x,dh.y);x0.rotate(headDir);
  x0.fillStyle=rgba(pc(0),0.92);x0.shadowBlur=30;x0.shadowColor=pc(0);
  x0.beginPath();x0.ellipse(0,0,38,26,0,0,Math.PI*2);x0.fill();
  // Jaw/snout
  x0.beginPath();x0.moveTo(20,8*(1+SM.beatPulse*0.3));x0.lineTo(55,5*(1+SM.beatPulse*0.3));x0.lineTo(55,14*(1+SM.beatPulse*0.3));x0.lineTo(20,16*(1+SM.beatPulse*0.3));x0.fill();
  // Eye
  x0.fillStyle=rgba(pc(1),0.95);x0.shadowBlur=15;x0.shadowColor=pc(1);
  x0.beginPath();x0.arc(20,-10,8,0,Math.PI*2);x0.fill();x0.fillStyle='rgba(0,0,0,0.9)';x0.beginPath();x0.arc(22,-10,4,0,Math.PI*2);x0.fill();
  // Horn
  x0.fillStyle=rgba(pc(2),0.85);x0.beginPath();x0.moveTo(5,-26);x0.lineTo(18,-50);x0.lineTo(22,-26);x0.closePath();x0.fill();
  x0.restore();x0.restore();
}
function drawMountOlympus(t){
  const w=W(),h=H(),cx=w/2;

  // ── Sky ─────────────────────────────────────────────
  // Use AI palette for sky colors — different every song
  const sky=x0.createLinearGradient(0,0,0,h);
  const sc0=h2r(pc(0)),sc2=h2r(pc(2)),sc3=h2r(pc(3));
  sky.addColorStop(0,`rgba(${Math.round(sc0.r*0.04)},${Math.round(sc0.g*0.04)},${Math.round(sc0.b*0.06)},1)`);
  sky.addColorStop(0.3,rgba(pc(2),0.22));
  sky.addColorStop(0.65,rgba(pc(0),0.15));
  sky.addColorStop(1,`rgba(${Math.round(sc3.r*0.08)},${Math.round(sc3.g*0.04)},${Math.round(sc3.b*0.03)},0.9)`);
  x0.fillStyle=sky;x0.fillRect(0,0,w,h);

  // ── Mountain ranges — lowered, AI-palette colored ──
  // Mountains sit in bottom 50% of screen, leaving top for Zeus + sky
  const drawMtRange=(peaks,baseY,fillColor)=>{
    x0.fillStyle=fillColor;
    x0.beginPath();x0.moveTo(0,h);
    for(const[px,py] of peaks)x0.lineTo(px*w,baseY+py*(h-baseY));
    x0.lineTo(w,h);x0.closePath();x0.fill();
  };

  // Far range — palette color 3, subtle, peaks reach ~55% down
  const farC=h2r(pc(3));
  drawMtRange(
    [[0,0.55],[0.07,0.08],[0.15,0.22],[0.25,0.02],[0.36,0.18],[0.45,0],[0.54,0.15],[0.63,0.04],[0.74,0.2],[0.85,0.06],[0.93,0.16],[1,0.35]],
    h*0.38,
    `rgba(${farC.r},${farC.g},${farC.b},0.4)`
  );

  // Mid range — palette color 1, peaks reach ~65% down
  const midC=h2r(pc(1));
  drawMtRange(
    [[0,0.65],[0.06,0.28],[0.18,0.44],[0.28,0.15],[0.4,0.38],[0.5,0.1],[0.6,0.32],[0.71,0.18],[0.82,0.38],[0.91,0.22],[1,0.4]],
    h*0.42,
    `rgba(${midC.r},${midC.g},${midC.b},0.55)`
  );

  // Close range — palette color 2, peaks reach ~75% down, darker
  const closeC=h2r(pc(2));
  drawMtRange(
    [[0,0.8],[0.09,0.38],[0.2,0.52],[0.32,0.28],[0.44,0.46],[0.53,0.22],[0.64,0.42],[0.76,0.3],[0.87,0.45],[0.96,0.32],[1,0.55]],
    h*0.46,
    `rgba(${Math.round(closeC.r*0.4)},${Math.round(closeC.g*0.4)},${Math.round(closeC.b*0.5)},0.75)`
  );

  // Foreground silhouette — near-black, fills bottom third
  x0.fillStyle='rgba(4,2,8,0.97)';
  x0.beginPath();x0.moveTo(0,h);
  [[0,1],[0.1,0.42],[0.22,0.58],[0.35,0.35],[0.48,0.5],[0.57,0.3],[0.68,0.46],[0.8,0.34],[0.9,0.44],[1,0.55]].forEach(([px,py])=>x0.lineTo(px*w,h*0.52+py*(h*0.48)));
  x0.lineTo(w,h);x0.closePath();x0.fill();

  // Olympus peak divine glow
  const peakG=x0.createRadialGradient(cx,h*0.52,0,cx,h*0.52,w*0.22);
  peakG.addColorStop(0,rgba(pc(1),0.28*(1+SM.beatPulse*0.5)));
  peakG.addColorStop(0.5,rgba(pc(2),0.08));
  peakG.addColorStop(1,'transparent');
  x0.fillStyle=peakG;x0.fillRect(0,0,w,h);

  // ── Clouds drifting through scene ───────────────────
  if(!SD.clouds){SD.clouds=Array.from({length:7},(_,i)=>({x:Math.random()*w,y:h*(0.25+i*0.04),r:70+Math.random()*120,vx:(Math.random()-0.5)*0.2,ci:i%4}));}
  for(const cl of SD.clouds){
    cl.x+=cl.vx;if(cl.x<-cl.r)cl.x=w+cl.r;if(cl.x>w+cl.r)cl.x=-cl.r;
    const cg=x0.createRadialGradient(cl.x,cl.y,0,cl.x,cl.y,cl.r);
    cg.addColorStop(0,rgba(pc(cl.ci),0.12*(1+SM.beatPulse*0.2)));cg.addColorStop(1,'transparent');
    x0.fillStyle=cg;x0.fillRect(0,0,w,h);
  }

  // ── ZEUS FACE — large white-line drawing, fills upper sky ──
  if(!SD.zeus){SD.zeus={tilt:0,tiltDir:1,tiltSpeed:0.004,eyeFlashL:0,eyeFlashR:0,shootCharge:0,shootState:'idle',shootTimer:3000+Math.random()*2000,angry:0};}
  const Z=SD.zeus;

  // Tilt side to side, searching
  Z.tilt+=Z.tiltDir*Z.tiltSpeed*(1+SM.energy*0.3);
  if(Math.abs(Z.tilt)>0.18)Z.tiltDir*=-1;

  // Shoot charge builds before firing
  Z.shootTimer-=16;
  if(Z.shootState==='idle'&&Z.shootTimer<=0&&SD.cpTarget&&SD.cpTarget.alive){
    Z.shootState='charging';Z.shootTimer=1200; // 1.2s charge before firing
  }
  if(Z.shootState==='charging'){
    Z.shootTimer-=0; // already decremented above
    Z.eyeFlashL=Math.min(1,(1200-Z.shootTimer)/1200);
    Z.eyeFlashR=Z.eyeFlashL;
    if(Z.shootTimer<=0){
      Z.shootState='firing';
      // Spawn converging bolt from both eye positions (world coords)
      const faceX=cx, faceY=h*0.2;
      const eyeLX=faceX+Math.cos(Z.tilt)*(-55)+Math.cos(Z.tilt+Math.PI/2)*(-28);
      const eyeLY=faceY+Math.sin(Z.tilt)*(-55)+Math.sin(Z.tilt+Math.PI/2)*(-28);
      const eyeRX=faceX+Math.cos(Z.tilt)*(55)+Math.cos(Z.tilt+Math.PI/2)*(-28);
      const eyeRY=faceY+Math.sin(Z.tilt)*(55)+Math.sin(Z.tilt+Math.PI/2)*(-28);
      if(!SD.boltsComing)SD.boltsComing=[];
      const tgt=SD.cpTarget;
      // Two beams from each eye converge on target
      for(const[ex,ey] of [[eyeLX,eyeLY],[eyeRX,eyeRY]]){
        const dx=tgt.x-ex,dy=tgt.y-ey,dist=Math.hypot(dx,dy)||1;
        SD.boltsComing.push({x:ex,y:ey,vx:dx/dist*16,vy:dy/dist*16,size:14,life:1.2,ci:1,target:tgt,eyeOrigin:true});
      }
      flash('rgba(255,255,180,0.85)',120);
      setTimeout(()=>{Z.eyeFlashL=0;Z.eyeFlashR=0;Z.shootState='idle';Z.shootTimer=4000+Math.random()*3000;},400);
    }
  }

  // ── ZEUS FACE — elaborate godly portrait ─────────────
  x0.save();
  x0.translate(cx, h*0.21);
  x0.rotate(Z.tilt);
  const faceR = h*0.27;
  const anger = Z.angry||0;
  const charge = (Z.eyeFlashL||0);
  const glow = 0.78 + charge*0.5 + anger*0.3 + SM.beatPulse*0.15;

  const ss=(alpha,blur,lw)=>{
    x0.strokeStyle=`rgba(255,255,225,${Math.min(1,alpha*glow)})`;
    x0.shadowColor='rgba(210,230,255,0.95)';
    x0.shadowBlur=blur*(1+SM.beatPulse*0.15);
    x0.lineWidth=lw; x0.lineCap='round'; x0.lineJoin='round';
  };

  // Divine aura behind face
  const aura=x0.createRadialGradient(0,0,faceR*0.3,0,0,faceR*2.4);
  aura.addColorStop(0,`rgba(255,250,190,${0.05+charge*0.1+SM.beatPulse*0.03})`);
  aura.addColorStop(0.45,`rgba(210,180,100,${0.025+anger*0.04})`);
  aura.addColorStop(1,'transparent');
  x0.fillStyle=aura;x0.fillRect(-faceR*2.8,-faceR*2.6,faceR*5.6,faceR*5.2);

  // Lightning tendrils around head on charge/anger
  if(charge>0.15||anger>0.3){
    for(let lt=0;lt<10;lt++){
      const lta=lt/10*Math.PI*2+t*0.0006;
      const lr1=faceR*(0.9+Math.sin(lt*2.1)*0.06);
      const lr2=faceR*(1.08+Math.sin(lt*1.7+t*0.001)*0.14);
      x0.strokeStyle=`rgba(255,255,160,${(charge*0.5+anger*0.3)*0.7})`;
      x0.lineWidth=0.8;x0.shadowBlur=8;x0.shadowColor='rgba(255,255,80,0.9)';
      x0.beginPath();
      x0.moveTo(Math.cos(lta)*lr1,Math.sin(lta)*lr1);
      const midA=lta+(Math.random()-0.5)*0.4;
      const midR=(lr1+lr2)*0.5;
      x0.lineTo(Math.cos(midA)*midR+(Math.random()-0.5)*12,Math.sin(midA)*midR+(Math.random()-0.5)*12);
      x0.lineTo(Math.cos(lta)*lr2+(Math.random()-0.5)*8,Math.sin(lta)*lr2+(Math.random()-0.5)*8);
      x0.stroke();
    }
    x0.shadowBlur=0;
  }

  // ── HEAD SHAPE — broad noble cranium ─────────────────
  ss(0.9,30,3.5);
  x0.beginPath();
  x0.moveTo(0,-faceR);
  x0.bezierCurveTo( faceR*0.52,-faceR,    faceR*0.84,-faceR*0.65, faceR*0.8, -faceR*0.28);
  x0.bezierCurveTo( faceR*0.9, -faceR*0.0, faceR*0.88, faceR*0.22, faceR*0.72, faceR*0.44);
  x0.bezierCurveTo( faceR*0.58, faceR*0.68, faceR*0.35, faceR*0.84, 0,         faceR*0.9);
  x0.bezierCurveTo(-faceR*0.35, faceR*0.84,-faceR*0.58, faceR*0.68,-faceR*0.72,faceR*0.44);
  x0.bezierCurveTo(-faceR*0.88, faceR*0.22,-faceR*0.9,  -faceR*0.0,-faceR*0.8, -faceR*0.28);
  x0.bezierCurveTo(-faceR*0.84,-faceR*0.65,-faceR*0.52,-faceR,      0,         -faceR);
  x0.stroke();
  x0.fillStyle=`rgba(150,130,220,${0.035+SM.beatPulse*0.015})`;x0.fill();

  // ── LAUREL WREATH — olive crown across top ────────────
  const wreathR=faceR*1.08;
  ss(0.6,12,1.8);
  x0.beginPath();x0.arc(0,0,wreathR,-Math.PI*0.87,-Math.PI*0.13);x0.stroke();
  // Second ring
  x0.beginPath();x0.arc(0,0,wreathR*0.93,-Math.PI*0.82,-Math.PI*0.18);x0.stroke();
  // Leaf pairs along wreath
  for(let lf=0;lf<13;lf++){
    const la=-Math.PI*0.84+lf*(Math.PI*0.68/12);
    const lx=Math.cos(la)*wreathR,ly=Math.sin(la)*wreathR;
    x0.save();x0.translate(lx,ly);x0.rotate(la+Math.PI/2);
    for(const sd of [-1,1]){
      x0.strokeStyle=rgba(pc((lf+1)%4),0.5*glow);
      x0.shadowColor=pc((lf+1)%4);x0.shadowBlur=7+SM.beatPulse*4;
      x0.lineWidth=1.8;
      x0.beginPath();x0.moveTo(0,0);
      x0.bezierCurveTo(sd*7,-11,sd*13,-7,sd*9,1);
      x0.bezierCurveTo(sd*13,8,sd*7,12,0,0);x0.stroke();
    }
    x0.restore();
    if(lf%3===0){
      x0.fillStyle=rgba(pc(lf%4),0.65);x0.shadowBlur=5;x0.shadowColor=pc(lf%4);
      x0.beginPath();x0.arc(Math.cos(la)*wreathR*0.96,Math.sin(la)*wreathR*0.96,3.5,0,Math.PI*2);x0.fill();
    }
  }

  // ── BROW RIDGE — heavy, deeply furrowed ───────────────
  const furrow=0.1+anger*0.2+charge*0.06;
  ss(0.88,24,5);
  // Brow bone mass — thick single arc
  x0.beginPath();
  x0.moveTo(-faceR*0.74,-faceR*0.1);
  x0.bezierCurveTo(-faceR*0.54,-faceR*0.3,-faceR*0.2,-faceR*(0.38+furrow),0,-faceR*(0.32+furrow*0.5));
  x0.bezierCurveTo( faceR*0.2,-faceR*(0.38+furrow), faceR*0.54,-faceR*0.3, faceR*0.74,-faceR*0.1);
  x0.stroke();
  // Temple ridge lines
  ss(0.55,10,2);
  x0.beginPath();x0.moveTo(-faceR*0.74,-faceR*0.1);x0.bezierCurveTo(-faceR*0.82,-faceR*0.02,-faceR*0.8,faceR*0.12,-faceR*0.72,faceR*0.18);x0.stroke();
  x0.beginPath();x0.moveTo( faceR*0.74,-faceR*0.1);x0.bezierCurveTo( faceR*0.82,-faceR*0.02, faceR*0.8,faceR*0.12, faceR*0.72,faceR*0.18);x0.stroke();
  // Inner scowl creases between brows
  ss(0.65,12,2.5);
  x0.beginPath();x0.moveTo(-faceR*0.13,-faceR*(0.3+furrow*0.7));x0.lineTo(-faceR*0.05,-faceR*0.16);x0.stroke();
  x0.beginPath();x0.moveTo( faceR*0.13,-faceR*(0.3+furrow*0.7));x0.lineTo( faceR*0.05,-faceR*0.16);x0.stroke();

  // ── EYES — deep-set, hooded, intense ─────────────────
  const eyeY=-faceR*0.05;
  const eyeXL=-faceR*0.34,eyeXR=faceR*0.34;
  for(const[ex,ef] of [[eyeXL,charge],[eyeXR,charge]]){
    // Deep socket void
    x0.fillStyle=`rgba(0,0,0,${0.6+anger*0.2})`;
    x0.beginPath();x0.ellipse(ex,eyeY,faceR*0.185,faceR*0.135,0,0,Math.PI*2);x0.fill();
    // Heavy overhanging upper lid
    ss(0.82+ef*0.18,16+ef*35,3);
    x0.shadowColor=ef>0.15?'rgba(255,255,80,1)':'rgba(200,225,255,0.95)';
    x0.beginPath();
    x0.moveTo(ex-faceR*0.185,eyeY+faceR*0.01);
    x0.bezierCurveTo(ex-faceR*0.13,eyeY-faceR*0.145,ex+faceR*0.07,eyeY-faceR*0.14,ex+faceR*0.185,eyeY-faceR*0.01);
    x0.stroke();
    // Lower lid
    x0.beginPath();
    x0.moveTo(ex-faceR*0.185,eyeY+faceR*0.01);
    x0.bezierCurveTo(ex-faceR*0.08,eyeY+faceR*0.08,ex+faceR*0.08,eyeY+faceR*0.08,ex+faceR*0.185,eyeY-faceR*0.01);
    x0.stroke();
    // Iris ring
    const ir=faceR*0.09;
    x0.strokeStyle=`rgba(255,255,${ef>0.15?90:200},${0.75+ef*0.25})`;
    x0.shadowBlur=10+ef*55;x0.lineWidth=2.5;
    x0.beginPath();x0.arc(ex,eyeY,ir,0,Math.PI*2);x0.stroke();
    // Iris inner detail
    x0.lineWidth=1.2;x0.shadowBlur=5+ef*20;
    x0.beginPath();x0.arc(ex,eyeY,ir*0.62,0,Math.PI*2);x0.stroke();
    // Iris spokes
    for(let sp=0;sp<10;sp++){
      const sa=sp/10*Math.PI*2;
      x0.strokeStyle=`rgba(255,255,${ef>0.15?70:170},${0.28+ef*0.35})`;
      x0.lineWidth=0.9;x0.shadowBlur=3+ef*10;
      x0.beginPath();x0.moveTo(ex+Math.cos(sa)*ir*0.38,eyeY+Math.sin(sa)*ir*0.38);
      x0.lineTo(ex+Math.cos(sa)*ir*0.9,eyeY+Math.sin(sa)*ir*0.9);x0.stroke();
    }
    // Pupil
    x0.fillStyle='rgba(0,0,0,0.95)';x0.shadowBlur=0;
    x0.beginPath();x0.arc(ex,eyeY,ir*0.34,0,Math.PI*2);x0.fill();
    // Gleam
    x0.fillStyle=`rgba(255,255,255,${0.55+ef*0.4})`;
    x0.beginPath();x0.arc(ex-ir*0.28,eyeY-ir*0.25,ir*0.17,0,Math.PI*2);x0.fill();
    // Charge beam
    if(ef>0.08&&SD.cpTarget&&SD.cpTarget.alive){
      const tgt=SD.cpTarget;
      const lx=(tgt.x-cx)*Math.cos(-Z.tilt)-(tgt.y-h*0.21)*Math.sin(-Z.tilt);
      const ly=(tgt.x-cx)*Math.sin(-Z.tilt)+(tgt.y-h*0.21)*Math.cos(-Z.tilt);
      const dist=Math.hypot(lx-ex,ly-eyeY)||1;
      x0.save();x0.globalAlpha=ef*0.55;
      x0.strokeStyle='rgba(255,255,100,1)';x0.lineWidth=2+ef*6;
      x0.shadowBlur=28;x0.shadowColor='rgba(255,255,0,1)';
      x0.beginPath();x0.moveTo(ex,eyeY);x0.lineTo(ex+(lx-ex)/dist*faceR*0.9,eyeY+(ly-eyeY)/dist*faceR*0.9);x0.stroke();
      x0.restore();
    }
  }

  // ── NOSE — aquiline Roman bridge ──────────────────────
  ss(0.78,14,3.2);
  x0.beginPath();
  x0.moveTo(-faceR*0.07,-faceR*0.2);
  x0.bezierCurveTo(-faceR*0.09,faceR*0.06,-faceR*0.06,faceR*0.22,-faceR*0.05,faceR*0.3);
  x0.stroke();
  x0.beginPath();
  x0.moveTo( faceR*0.07,-faceR*0.2);
  x0.bezierCurveTo( faceR*0.09,faceR*0.06, faceR*0.06,faceR*0.22, faceR*0.05,faceR*0.3);
  x0.stroke();
  // Nostril wings
  ss(0.6,9,2);
  x0.beginPath();x0.moveTo(-faceR*0.05,faceR*0.28);x0.bezierCurveTo(-faceR*0.18,faceR*0.23,-faceR*0.23,faceR*0.36,-faceR*0.14,faceR*0.39);x0.stroke();
  x0.beginPath();x0.moveTo( faceR*0.05,faceR*0.28);x0.bezierCurveTo( faceR*0.18,faceR*0.23, faceR*0.23,faceR*0.36, faceR*0.14,faceR*0.39);x0.stroke();
  // Nose bridge ridge
  ss(0.38,6,1.2);
  x0.beginPath();x0.moveTo(0,-faceR*0.2);x0.lineTo(0,faceR*0.28);x0.stroke();

  // ── CHEEKBONES — sculptural definition ───────────────
  ss(0.42,10,1.8);
  x0.beginPath();x0.moveTo(-faceR*0.6,faceR*0.1);x0.bezierCurveTo(-faceR*0.72,faceR*0.22,-faceR*0.7,faceR*0.38,-faceR*0.58,faceR*0.42);x0.stroke();
  x0.beginPath();x0.moveTo( faceR*0.6,faceR*0.1);x0.bezierCurveTo( faceR*0.72,faceR*0.22, faceR*0.7,faceR*0.38, faceR*0.58,faceR*0.42);x0.stroke();

  // ── MUSTACHE — thick, curling ─────────────────────────
  ss(0.82,16,4);
  x0.beginPath();
  x0.moveTo(-faceR*0.35,faceR*0.41);
  x0.bezierCurveTo(-faceR*0.22,faceR*0.38,-faceR*0.08,faceR*0.42,0,faceR*0.44);
  x0.bezierCurveTo( faceR*0.08,faceR*0.42, faceR*0.22,faceR*0.38,faceR*0.35,faceR*0.41);
  x0.stroke();
  // Curled ends
  ss(0.72,10,2.5);
  x0.beginPath();x0.moveTo(-faceR*0.35,faceR*0.41);x0.bezierCurveTo(-faceR*0.44,faceR*0.36,-faceR*0.46,faceR*0.3,-faceR*0.38,faceR*0.28);x0.stroke();
  x0.beginPath();x0.moveTo( faceR*0.35,faceR*0.41);x0.bezierCurveTo( faceR*0.44,faceR*0.36, faceR*0.46,faceR*0.3, faceR*0.38,faceR*0.28);x0.stroke();

  // ── MOUTH — commanding, lips with philtrum detail ─────
  const mOpen=anger*0.05+charge*0.025;
  ss(0.72,14,3);
  // Upper lip — Cupid's bow
  x0.beginPath();
  x0.moveTo(-faceR*0.3,faceR*0.48+mOpen);
  x0.bezierCurveTo(-faceR*0.18,faceR*0.44+mOpen,-faceR*0.07,faceR*0.5+mOpen,0,faceR*0.47+mOpen);
  x0.bezierCurveTo( faceR*0.07,faceR*0.5+mOpen, faceR*0.18,faceR*0.44+mOpen,faceR*0.3,faceR*0.48+mOpen);
  x0.stroke();
  // Lower lip
  x0.beginPath();
  x0.moveTo(-faceR*0.3,faceR*0.48+mOpen);
  x0.bezierCurveTo(-faceR*0.2,faceR*0.62,faceR*0.2,faceR*0.62,faceR*0.3,faceR*0.48+mOpen);
  x0.stroke();
  // Lip line
  ss(0.45,7,1.5);
  x0.beginPath();x0.moveTo(-faceR*0.3,faceR*0.48+mOpen);x0.lineTo(faceR*0.3,faceR*0.48+mOpen);x0.stroke();
  // Philtrum
  x0.beginPath();x0.moveTo(-faceR*0.06,faceR*0.39);x0.lineTo(-faceR*0.04,faceR*0.46+mOpen);x0.stroke();
  x0.beginPath();x0.moveTo( faceR*0.06,faceR*0.39);x0.lineTo( faceR*0.04,faceR*0.46+mOpen);x0.stroke();

  // ── BEARD — vast, layered, animated flowing strands ───
  ss(0.7,10,2.2);
  // Outer beard silhouette
  x0.beginPath();
  x0.moveTo(-faceR*0.72,faceR*0.44);
  x0.bezierCurveTo(-faceR*0.88,faceR*0.72,-faceR*0.94,faceR*1.15,-faceR*0.72,faceR*1.55);
  x0.bezierCurveTo(-faceR*0.42,faceR*1.82,faceR*0.42,faceR*1.82,faceR*0.72,faceR*1.55);
  x0.bezierCurveTo( faceR*0.94,faceR*1.15, faceR*0.88,faceR*0.72, faceR*0.72,faceR*0.44);
  x0.stroke();
  // 18 animated strands
  for(let b=0;b<18;b++){
    const bf=b/17;
    const bx=-faceR*0.68+bf*faceR*1.36;
    const sy=faceR*(0.52+Math.pow(Math.abs(bf-0.5)*2,1.8)*0.12);
    const endM=1.25+Math.sin(bf*Math.PI)*0.48;
    const wa=t*0.0007;
    x0.strokeStyle=`rgba(255,255,222,${(0.32+Math.sin(bf*Math.PI)*0.32)*glow})`;
    x0.lineWidth=0.9+Math.sin(bf*Math.PI)*1.8;
    x0.shadowBlur=5+Math.sin(bf*Math.PI)*7;
    x0.shadowColor='rgba(200,220,255,0.7)';
    x0.beginPath();x0.moveTo(bx,sy);
    x0.bezierCurveTo(
      bx+Math.sin(b*0.85+wa)*17,   sy+faceR*0.36,
      bx+Math.sin(b*0.62+wa*0.8)*14,sy+faceR*0.76,
      bx+Math.sin(b*1.1+wa*1.1)*10, sy+faceR*endM
    );x0.stroke();
  }
  // Beard curl clusters at bottom
  ss(0.52,7,1.8);
  for(let c=0;c<7;c++){
    const cx2=-faceR*0.55+c*faceR*0.185;
    const cy2=faceR*(1.38+Math.sin(c*1.3)*0.08);
    x0.beginPath();x0.arc(cx2+Math.sin(t*0.0007+c)*5,cy2,faceR*0.055,0,Math.PI*2);x0.stroke();
  }

  // ── EARS — partially visible at sides ─────────────────
  ss(0.48,10,2.2);
  for(const[ex2,dir] of [[-faceR*0.8,-1],[faceR*0.8,1]]){
    const ey2=faceR*0.06;
    x0.beginPath();x0.arc(ex2,ey2,faceR*0.105,dir>0?-Math.PI*0.6:-Math.PI*0.4,dir>0?Math.PI*0.4:Math.PI*0.6);x0.stroke();
    ss(0.3,5,1);
    x0.beginPath();x0.arc(ex2,ey2,faceR*0.058,dir>0?-Math.PI*0.45:-Math.PI*0.28,dir>0?Math.PI*0.28:Math.PI*0.45);x0.stroke();
    // Earlobe
    ss(0.4,7,1.8);
    x0.beginPath();x0.arc(ex2,ey2+faceR*0.1,faceR*0.042,0,Math.PI*2);x0.stroke();
  }

  x0.lineCap='butt'; x0.lineJoin='miter'; x0.shadowBlur=0; x0.restore();

    // ── Centerpiece target ───────────────────────────────
  if(!SD.cpTarget){SD.cpTarget={x:w*0.25+Math.random()*w*0.5,y:h*0.62+Math.random()*h*0.15,alive:true,debris:[],spawnTimer:0,reforming:false,reformProgress:0};}
  const cpt=SD.cpTarget;
  cpt.spawnTimer+=16;

  // Draw living centerpiece
  if(cpt.alive){
    const cpSz=Math.min(w,h)*(0.1+SM.beatPulse*0.025);
    cpPh+=0.013;cpRot+=0.022;
    // Glow halo pulses when Zeus is charging
    const chargeGlow=Z.shootState==='charging'?Z.eyeFlashL:0;
    x0.shadowBlur=cpSz*(0.4+chargeGlow*0.8);
    x0.shadowColor=chargeGlow>0.3?'rgba(255,255,100,0.9)':pc(0);
    if(chargeGlow>0.3){x0.globalAlpha=0.9+chargeGlow*0.1;}
    drawCPMini(x0,THEME.centerpiece,cpt.x,cpt.y,cpSz,cpRot);
    x0.shadowBlur=0;x0.globalAlpha=1;
  }

  // Debris from destroyed centerpiece — and reform logic
  if(cpt.debris.length>0){
    // Check if all debris has slowed enough to start reforming
    const avgLife=cpt.debris.reduce((s,d)=>s+d.life,0)/cpt.debris.length;
    if(avgLife<0.45&&!cpt.reforming){cpt.reforming=true;cpt.reformProgress=0;}

    for(let i=cpt.debris.length-1;i>=0;i--){
      const d=cpt.debris[i];
      if(cpt.reforming){
        // Pull debris back toward new spawn point
        if(!cpt.reformX){cpt.reformX=w*0.2+Math.random()*w*0.6;cpt.reformY=h*0.55+Math.random()*h*0.15;}
        const dx=cpt.reformX-d.x,dy=cpt.reformY-d.y;
        d.vx+=dx*0.02;d.vy+=dy*0.02;
        d.vx*=0.88;d.vy*=0.88;
        cpt.reformProgress+=0.0008;
        d.life=Math.min(d.life+0.003,0.8);
      } else {
        d.vx*=0.98;d.vy+=0.12;
        d.life-=0.009;
      }
      d.x+=d.vx;d.y+=d.vy;d.rot+=d.rotS;

      if(d.life<=0){cpt.debris.splice(i,1);continue;}

      x0.save();x0.translate(d.x,d.y);x0.rotate(d.rot);x0.globalAlpha=d.life;
      x0.shadowBlur=6*(1-d.life)*2;x0.shadowColor=pc(d.ci);
      x0.fillStyle=rgba(pc(d.ci),0.85);x0.fillRect(-d.sz/2,-d.sz/2,d.sz,d.sz);
      x0.restore();
    }

    // All debris converged — snap to alive
    if(cpt.reforming&&cpt.reformProgress>1&&cpt.debris.length<5){
      cpt.debris=[];cpt.alive=true;cpt.reforming=false;cpt.reformProgress=0;
      cpt.x=cpt.reformX||cx;cpt.y=cpt.reformY||h*0.6;
      delete cpt.reformX;delete cpt.reformY;
      cpt.spawnTimer=0;
      flash(rgba(pc(0),0.5),300);
    }
  }

  // ── Incoming converging bolts ────────────────────────
  if(!SD.boltsComing)SD.boltsComing=[];
  for(let i=SD.boltsComing.length-1;i>=0;i--){
    const b=SD.boltsComing[i];
    b.x+=b.vx;b.y+=b.vy;b.size*=1.04;b.life-=0.022;

    // Hit detection
    if(b.target&&b.target.alive){
      const hitDist=Math.hypot(b.x-b.target.x,b.y-b.target.y);
      if(hitDist<50){
        flash('rgba(255,255,150,0.95)',100);
        b.target.alive=false;b.target.reforming=false;
        for(let d=0;d<22;d++){
          b.target.debris.push({
            x:b.target.x,y:b.target.y,
            vx:(Math.random()-0.5)*14,vy:-(Math.random()*10+1),
            life:1,rot:Math.random()*Math.PI*2,rotS:(Math.random()-0.5)*0.22,
            sz:6+Math.random()*18,ci:Math.floor(Math.random()*4)
          });
        }
        Z.angry=Math.min(1,(Z.angry||0)+0.3);
        SD.boltsComing.splice(i,1);continue;
      }
    }
    if(b.life<=0||b.y>h||b.x<0||b.x>w){SD.boltsComing.splice(i,1);continue;}

    // Draw bolt as zigzag lightning
    x0.save();x0.shadowBlur=20+b.size;x0.shadowColor='rgba(255,255,100,1)';
    x0.strokeStyle=`rgba(255,255,${Math.floor(100+b.life*155)},${b.life})`;
    x0.lineWidth=2+b.size*0.15;
    // Zigzag along bolt direction
    const len=30+b.size*2;
    const perpX=-b.vy/(Math.hypot(b.vx,b.vy)||1);
    const perpY=b.vx/(Math.hypot(b.vx,b.vy)||1);
    x0.beginPath();x0.moveTo(b.x,b.y);
    for(let s=0;s<5;s++){
      const frac=(s+1)/5;
      const jitter=(Math.random()-0.5)*12;
      x0.lineTo(b.x+b.vx/16*len*frac+perpX*jitter,b.y+b.vy/16*len*frac+perpY*jitter);
    }
    x0.stroke();
    x0.shadowBlur=0;x0.restore();
  }

  // Angry meter fades
  if(Z.angry>0)Z.angry=Math.max(0,Z.angry-0.003);

  // ── Background lightning ─────────────────────────────
  if(!SD.lightnings)SD.lightnings=[];
  SD.ltTimer=(SD.ltTimer||0)-16;
  if(SD.ltTimer<0){SD.lightnings.push(mkLightning());SD.ltTimer=2500+Math.random()*3500;}
  for(let i=SD.lightnings.length-1;i>=0;i--){
    const lt=SD.lightnings[i];lt.life-=0.045;
    if(lt.life<=0){SD.lightnings.splice(i,1);continue;}
    x0.shadowBlur=18;x0.shadowColor=pc(lt.ci);
    for(const seg of lt.segs){
      x0.beginPath();x0.moveTo(seg.x1,seg.y1);x0.lineTo(seg.x2,seg.y2);
      x0.strokeStyle=rgba(pc(lt.ci),lt.life*0.8);x0.lineWidth=lt.life*2;x0.stroke();
    }x0.shadowBlur=0;
  }
}
function drawSuperMario(t){
  const w=W(),h=H();
  // Sky
  x0.fillStyle='#1a1a2e';x0.fillRect(0,0,w,h);
  // Stars
  if(!SD.marioStars){SD.marioStars=Array.from({length:80},()=>({x:Math.random()*w,y:Math.random()*h*0.5,b:Math.random()}));}
  for(const s of SD.marioStars){x0.fillStyle=`rgba(255,255,255,${0.3+Math.abs(Math.sin(t*0.001+s.b*10))*0.5})`;x0.fillRect(s.x,s.y,s.b>0.8?2:1,s.b>0.8?2:1);}
  // Scrolling background
  SD.scrollX=(SD.scrollX||0)+THEME.sceneSpeed*(1+SM.energy*0.3)*(1+beatFX.speedBoost*0.5);
  // Neon ground
  x0.fillStyle=rgba(pc(2),0.85);x0.fillRect(0,h*0.78,w,h*0.06);
  x0.fillStyle=rgba(pc(0),0.6);x0.fillRect(0,h*0.84,w,h*0.16);
  // Ground pattern
  x0.strokeStyle=rgba(pc(2),0.15);x0.lineWidth=1;
  for(let gx=0;gx<w;gx+=40){x0.beginPath();x0.moveTo((gx-SD.scrollX*0.3)%w,h*0.78);x0.lineTo((gx-SD.scrollX*0.3)%w,h);x0.stroke();}
  // Clouds
  for(let c=0;c<4;c++){const cx2=((c*w/3+t*0.018)%w+w)%w,cy2=h*0.12+c*h*0.05;x0.fillStyle='rgba(30,25,60,0.9)';x0.shadowBlur=8;x0.shadowColor=rgba(pc(2),0.3);x0.beginPath();x0.arc(cx2,cy2,35,0,Math.PI*2);x0.arc(cx2+28,cy2-8,25,0,Math.PI*2);x0.arc(cx2+55,cy2,35,0,Math.PI*2);x0.fill();x0.shadowBlur=0;}
  // Pipes
  if(!SD.pipes){SD.pipes=Array.from({length:4},(_,i)=>({x:i*(w/3)+w*0.2,h:h*0.12+Math.random()*h*0.1}));}
  for(const pipe of SD.pipes){const px=((pipe.x-SD.scrollX%w+w*2)%w);x0.fillStyle=rgba(pc(2),0.8);x0.fillRect(px-18,h*0.78-pipe.h,36,pipe.h);x0.fillRect(px-23,h*0.78-pipe.h,46,18);x0.strokeStyle=rgba(pc(2),0.4);x0.lineWidth=1;x0.strokeRect(px-23,h*0.78-pipe.h,46,18);}
  // Platforms
  if(!SD.platforms){SD.platforms=Array.from({length:5},(_,i)=>({x:i*(w/4)+Math.random()*w*0.1,y:h*(0.42+Math.random()*0.2),w:60+Math.random()*80}));}
  for(const p of SD.platforms){const px=((p.x-SD.scrollX*0.5+w*2)%w);x0.fillStyle=rgba(pc(0),0.85);x0.shadowBlur=8;x0.shadowColor=pc(0);x0.fillRect(px,p.y,p.w,14);x0.shadowBlur=0;}
  // Question blocks — centerpiece IS the spinning collectible block
  const cpBlockX=((w*0.5-SD.scrollX*0.7+w*2)%w);
  const cpBlockY=h*0.45+Math.sin(t*0.002)*8;
  const blkSz=36*(1+SM.beatPulse*0.12);
  if(THEME.centerpiece){
    cpPh+=0.013;cpRot+=0.025;
    // Block frame
    x0.fillStyle=rgba(pc(1),0.9);x0.shadowBlur=20;x0.shadowColor=pc(1);
    x0.fillRect(cpBlockX-blkSz/2,cpBlockY-blkSz/2,blkSz,blkSz);
    x0.strokeStyle='rgba(0,0,0,0.5)';x0.lineWidth=2;x0.strokeRect(cpBlockX-blkSz/2,cpBlockY-blkSz/2,blkSz,blkSz);
    x0.shadowBlur=0;
    // Centerpiece inside the block (spinning)
    x0.save();x0.beginPath();x0.rect(cpBlockX-blkSz/2,cpBlockY-blkSz/2,blkSz,blkSz);x0.clip();
    drawCPMini(x0,THEME.centerpiece,cpBlockX,cpBlockY,blkSz*0.45,cpRot);
    x0.restore();
    // "?" label when not hit
    x0.fillStyle='rgba(0,0,0,0.6)';x0.font=`bold ${blkSz*0.5}px monospace`;x0.textAlign='center';
    x0.fillText('?',cpBlockX,cpBlockY+blkSz*0.18);x0.textAlign='left';
  }
  // Goombas
  if(!SD.goombas){SD.goombas=Array.from({length:4},(_,i)=>({x:w*0.2+i*w*0.22,y:h*0.745,vx:0.6+Math.random()*0.4,ph:Math.random()*Math.PI*2}));}
  for(const g of SD.goombas){g.x+=g.vx*(1+SM.energy*0.2);if(g.x<-30||g.x>w+30)g.vx*=-1;g.ph+=0.05;const walkanim=Math.sin(g.ph)*g.vx*0.3;x0.fillStyle=rgba(pc(2),0.9);x0.shadowBlur=6;x0.shadowColor=pc(2);x0.beginPath();x0.arc(g.x,g.y,16,Math.PI,0);x0.fill();x0.beginPath();x0.ellipse(g.x,g.y+4,18,10,0,0,Math.PI*2);x0.fill();x0.fillStyle='rgba(0,0,0,0.8)';x0.beginPath();x0.arc(g.x-6,g.y-2,4,0,Math.PI*2);x0.arc(g.x+6,g.y-2,4,0,Math.PI*2);x0.fill();x0.shadowBlur=0;}
  // Mario character
  const my=h*0.705;const mx=w*0.25;
  x0.fillStyle=rgba(pc(0),0.95);x0.shadowBlur=10;x0.shadowColor=pc(0);
  x0.fillRect(mx-10,my-38,22,38);x0.beginPath();x0.arc(mx,my-40,13,0,Math.PI*2);x0.fill();
  x0.fillRect(mx-14,my-54,30,12);x0.fillRect(mx-8,my-68,18,15);
  x0.fillStyle='rgba(200,160,120,0.9)';x0.beginPath();x0.arc(mx,my-40,9,0,Math.PI*2);x0.fill();
  x0.shadowBlur=0;
}
function drawAtlantis(t){
  const w=W(),h=H(),cx=w/2;
  const beat=SM.beatPulse,energy=SM.energy;
  const floorY=h*0.88;

  // ── Init ─────────────────────────────────────────────
  if(!SD.atl){
    SD.atl={
      // Sea creatures
      anglerfish:Array.from({length:3},(_,i)=>({
        x:Math.random()*w, y:h*(0.2+Math.random()*0.45),
        vx:(Math.random()<0.5?1:-1)*(0.4+Math.random()*0.5),
        sz:22+Math.random()*18, ph:Math.random()*Math.PI*2,
        ci:i%4, mouthPh:Math.random()*Math.PI*2,
        lurePh:Math.random()*Math.PI*2,
      })),
      mantas:Array.from({length:4},(_,i)=>({
        x:Math.random()*w, y:h*(0.08+Math.random()*0.3),
        vx:(Math.random()<0.5?1:-1)*(0.6+Math.random()*0.5),
        sz:35+Math.random()*30, ph:Math.random()*Math.PI*2,
        ci:i%4, waveAmp:0,
      })),
      eels:Array.from({length:5},(_,i)=>({
        x:Math.random()*w, y:h*(0.55+Math.random()*0.25),
        vx:(Math.random()<0.5?1:-1)*(0.3+Math.random()*0.3),
        sz:50+Math.random()*40, ph:Math.random()*Math.PI*2,
        phSpeed:0.025+Math.random()*0.015, ci:i%4,
        segments:12,
      })),
      // Bubbles
      bubbles:Array.from({length:35},()=>({
        x:Math.random()*w, y:Math.random()*h,
        vy:-(0.3+Math.random()*0.6), r:2+Math.random()*5,
        ph:Math.random()*Math.PI*2, ci:Math.floor(Math.random()*4),
        vx:(Math.random()-0.5)*0.2,
      })),
      // Caustic light ripples
      caustics:Array.from({length:8},(_,i)=>({
        x:Math.random()*w, y:Math.random()*h*0.5,
        r:60+Math.random()*80, ph:Math.random()*Math.PI*2,
        speed:0.008+Math.random()*0.006, ci:i%4,
      })),
      // Light shafts from surface
      shafts:Array.from({length:5},(_,i)=>({
        x:w*0.1+i*(w*0.2), ph:i*0.4, speed:0.004+Math.random()*0.003,
      })),
      // Statues — still standing heroes, react to beat
      statues:[
        {x:cx-w*0.35, y:floorY, sz:h*0.28, lean:0, leanDir:1, ci:2, intact:true},
        {x:cx+w*0.28, y:floorY, sz:h*0.34, lean:0, leanDir:-1, ci:3, intact:true},
        {x:cx-w*0.12, y:floorY, sz:h*0.24, lean:0, leanDir:1, ci:0, intact:true},
        // Toppled statue on ground
        {x:cx+w*0.12, y:floorY, sz:h*0.22, lean:Math.PI/2, leanDir:0, ci:1, intact:false},
      ],
      // Ruins columns
      columns:[
        {x:cx-w*0.46, y:floorY, h:h*0.44, broken:false, ci:2},
        {x:cx-w*0.34, y:floorY, h:h*0.28, broken:true,  ci:3},
        {x:cx-w*0.22, y:floorY, h:h*0.50, broken:false, ci:0},
        {x:cx-w*0.08, y:floorY, h:h*0.36, broken:true,  ci:1},
        {x:cx+w*0.05, y:floorY, h:h*0.54, broken:false, ci:2},
        {x:cx+w*0.18, y:floorY, h:h*0.30, broken:true,  ci:3},
        {x:cx+w*0.32, y:floorY, h:h*0.46, broken:false, ci:0},
        {x:cx+w*0.48, y:floorY, h:h*0.22, broken:true,  ci:1},
      ],
      // Fallen column pieces on ground
      fallenCols:[
        {x:cx-w*0.29, y:floorY-8,  w:w*0.19, ci:3},
        {x:cx+w*0.08, y:floorY-6,  w:w*0.15, ci:1},
        {x:cx+w*0.38, y:floorY-10, w:w*0.17, ci:0},
      ],
      // Cracked road tiles
      roadTiles:Array.from({length:18},(_,i)=>({
        x:i/17*w, y:floorY+h*0.01, w:w/17, crack:Math.random()>0.4,
        ci:i%4,
      })),
      // Rubble piles at base
      rubble:Array.from({length:6},(_,i)=>({
        x:w*0.05+i*(w*0.17), y:floorY, r:14+Math.random()*18, ci:i%4,
      })),
      // Toppled arch fragment
      arch:{x:cx-w*0.05, y:floorY, w:w*0.18, h:h*0.22, ci:2},
      // Kraken
      kraken:null,
      // Whirlpool
      whirlpool:null,
      // Bubble storm
      bubbleStorm:false,
      // Destruction debris
      debris:[],
    };
  }
  const A=SD.atl;

  // ── Deep ocean background ────────────────────────────
  const deep=x0.createLinearGradient(0,0,0,h);
  const sc0=h2r(pc(0)),sc2=h2r(pc(2));
  deep.addColorStop(0,`rgba(${Math.round(sc0.r*0.05)},${Math.round(sc0.g*0.08)},${Math.round(sc0.b*0.12)},1)`);
  deep.addColorStop(0.5,`rgba(${Math.round(sc2.r*0.03)},${Math.round(sc2.g*0.05)},${Math.round(sc2.b*0.1)},1)`);
  deep.addColorStop(1,'rgba(1,2,6,1)');
  x0.fillStyle=deep;x0.fillRect(0,0,w,h);

  // ── Caustic light ripples (surface light through water) ──
  for(const c of A.caustics){
    c.ph+=c.speed;
    const alpha=0.04+Math.sin(c.ph)*0.025;
    const cg=x0.createRadialGradient(c.x+Math.sin(c.ph)*20,c.y,0,c.x,c.y,c.r*(1+beat*0.1));
    cg.addColorStop(0,rgba(pc(c.ci),alpha*(1+beat*0.3)));cg.addColorStop(1,'transparent');
    x0.fillStyle=cg;x0.fillRect(0,0,w,h);
  }

  // ── Light shafts from above ──────────────────────────
  for(const sh of A.shafts){
    sh.ph+=sh.speed;
    const sx=sh.x+Math.sin(sh.ph)*25;
    const sg=x0.createLinearGradient(sx,0,sx+w*0.06,h*0.7);
    sg.addColorStop(0,rgba(pc(0),0.04*(1+beat*0.2)));sg.addColorStop(1,'transparent');
    x0.fillStyle=sg;
    x0.beginPath();x0.moveTo(sx-20,0);x0.lineTo(sx+30,0);x0.lineTo(sx+80,h*0.7);x0.lineTo(sx-40,h*0.7);x0.closePath();x0.fill();
  }

  // ── Seafloor ─────────────────────────────────────────
  // Deep silt floor — layered
  const floorG=x0.createLinearGradient(0,floorY,0,h);
  floorG.addColorStop(0,`rgba(${Math.round(sc2.r*0.12)},${Math.round(sc2.g*0.1)},${Math.round(sc2.b*0.18)},0.9)`);
  floorG.addColorStop(1,'rgba(2,1,4,1)');
  x0.fillStyle=floorG;x0.fillRect(0,floorY,w,h-floorY);
  // Bioluminescent algae glow on floor line
  x0.shadowBlur=18;x0.shadowColor=rgba(pc(2),0.5);
  x0.strokeStyle=rgba(pc(2),0.25*(1+beat*0.2));x0.lineWidth=2;
  x0.beginPath();x0.moveTo(0,floorY);x0.lineTo(w,floorY);x0.stroke();
  x0.shadowBlur=0;

  // ── Road tiles — cracked mosaic ──────────────────────
  for(const tile of A.roadTiles){
    x0.fillStyle=rgba(pc(tile.ci),0.04);
    x0.fillRect(tile.x,floorY,tile.w-1,h*0.025);
    if(tile.crack){
      x0.strokeStyle=rgba(pc(tile.ci),0.06*(1+beat*0.15));x0.lineWidth=1;
      x0.shadowBlur=3;x0.shadowColor=pc(tile.ci);
      x0.beginPath();x0.moveTo(tile.x+tile.w*0.2,floorY);x0.lineTo(tile.x+tile.w*0.6,floorY+h*0.018);x0.lineTo(tile.x+tile.w*0.9,floorY+h*0.008);x0.stroke();
      x0.shadowBlur=0;
    }
  }

  // ── Rubble piles ─────────────────────────────────────
  for(const rb of A.rubble){
    x0.shadowBlur=6;x0.shadowColor=rgba(pc(rb.ci),0.3);
    x0.fillStyle=rgba(pc(rb.ci),0.12*(1+beat*0.1));
    x0.beginPath();x0.ellipse(rb.x,rb.y,rb.r*1.8,rb.r*0.5,0,0,Math.PI*2);x0.fill();
    // Small rock chunks
    for(let r=0;r<4;r++){
      const rx=rb.x+(r-1.5)*rb.r*0.5;const ry=rb.y-(r%2)*rb.r*0.3;
      x0.fillStyle=rgba(pc(rb.ci),0.2);
      x0.beginPath();x0.ellipse(rx,ry,rb.r*0.3,rb.r*0.2,r*0.3,0,Math.PI*2);x0.fill();
    }
    x0.shadowBlur=0;
  }

  // ── Fallen column pieces ─────────────────────────────
  for(const fc of A.fallenCols){
    const algaeGlow=rgba(pc(fc.ci),0.18*(1+beat*0.15));
    x0.shadowBlur=12;x0.shadowColor=algaeGlow;
    x0.fillStyle=rgba(pc(fc.ci),0.15);
    x0.fillRect(fc.x,fc.y-h*0.025,fc.w,h*0.025);
    // Column drum rings along fallen piece
    x0.strokeStyle=rgba(pc(fc.ci),0.25*(1+beat*0.1));x0.lineWidth=1.5;
    for(let dr=0;dr<5;dr++){
      const drX=fc.x+fc.w*(dr/4);
      x0.beginPath();x0.moveTo(drX,fc.y-h*0.025);x0.lineTo(drX,fc.y);x0.stroke();
    }
    x0.shadowBlur=0;
  }

  // ── Toppled arch fragment ────────────────────────────
  const arc=A.arch;
  x0.shadowBlur=14;x0.shadowColor=rgba(pc(arc.ci),0.35);
  x0.strokeStyle=rgba(pc(arc.ci),0.3*(1+beat*0.15));x0.lineWidth=4;
  // Arch lying on its side — two pillars and arch curve, rotated ~70deg
  x0.save();x0.translate(arc.x,arc.y);x0.rotate(0.4);
  x0.beginPath();x0.moveTo(0,0);x0.lineTo(0,-arc.h);
  x0.bezierCurveTo(0,-arc.h-arc.w*0.4,arc.w,-arc.h-arc.w*0.4,arc.w,-arc.h);
  x0.lineTo(arc.w,0);x0.stroke();
  x0.restore();x0.shadowBlur=0;

  // ── Standing columns ─────────────────────────────────
  for(const col of A.columns){
    const algGlow=rgba(pc(col.ci),0.28*(1+beat*0.18));
    x0.shadowBlur=16;x0.shadowColor=algGlow;
    const colW=w*0.038;
    // Column shaft — tapered (wider at base)
    x0.fillStyle=rgba(pc(col.ci),0.16);
    x0.beginPath();
    x0.moveTo(col.x-colW*0.55,col.y);
    x0.lineTo(col.x-colW*0.45,col.y-col.h);
    x0.lineTo(col.x+colW*0.45,col.y-col.h);
    x0.lineTo(col.x+colW*0.55,col.y);
    x0.closePath();x0.fill();
    // Glowing outline
    x0.strokeStyle=rgba(pc(col.ci),0.35*(1+beat*0.2));x0.lineWidth=1.5;x0.stroke();
    // Column drums — horizontal rings every ~8% height
    x0.strokeStyle=rgba(pc(col.ci),0.2);x0.lineWidth=1;
    for(let dr=1;dr<6;dr++){
      const dy=col.y-col.h*dr/6;
      x0.beginPath();x0.moveTo(col.x-colW*0.5,dy);x0.lineTo(col.x+colW*0.5,dy);x0.stroke();
    }
    // Capital (top)
    if(!col.broken){
      x0.fillStyle=rgba(pc(col.ci),0.22);
      x0.fillRect(col.x-colW*0.7,col.y-col.h-h*0.012,colW*1.4,h*0.012);
      x0.strokeStyle=rgba(pc(col.ci),0.4);x0.lineWidth=1.5;
      x0.strokeRect(col.x-colW*0.7,col.y-col.h-h*0.012,colW*1.4,h*0.012);
    } else {
      // Jagged break at top
      x0.strokeStyle=rgba(pc(col.ci),0.35);x0.lineWidth=1.5;
      x0.beginPath();
      x0.moveTo(col.x-colW*0.45,col.y-col.h);
      for(let jag=0;jag<5;jag++){
        x0.lineTo(col.x-colW*0.35+jag*(colW*0.18),(col.y-col.h)+(jag%2===0?-8:4));
      }
      x0.lineTo(col.x+colW*0.45,col.y-col.h);x0.stroke();
    }
    // Algae moss patches — green/teal glow spots on column
    for(let mg=0;mg<3;mg++){
      const mgy=col.y-col.h*(0.2+mg*0.3);
      x0.fillStyle=rgba(pc(2),0.08*(1+beat*0.1));x0.shadowBlur=6;x0.shadowColor=pc(2);
      x0.beginPath();x0.ellipse(col.x+(mg%2===0?1:-1)*colW*0.3,mgy,colW*0.4,h*0.008,0,0,Math.PI*2);x0.fill();
    }
    x0.shadowBlur=0;
  }

  // ── Statues — react to beat ───────────────────────────
  for(const st of A.statues){
    if(st.intact){
      // Beat pulse — slight lean back and forth
      if(beat>0.5)st.lean+=(st.leanDir*0.008);
      st.lean*=0.92;
      const stW=st.sz*0.18;
      x0.save();x0.translate(st.x,st.y);x0.rotate(st.lean);
      x0.shadowBlur=20+beat*12;x0.shadowColor=rgba(pc(st.ci),0.6);
      // Base plinth
      x0.fillStyle=rgba(pc(st.ci),0.18);
      x0.fillRect(-stW,-h*0.025,stW*2,h*0.025);
      x0.strokeStyle=rgba(pc(st.ci),0.4);x0.lineWidth=1.5;x0.strokeRect(-stW,-h*0.025,stW*2,h*0.025);
      // Legs
      x0.fillStyle=rgba(pc(st.ci),0.22);
      x0.fillRect(-stW*0.6,-st.sz*0.5,stW*0.45,st.sz*0.5);
      x0.fillRect(stW*0.15,-st.sz*0.5,stW*0.45,st.sz*0.5);
      // Torso
      x0.fillStyle=rgba(pc(st.ci),0.28);
      x0.beginPath();x0.ellipse(0,-st.sz*0.62,stW*0.55,st.sz*0.18,0,0,Math.PI*2);x0.fill();
      // Outstretched arm — raised in pose
      x0.strokeStyle=rgba(pc(st.ci),0.35);x0.lineWidth=stW*0.45;x0.lineCap='round';
      x0.beginPath();x0.moveTo(stW*0.5,-st.sz*0.62);x0.lineTo(stW*1.2,-st.sz*0.85+beat*st.sz*0.08);x0.stroke();
      x0.beginPath();x0.moveTo(-stW*0.5,-st.sz*0.62);x0.lineTo(-stW*0.9,-st.sz*0.5);x0.stroke();
      x0.lineCap='butt';
      // Head
      x0.fillStyle=rgba(pc(st.ci),0.32);x0.shadowBlur=14+beat*8;
      x0.beginPath();x0.ellipse(0,-st.sz*0.88,stW*0.38,stW*0.45,0,0,Math.PI*2);x0.fill();
      // Laurel crown detail line
      x0.strokeStyle=rgba(pc((st.ci+1)%4),0.4);x0.lineWidth=1.5;
      x0.beginPath();x0.arc(0,-st.sz*0.88,stW*0.42,Math.PI*1.1,Math.PI*1.9);x0.stroke();
      // Glow outline entire statue
      x0.strokeStyle=rgba(pc(st.ci),0.25*(1+beat*0.3));x0.lineWidth=1;
      x0.beginPath();x0.rect(-stW,-st.sz,stW*2,st.sz);x0.stroke();
      x0.shadowBlur=0;x0.restore();
    } else {
      // Toppled statue — lying on ground
      x0.save();x0.translate(st.x,st.y-h*0.015);x0.rotate(st.lean);
      x0.shadowBlur=10;x0.shadowColor=rgba(pc(st.ci),0.3);
      x0.fillStyle=rgba(pc(st.ci),0.18);
      x0.fillRect(-st.sz*0.5,-h*0.015,st.sz,h*0.03);
      // Head detached nearby
      x0.beginPath();x0.ellipse(st.sz*0.6,-h*0.008,h*0.025,h*0.028,0.3,0,Math.PI*2);x0.fill();
      x0.strokeStyle=rgba(pc(st.ci),0.3);x0.lineWidth=1.5;
      x0.beginPath();x0.ellipse(st.sz*0.6,-h*0.008,h*0.025,h*0.028,0.3,0,Math.PI*2);x0.stroke();
      x0.shadowBlur=0;x0.restore();
    }
  }

  // ── Power source centerpiece — in central ruins ───────
  if(THEME.centerpiece){
    const cpX=cx,cpY=floorY-h*0.06;
    const cpSz=Math.min(w,h)*(0.08+beat*0.025);
    cpRot+=0.012;cpPh+=0.013;
    const cpGlow=x0.createRadialGradient(cpX,cpY,0,cpX,cpY,cpSz*3);
    cpGlow.addColorStop(0,rgba(pc(0),0.2*(1+beat*0.4)));
    cpGlow.addColorStop(0.4,rgba(pc(1),0.07));
    cpGlow.addColorStop(1,'transparent');
    x0.fillStyle=cpGlow;x0.fillRect(0,0,w,h);
    x0.shadowBlur=cpSz*0.8;x0.shadowColor=rgba(pc(0),0.9);
    drawCPMini(x0,THEME.centerpiece,cpX,cpY,cpSz,cpRot);
    x0.shadowBlur=0;
  }

  // ── Destruction debris (from kraken) ─────────────────
  for(let i=A.debris.length-1;i>=0;i--){
    const d=A.debris[i];
    d.x+=d.vx;d.y+=d.vy;d.vy+=0.04;d.vx*=0.99;
    d.life-=0.004;d.rot+=d.rotS;
    if(d.life<=0){A.debris.splice(i,1);continue;}
    x0.save();x0.translate(d.x,d.y);x0.rotate(d.rot);x0.globalAlpha=Math.min(1,d.life*2);
    x0.fillStyle=rgba(pc(d.ci),0.7);x0.shadowBlur=4;x0.shadowColor=pc(d.ci);
    x0.fillRect(-d.sz/2,-d.sz/2,d.sz,d.sz);x0.shadowBlur=0;x0.restore();
  }

  // ── KRAKEN ───────────────────────────────────────────
  if(A.kraken){
    const K=A.kraken;
    K.age+=16;K.alpha=Math.min(0.9,K.alpha+0.012);
    if(K.retreating)K.alpha=Math.max(0,K.alpha-0.008);
    if(K.alpha<=0&&K.retreating){A.kraken=null;}

    // Eye — massive, above ruins
    if(!K.retreating){
      x0.save();x0.globalAlpha=K.alpha*0.8;
      x0.shadowBlur=40;x0.shadowColor=rgba(pc(0),0.9);
      x0.fillStyle=rgba(pc(0),0.6);
      x0.beginPath();x0.ellipse(K.eyeX,K.eyeY,K.eyeR*1.4,K.eyeR,0,0,Math.PI*2);x0.fill();
      x0.fillStyle='rgba(0,0,0,0.9)';
      x0.beginPath();x0.ellipse(K.eyeX,K.eyeY,K.eyeR*0.6,K.eyeR*0.5,0,0,Math.PI*2);x0.fill();
      x0.fillStyle='rgba(255,255,255,0.7)';
      x0.beginPath();x0.arc(K.eyeX-K.eyeR*0.3,K.eyeY-K.eyeR*0.2,K.eyeR*0.18,0,Math.PI*2);x0.fill();
      x0.shadowBlur=0;x0.restore();
    }

    // Tentacles — each grabs a different part of the ruins
    for(const ten of K.tentacles){
      ten.ph+=0.018*(1+beat*0.4);
      const grabProgress=Math.min(1,K.age/2000);
      x0.save();x0.globalAlpha=K.alpha*0.85;
      x0.strokeStyle=rgba(pc(ten.ci),0.75);
      x0.shadowBlur=18;x0.shadowColor=rgba(pc(ten.ci),0.6);
      x0.lineWidth=ten.thickness*(1+beat*0.1);x0.lineCap='round';
      // Draw tentacle as bezier with sucker dots
      const startX=ten.originX,startY=ten.originY;
      const midX=ten.midX+Math.sin(ten.ph)*20;
      const midY=ten.midY+Math.cos(ten.ph*0.7)*15;
      const endX=ten.targetX+Math.sin(ten.ph*1.3)*8*(1-grabProgress);
      const endY=ten.targetY+Math.cos(ten.ph*0.9)*6*(1-grabProgress);
      x0.beginPath();x0.moveTo(startX,startY);
      x0.bezierCurveTo(midX,midY,midX+20,endY-30,endX,endY);x0.stroke();
      // Sucker dots along tentacle
      x0.lineWidth=1;x0.shadowBlur=4;
      for(let sk=0;sk<5;sk++){
        const frac=(sk+1)/6;
        const skX=startX+(midX-startX)*frac+(endX-midX)*frac;
        const skY=startY+(midY-startY)*frac+(endY-midY)*frac;
        x0.strokeStyle=rgba(pc((ten.ci+1)%4),0.5);
        x0.beginPath();x0.arc(skX+Math.sin(ten.ph+sk)*5,skY,4,0,Math.PI*2);x0.stroke();
      }
      x0.lineCap='butt';x0.shadowBlur=0;x0.restore();
    }
  }

  // ── WHIRLPOOL ────────────────────────────────────────
  if(A.whirlpool){
    const WP=A.whirlpool;
    WP.rot+=WP.speed*(1+beat*0.4);
    WP.alpha=Math.min(0.85,WP.alpha+0.015);
    WP.radius=Math.min(WP.maxR,WP.radius+WP.growSpeed);
    if(WP.fading)WP.alpha=Math.max(0,WP.alpha-0.01);
    if(WP.alpha<=0&&WP.fading){A.whirlpool=null;}

    // Spiraling rings
    for(let ring=0;ring<8;ring++){
      const rFrac=ring/7;
      const rR=WP.radius*(1-rFrac*0.85);
      const rAlpha=WP.alpha*(1-rFrac*0.6);
      x0.strokeStyle=rgba(pc(ring%4),rAlpha);
      x0.lineWidth=2-rFrac*1.5;
      x0.shadowBlur=10*(1-rFrac)+beat*5;x0.shadowColor=pc(ring%4);
      x0.beginPath();
      // Spiral arc — not full circle, offset by rotation
      const startA=WP.rot+ring*0.7;
      x0.arc(WP.x,WP.y,Math.max(2,rR),startA,startA+Math.PI*1.6);
      x0.stroke();
    }
    // Dark vortex center
    const vg=x0.createRadialGradient(WP.x,WP.y,0,WP.x,WP.y,WP.radius*0.3);
    vg.addColorStop(0,'rgba(0,0,0,'+WP.alpha*0.9+')');vg.addColorStop(1,'transparent');
    x0.fillStyle=vg;x0.fillRect(0,0,w,h);
    // Suck fish toward whirlpool
    for(const f of [...A.anglerfish,...A.mantas,...A.eels]){
      if(WP.alpha>0.4){
        const dx=WP.x-f.x,dy=WP.y-f.y,dist=Math.hypot(dx,dy)||1;
        if(dist<WP.radius*1.5){
          f.x+=dx/dist*1.5*WP.alpha;f.y+=dy/dist*1.5*WP.alpha;
        }
      }
    }
    x0.shadowBlur=0;
  }

  // ── SEA CREATURES ────────────────────────────────────

  // Eels — weave through ruins with segmented body
  for(const eel of A.eels){
    eel.ph+=eel.phSpeed*(1+beat*0.3);
    eel.x+=eel.vx*(1+energy*0.2);
    if(eel.x<-eel.sz)eel.x=w+eel.sz;
    if(eel.x>w+eel.sz)eel.x=-eel.sz;
    x0.save();x0.shadowBlur=12;x0.shadowColor=rgba(pc(eel.ci),0.7);
    x0.strokeStyle=rgba(pc(eel.ci),0.65);x0.lineWidth=5+beat*2;x0.lineCap='round';
    x0.beginPath();
    for(let seg=0;seg<eel.segments;seg++){
      const sx=eel.x-eel.vx*seg*(eel.sz/eel.segments);
      const sy=eel.y+Math.sin(eel.ph+seg*0.5)*18*(1+beat*0.3);
      seg===0?x0.moveTo(sx,sy):x0.lineTo(sx,sy);
    }
    x0.stroke();
    // Eel head — glowing eye
    x0.fillStyle=rgba(pc(eel.ci),0.8);x0.beginPath();x0.ellipse(eel.x,eel.y,10+beat*2,7,eel.vx>0?0:Math.PI,0,Math.PI*2);x0.fill();
    x0.fillStyle='rgba(255,255,100,0.9)';x0.shadowBlur=8;x0.shadowColor='rgba(255,255,0,1)';
    x0.beginPath();x0.arc(eel.x+(eel.vx>0?5:-5),eel.y-1,3*(1+beat*0.3),0,Math.PI*2);x0.fill();
    x0.lineCap='butt';x0.shadowBlur=0;x0.restore();
  }

  // Anglerfish — lurk mid-water with glowing lure
  for(const af of A.anglerfish){
    af.ph+=0.02*(1+beat*0.3);af.mouthPh+=0.04;af.lurePh+=0.05+Math.random()*0.02;
    af.x+=af.vx*(1+energy*0.15);
    if(af.x<-80)af.x=w+80;if(af.x>w+80)af.x=-80;
    const dir=af.vx>0?1:-1;
    x0.save();x0.translate(af.x,af.y+Math.sin(af.ph)*8);
    x0.scale(dir,1);x0.shadowBlur=16;x0.shadowColor=rgba(pc(af.ci),0.7);
    // Body — bulbous
    x0.fillStyle=rgba(pc(af.ci),0.5);
    x0.beginPath();x0.ellipse(0,0,af.sz,af.sz*0.65,0,0,Math.PI*2);x0.fill();
    // Mouth — hinged open slightly
    const mA=0.2+Math.sin(af.mouthPh)*0.12;
    x0.fillStyle=rgba(pc(af.ci),0.7);
    x0.beginPath();x0.moveTo(af.sz*0.85,0);
    x0.lineTo(af.sz*0.4,-mA*af.sz*0.6);x0.lineTo(af.sz*0.4,mA*af.sz*0.6);x0.closePath();x0.fill();
    // Jagged teeth
    x0.strokeStyle='rgba(220,220,180,0.8)';x0.lineWidth=1.5;
    for(let tk=0;tk<4;tk++){
      const tx=af.sz*(0.5+tk*0.09),ty=mA*af.sz*(0.15+tk*0.1);
      x0.beginPath();x0.moveTo(tx,-ty);x0.lineTo(tx+4,-ty-8*(1-tk*0.1));x0.moveTo(tx,ty);x0.lineTo(tx+4,ty+6*(1-tk*0.1));x0.stroke();
    }
    // Eye
    x0.fillStyle='rgba(255,200,50,0.9)';x0.shadowBlur=12;x0.shadowColor='rgba(255,200,0,1)';
    x0.beginPath();x0.arc(af.sz*0.25,-af.sz*0.2,af.sz*0.15*(1+beat*0.15),0,Math.PI*2);x0.fill();
    x0.fillStyle='rgba(0,0,0,0.8)';x0.shadowBlur=0;
    x0.beginPath();x0.arc(af.sz*0.27,-af.sz*0.2,af.sz*0.07,0,Math.PI*2);x0.fill();
    // Bioluminescent lure on rod above head
    const lureRodX=-af.sz*0.2,lureRodY=-af.sz*0.75;
    const lureX=lureRodX+Math.sin(af.lurePh)*12,lureY=lureRodY+Math.cos(af.lurePh*0.7)*8;
    x0.strokeStyle=rgba(pc((af.ci+1)%4),0.5);x0.lineWidth=1.5;
    x0.beginPath();x0.moveTo(-af.sz*0.1,-af.sz*0.5);x0.lineTo(lureX,lureY);x0.stroke();
    x0.fillStyle=rgba(pc((af.ci+1)%4),0.95);x0.shadowBlur=20+Math.sin(af.lurePh)*8;x0.shadowColor=pc((af.ci+1)%4);
    x0.beginPath();x0.arc(lureX,lureY,4+beat*3,0,Math.PI*2);x0.fill();
    x0.shadowBlur=0;x0.restore();
  }

  // Manta rays — glide overhead in upper water
  for(const mr of A.mantas){
    mr.ph+=0.008*(1+beat*0.2);mr.waveAmp+=(beat*0.15-mr.waveAmp)*0.1;
    mr.x+=mr.vx*(1+energy*0.2);
    if(mr.x<-mr.sz*2)mr.x=w+mr.sz*2;if(mr.x>w+mr.sz*2)mr.x=-mr.sz*2;
    const dir=mr.vx>0?1:-1;
    const wingFlap=Math.sin(mr.ph)*mr.sz*(0.12+mr.waveAmp*0.25);
    x0.save();x0.translate(mr.x,mr.y+Math.sin(mr.ph*0.4)*12);x0.scale(dir,1);
    x0.shadowBlur=20;x0.shadowColor=rgba(pc(mr.ci),0.5);
    // Main body — diamond shape
    x0.fillStyle=rgba(pc(mr.ci),0.35);
    x0.beginPath();
    x0.moveTo(0,-mr.sz*0.12);                    // nose
    x0.bezierCurveTo(mr.sz*0.3,-mr.sz*0.08,mr.sz*0.55,wingFlap*0.5,mr.sz*0.6,wingFlap);
    x0.bezierCurveTo(mr.sz*0.3,wingFlap*0.8,0,mr.sz*0.15,0,mr.sz*0.15);
    x0.bezierCurveTo(0,mr.sz*0.15,-mr.sz*0.3,wingFlap*0.8,-mr.sz*0.6,wingFlap);
    x0.bezierCurveTo(-mr.sz*0.55,wingFlap*0.5,-mr.sz*0.3,-mr.sz*0.08,0,-mr.sz*0.12);
    x0.closePath();x0.fill();
    // Wing outline glow
    x0.strokeStyle=rgba(pc(mr.ci),0.6);x0.lineWidth=1.5;x0.stroke();
    // Belly dots pattern
    x0.fillStyle=rgba(pc((mr.ci+2)%4),0.25);
    for(let dp=0;dp<5;dp++){x0.beginPath();x0.arc((dp-2)*mr.sz*0.08,mr.sz*0.04,mr.sz*0.03,0,Math.PI*2);x0.fill();}
    // Tail
    x0.strokeStyle=rgba(pc(mr.ci),0.45);x0.lineWidth=3;
    x0.beginPath();x0.moveTo(-mr.sz*0.08,mr.sz*0.12);x0.bezierCurveTo(-mr.sz*0.1,mr.sz*0.3,-mr.sz*0.05,mr.sz*0.45,mr.sz*0.05,mr.sz*0.55);x0.stroke();
    x0.shadowBlur=0;x0.restore();
  }

  // ── Bubbles ───────────────────────────────────────────
  for(const b of A.bubbles){
    b.y+=b.vy*(A.bubbleStorm?4:1);b.x+=b.vx+Math.sin(b.ph+t*0.001)*0.3;b.ph+=0.03;
    if(b.y<-10){b.y=h+10;b.x=Math.random()*w;}
    if(A.bubbleStorm){
      // Big glowing neon bubbles during storm
      x0.shadowBlur=15;x0.shadowColor=rgba(pc(b.ci),0.8);
      x0.strokeStyle=rgba(pc(b.ci),0.85);x0.lineWidth=2;
      x0.beginPath();x0.arc(b.x,b.y,b.r*2.5*(1+beat*0.2),0,Math.PI*2);x0.stroke();
      // Inner highlight
      x0.fillStyle=rgba(pc(b.ci),0.15);x0.fill();
      x0.shadowBlur=0;
    } else {
      x0.strokeStyle=rgba(pc(b.ci),0.3+beat*0.1);x0.lineWidth=1;
      x0.beginPath();x0.arc(b.x,b.y,b.r,0,Math.PI*2);x0.stroke();
      x0.fillStyle=rgba(pc(b.ci),0.05);x0.fill();
    }
  }
}
function drawCarnival(t){
  const w=W(),h=H(),cx=w/2,cy=h/2;
  x0.fillStyle=THEME.bgColor;x0.fillRect(0,0,w,h);
  x0.fillStyle=rgba(pc(0),0.12);x0.beginPath();x0.moveTo(cx,h*0.05);x0.lineTo(w*0.05,h*0.5);x0.lineTo(w*0.95,h*0.5);x0.closePath();x0.fill();
  if(SD.tentLights)for(const tl of SD.tentLights){tl.ph+=0.04;const lx=cx+Math.cos(tl.angle)*w*0.4,ly=cy*0.8+Math.sin(tl.angle)*h*0.25,br=Math.sin(tl.ph)*0.5+0.5;x0.beginPath();x0.arc(lx,ly,4*(1+SM.beatPulse*0.5),0,Math.PI*2);x0.fillStyle=rgba(pc(tl.ci),0.6+br*0.4);x0.shadowBlur=10;x0.shadowColor=pc(tl.ci);x0.fill();x0.shadowBlur=0;}
  SD.ferrisRot=(SD.ferrisRot||0)+0.008+SM.energy*0.005+SM.beatPulse*0.02;
  const ferrisR=Math.min(w,h)*(0.28+SM.beatPulse*0.01); // BIGGER wheel
  const ferrisCX=cx,ferrisCY=h*0.42;
  x0.save();x0.translate(ferrisCX,ferrisCY);x0.rotate(SD.ferrisRot);x0.strokeStyle=rgba(pc(0),0.5);x0.lineWidth=4;x0.shadowBlur=10;x0.shadowColor=pc(0);x0.beginPath();x0.arc(0,0,ferrisR,0,Math.PI*2);x0.stroke();
  // Inner ring
  x0.beginPath();x0.arc(0,0,ferrisR*0.3,0,Math.PI*2);x0.strokeStyle=rgba(pc(1),0.4);x0.lineWidth=3;x0.stroke();
  for(let s=0;s<12;s++){const a=s/12*Math.PI*2;x0.beginPath();x0.moveTo(0,0);x0.lineTo(Math.cos(a)*ferrisR,Math.sin(a)*ferrisR);x0.strokeStyle=rgba(pc(s%4),0.3);x0.lineWidth=2;x0.stroke();}
  x0.shadowBlur=0;x0.restore();
  // Gondolas as centerpiece symbols — mini versions at each spoke tip
  if(THEME.centerpiece){
    // INTEGRATED: 12 mini centerpieces as ferris gondolas on x0
    cpRot+=0.015; cpPh+=0.013;
    const gs=Math.min(w,h)*(0.025+SM.beatPulse*0.007);
    for(let s=0;s<12;s++){
      const a=s/12*Math.PI*2+SD.ferrisRot;
      const gx=ferrisCX+Math.cos(a)*ferrisR, gy=ferrisCY+Math.sin(a)*ferrisR;
      x0.globalAlpha=0.8+SM.beatPulse*0.15;
      drawCPMini(x0,THEME.centerpiece,gx,gy,gs,-SD.ferrisRot+cpRot);
    }
    x0.globalAlpha=1;
  }
  if(SD.confetti)for(const c of SD.confetti){c.x+=c.vx;c.y+=c.vy*(1+SM.energy*0.2);c.rot+=c.rotS;if(c.y>h+10){c.y=-10;c.x=Math.random()*w;}x0.save();x0.translate(c.x,c.y);x0.rotate(c.rot);x0.fillStyle=rgba(pc(c.ci),0.7);x0.fillRect(-c.sz/2,-c.sz*0.3,c.sz,c.sz*0.6);x0.restore();}
}
function drawEgyptianTomb(t){
  const w=W(),h=H(),cx=w/2,cy=h/2;
  x0.fillStyle=THEME.bgColor;x0.fillRect(0,0,w,h);
  SD.tunnelZ=(SD.tunnelZ||0)+THEME.sceneSpeed*0.01*(1+SM.energy*0.4)*progMult;
  for(let d=8;d>0;d--){const z=((d/8+SD.tunnelZ)%1),cw=lerp(w*0.5,0,z),ch2=lerp(h*0.5,0,z),alpha=(0.1+z*0.5)*THEME.sceneIntensity;x0.strokeStyle=rgba(pc(d%4),alpha);x0.lineWidth=1+z*2;x0.shadowBlur=z>0.6?10:0;x0.shadowColor=pc(d%4);x0.strokeRect(cx-cw,cy-ch2,cw*2,ch2*2);x0.shadowBlur=0;}
  const hChars=['𓀀','𓂀','𓃭','𓄿','𓇋','𓈖','𓊖','𓌃','𓎛','𓏏','𓐍','𓇼'];
  if(SD.hieroglyphs)for(const hg of SD.hieroglyphs){x0.font='18px serif';x0.fillStyle=rgba(pc(hg.ci),hg.alpha*(0.8+SM.beatPulse*0.2));x0.fillText(hChars[hg.char%hChars.length],hg.x,hg.y);}
  if(SD.torches)for(const tr of SD.torches){tr.ph+=0.08;const fx=Math.sin(tr.ph)*4,tx=tr.x*w;x0.fillStyle='rgba(100,60,20,0.8)';x0.fillRect(tx-4,h*0.55,8,40);const fg=x0.createRadialGradient(tx+fx,h*0.53,0,tx+fx,h*0.53,28);fg.addColorStop(0,'rgba(255,200,50,0.9)');fg.addColorStop(0.4,rgba(pc(0),0.6));fg.addColorStop(1,'transparent');x0.fillStyle=fg;x0.beginPath();x0.arc(tx+fx,h*0.53,24,0,Math.PI*2);x0.fill();}
  if(SD.traps)for(let i=SD.traps.length-1;i>=0;i--){const tr=SD.traps[i];tr.y+=tr.vy;tr.life-=0.02;if(tr.y>h||tr.life<=0){SD.traps.splice(i,1);continue;}x0.fillStyle=rgba(pc(tr.ci),tr.life*0.8);x0.beginPath();x0.moveTo(tr.x,tr.y);x0.lineTo(tr.x-10,tr.y-30);x0.lineTo(tr.x+10,tr.y-30);x0.closePath();x0.fill();}
  // Centerpiece stamped as repeating symbol on corridor walls
  if(THEME.centerpiece){
    // INTEGRATED: centerpiece stamped on corridor walls at each depth
    cpRot+=0.003; cpPh+=0.013;
    const stampAlpha=(0.08+songProg*0.12+SM.beatPulse*0.06);
    for(let row=0;row<4;row++){
      const depth=row/4, xOff=w*depth*0.38;
      const stampSz=Math.min(w,h)*0.07*(1-depth*0.45)*(0.7+SM.beatPulse*0.2);
      for(let side=0;side<2;side++){
        const sx=side===0?xOff+w*0.05:w-xOff-w*0.05;
        const sy=h*0.5+Math.sin(row+SD.tunnelZ*3)*h*0.04;
        x0.globalAlpha=stampAlpha*(1-depth*0.4);
        drawCPMini(x0,THEME.centerpiece,sx,sy,stampSz,cpRot+(row+side)*0.6);
      }
    }
    x0.globalAlpha=1;
  }
}

// ═══════════════════════════════════════════════════════
// CENTERPIECE SYSTEM v2 — COMPLETE REBUILD
// ═══════════════════════════════════════════════════════
// Architecture:
//   1. drawCP(ctx, name, sz, t) — draws any centerpiece at (0,0), size sz
//   2. Each scene renderer calls drawCPInScene(x0, t) to integrate
//   3. Render loop calls drawCPInScene — NO separate x1 layer for integrated scenes
//   4. x1 layer ONLY used for scenes that don't integrate (floating mode)
// ═══════════════════════════════════════════════════════

// CP_INTEGRATED_SCENES defined above in variety system

// ── Core draw function ──────────────────────────────────
function drawCP(ctx, name, sz, t) {
  const e = SM.energy, bp = SM.beatPulse, ph = cpPh;
  ctx.save();
  ctx.shadowBlur = 0;

  switch(name) {

    // ── SKULL ──────────────────────────────────────────
    case 'skull': {
      const jawDrop = bp * sz * 0.18;
      ctx.shadowBlur = sz * 0.4; ctx.shadowColor = pc(0);
      // Cranium
      ctx.fillStyle = rgba(pc(0), 0.92);
      ctx.beginPath();
      ctx.arc(0, -sz*0.1, sz*0.52, Math.PI, 0);
      ctx.bezierCurveTo(sz*0.52, sz*0.25, sz*0.38, sz*0.38, sz*0.28, sz*0.38);
      ctx.lineTo(-sz*0.28, sz*0.38);
      ctx.bezierCurveTo(-sz*0.38, sz*0.38, -sz*0.52, sz*0.25, -sz*0.52, -sz*0.1);
      ctx.fill();
      // Eye sockets
      ctx.fillStyle = 'rgba(0,0,0,0.92)';
      ctx.beginPath(); ctx.ellipse(-sz*0.2, -sz*0.1, sz*0.155, sz*0.17, -0.15, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(sz*0.2, -sz*0.1, sz*0.155, sz*0.17, 0.15, 0, Math.PI*2); ctx.fill();
      // Eye glow on beat
      if (bp > 0.3) {
        ctx.fillStyle = rgba(pc(1), bp * 0.8);
        ctx.shadowBlur = sz*0.3; ctx.shadowColor = pc(1);
        ctx.beginPath(); ctx.ellipse(-sz*0.2, -sz*0.1, sz*0.08, sz*0.09, 0, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(sz*0.2, -sz*0.1, sz*0.08, sz*0.09, 0, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
      }
      // Nose cavity
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.beginPath(); ctx.moveTo(0, sz*0.08); ctx.lineTo(-sz*0.08, sz*0.22); ctx.lineTo(sz*0.08, sz*0.22); ctx.closePath(); ctx.fill();
      // Upper jaw
      ctx.fillStyle = rgba(pc(0), 0.85);
      ctx.fillRect(-sz*0.28, sz*0.28, sz*0.56, sz*0.12);
      // Lower jaw — drops on beat
      ctx.fillStyle = rgba(pc(0), 0.8);
      ctx.fillRect(-sz*0.24, sz*0.38 + jawDrop, sz*0.48, sz*0.1);
      // Teeth
      ctx.fillStyle = 'rgba(230,230,220,0.9)';
      for (let i=0; i<6; i++) {
        ctx.fillRect(-sz*0.24 + i*sz*0.08, sz*0.28, sz*0.06, sz*0.12);
        ctx.fillRect(-sz*0.21 + i*sz*0.08, sz*0.38 + jawDrop, sz*0.06, sz*0.1);
      }
      break;
    }

    // ── FLAMING_SKULL ──────────────────────────────────
    case 'flaming_skull': {
      // Flames first (behind skull)
      ctx.shadowBlur = sz * 0.5; ctx.shadowColor = pc(0);
      for (let f=0; f<10; f++) {
        const fa = (f/10 - 0.5) * Math.PI * 0.9;
        const fh = sz * (0.6 + Math.sin(ph*4 + f*0.7) * 0.25 + bp*0.3);
        const fx = Math.sin(fa) * sz * 0.35;
        const fy = -sz * 0.38;
        ctx.beginPath();
        ctx.moveTo(fx - sz*0.06, fy);
        ctx.bezierCurveTo(fx - sz*0.04, fy - fh*0.4, fx + sz*0.08, fy - fh*0.6, fx, fy - fh);
        ctx.bezierCurveTo(fx - sz*0.1, fy - fh*0.6, fx + sz*0.04, fy - fh*0.3, fx + sz*0.06, fy);
        ctx.closePath();
        const fg = ctx.createLinearGradient(fx, fy, fx, fy - fh);
        fg.addColorStop(0, 'rgba(255,180,0,0.85)');
        fg.addColorStop(0.4, rgba(pc(0), 0.7));
        fg.addColorStop(1, 'rgba(255,50,0,0)');
        ctx.fillStyle = fg;
        ctx.fill();
      }
      ctx.shadowBlur = 0;
      // Draw skull on top
      drawCP(ctx, 'skull', sz, t);
      break;
    }

    // ── FLAME ──────────────────────────────────────────
    case 'flame': {
      ctx.shadowBlur = sz*0.5; ctx.shadowColor = rgba(pc(0), 0.8);
      for (let layer=0; layer<5; layer++) {
        const li = 1 - layer/5;
        const lsz = sz * (0.3 + layer * 0.16);
        const flicker = Math.sin(ph*5 + layer*1.3) * lsz * 0.12 + bp*lsz*0.15;
        ctx.beginPath();
        ctx.moveTo(0, sz*0.5);
        ctx.bezierCurveTo(-lsz*0.7, sz*0.1, -lsz*0.5 + flicker, -sz*0.2, 0, -sz*0.5 - flicker*0.5);
        ctx.bezierCurveTo(lsz*0.5 - flicker, -sz*0.2, lsz*0.7, sz*0.1, 0, sz*0.5);
        ctx.closePath();
        const colors = ['rgba(255,240,180,0.95)','rgba(255,180,0,0.85)','rgba(255,80,0,0.75)',rgba(pc(0),0.65),'rgba(180,0,80,0.4)'];
        ctx.fillStyle = colors[layer] || rgba(pc(layer%4), 0.5);
        ctx.fill();
      }
      ctx.shadowBlur = 0;
      break;
    }

    // ── DRAGON ──────────────────────────────────────────
    case 'dragon': case 'dragon_head': {
      ctx.shadowBlur = sz*0.35; ctx.shadowColor = pc(0);
      // Body / neck
      ctx.fillStyle = rgba(pc(0), 0.88);
      ctx.beginPath();
      ctx.moveTo(-sz*0.8, sz*0.2);
      ctx.bezierCurveTo(-sz*0.4, sz*0.1, sz*0.1, sz*0.25, sz*0.4, sz*0.05);
      ctx.bezierCurveTo(sz*0.6, -sz*0.05, sz*0.55, -sz*0.2, sz*0.3, -sz*0.15);
      ctx.bezierCurveTo(sz*0.1, sz*0.05, -sz*0.3, sz*0.0, -sz*0.5, sz*0.18);
      ctx.closePath(); ctx.fill();
      // Wing
      ctx.beginPath();
      ctx.moveTo(-sz*0.15, -sz*0.05);
      ctx.bezierCurveTo(-sz*0.35, -sz*0.55, -sz*0.7, -sz*0.8, -sz*0.85, -sz*0.55);
      ctx.bezierCurveTo(-sz*0.95, -sz*0.3, -sz*0.7, -sz*0.1, -sz*0.5, sz*0.0);
      ctx.closePath();
      ctx.fillStyle = rgba(pc(1), 0.65); ctx.fill();
      ctx.strokeStyle = rgba(pc(0), 0.8); ctx.lineWidth = sz*0.02; ctx.stroke();
      // Head
      ctx.fillStyle = rgba(pc(0), 0.92);
      ctx.beginPath();
      ctx.ellipse(sz*0.55, -sz*0.1, sz*0.38, sz*0.22, -0.2, 0, Math.PI*2);
      ctx.fill();
      // Snout/jaw
      ctx.beginPath();
      ctx.moveTo(sz*0.3, sz*0.04);
      ctx.lineTo(sz*0.95, sz*0.0 + bp*sz*0.1);
      ctx.lineTo(sz*0.95, sz*0.12 + bp*sz*0.1);
      ctx.lineTo(sz*0.3, sz*0.12);
      ctx.closePath(); ctx.fill();
      // Horn
      ctx.beginPath();
      ctx.moveTo(sz*0.45, -sz*0.28); ctx.lineTo(sz*0.55, -sz*0.55); ctx.lineTo(sz*0.62, -sz*0.28);
      ctx.closePath(); ctx.fillStyle = rgba(pc(2), 0.85); ctx.fill();
      // Eye
      ctx.fillStyle = rgba(pc(1), 0.95);
      ctx.shadowBlur = 10; ctx.shadowColor = pc(1);
      ctx.beginPath(); ctx.ellipse(sz*0.62, -sz*0.12, sz*0.07, sz*0.06, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = 'rgba(0,0,0,0.9)';
      ctx.beginPath(); ctx.arc(sz*0.64, -sz*0.12, sz*0.035, 0, Math.PI*2); ctx.fill();
      // Fire breath on beat
      if (bp > 0.5) {
        for (let f=0; f<5; f++) {
          const fl = sz*(0.4 + f*0.2 + bp*0.3);
          const ffy = (Math.random()-0.5) * sz * 0.12;
          const ffg = ctx.createLinearGradient(sz*0.95, 0, sz*0.95 + fl, 0);
          ffg.addColorStop(0,'rgba(255,240,0,0.9)');
          ffg.addColorStop(0.4,'rgba(255,100,0,0.7)');
          ffg.addColorStop(1,'transparent');
          ctx.fillStyle = ffg; ctx.shadowBlur = 15; ctx.shadowColor = 'rgba(255,150,0,1)';
          ctx.beginPath();
          ctx.ellipse(sz*0.95 + fl*0.5, ffy, fl*0.5, sz*(0.04 + f*0.015), 0, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.shadowBlur = 0;
      }
      break;
    }

    // ── WOLF_HEAD ──────────────────────────────────────
    case 'wolf_head': {
      ctx.shadowBlur = sz*0.3; ctx.shadowColor = pc(0);
      const howl = bp * sz * 0.15; // stretches up on beat
      // Ears
      ctx.fillStyle = rgba(pc(0), 0.85);
      ctx.beginPath(); ctx.moveTo(-sz*0.35, -sz*0.3 - howl); ctx.lineTo(-sz*0.55, -sz*0.75 - howl); ctx.lineTo(-sz*0.1, -sz*0.4 - howl); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(sz*0.35, -sz*0.3 - howl); ctx.lineTo(sz*0.55, -sz*0.75 - howl); ctx.lineTo(sz*0.1, -sz*0.4 - howl); ctx.closePath(); ctx.fill();
      // Inner ear
      ctx.fillStyle = rgba(pc(2), 0.5);
      ctx.beginPath(); ctx.moveTo(-sz*0.32, -sz*0.32 - howl); ctx.lineTo(-sz*0.48, -sz*0.65 - howl); ctx.lineTo(-sz*0.16, -sz*0.4 - howl); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(sz*0.32, -sz*0.32 - howl); ctx.lineTo(sz*0.48, -sz*0.65 - howl); ctx.lineTo(sz*0.16, -sz*0.4 - howl); ctx.closePath(); ctx.fill();
      // Head
      ctx.fillStyle = rgba(pc(0), 0.88);
      ctx.beginPath(); ctx.ellipse(0, -sz*0.05 - howl*0.3, sz*0.42, sz*0.45, 0, 0, Math.PI*2); ctx.fill();
      // Snout
      ctx.beginPath(); ctx.ellipse(0, sz*0.22, sz*0.28, sz*0.2, 0, 0, Math.PI*2); ctx.fill();
      // Eyes
      ctx.fillStyle = rgba(pc(1), 0.9); ctx.shadowBlur = 12; ctx.shadowColor = pc(1);
      ctx.beginPath(); ctx.ellipse(-sz*0.18, -sz*0.08 - howl*0.2, sz*0.09, sz*0.07, -0.2, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(sz*0.18, -sz*0.08 - howl*0.2, sz*0.09, sz*0.07, 0.2, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = 'rgba(0,0,0,0.9)'; ctx.shadowBlur = 0;
      ctx.beginPath(); ctx.arc(-sz*0.17, -sz*0.08 - howl*0.2, sz*0.04, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(sz*0.17, -sz*0.08 - howl*0.2, sz*0.04, 0, Math.PI*2); ctx.fill();
      // Nose
      ctx.fillStyle = 'rgba(20,20,20,0.9)';
      ctx.beginPath(); ctx.ellipse(0, sz*0.14, sz*0.1, sz*0.07, 0, 0, Math.PI*2); ctx.fill();
      // Teeth
      ctx.fillStyle = 'rgba(240,235,220,0.9)';
      for (let t2=0; t2<4; t2++) {
        ctx.beginPath(); ctx.moveTo(-sz*0.18 + t2*sz*0.12, sz*0.28); ctx.lineTo(-sz*0.14 + t2*sz*0.12, sz*0.42); ctx.lineTo(-sz*0.1 + t2*sz*0.12, sz*0.28); ctx.closePath(); ctx.fill();
      }
      break;
    }

    // ── EAGLE ──────────────────────────────────────────
    case 'eagle': {
      ctx.shadowBlur = sz*0.25; ctx.shadowColor = pc(0);
      const wingFlap = Math.sin(ph*3) * sz * 0.08 * (1 + bp*0.5);
      // Wings
      for (let side=0; side<2; side++) {
        const sx2 = side===0 ? -1 : 1;
        ctx.save(); ctx.scale(sx2, 1);
        ctx.fillStyle = rgba(pc(0), 0.85);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(sz*0.3, -sz*0.1 - wingFlap, sz*0.8, -sz*0.3 - wingFlap, sz*1.1, -sz*0.15 - wingFlap);
        ctx.bezierCurveTo(sz*0.9, sz*0.0, sz*0.5, sz*0.1, sz*0.15, sz*0.1);
        ctx.closePath(); ctx.fill();
        // Wing feather tips
        ctx.strokeStyle = rgba(pc(1), 0.4); ctx.lineWidth = sz*0.015;
        for (let f=0; f<5; f++) {
          const fx = sz*(0.7 + f*0.08);
          const fy = -sz*(0.2 + f*0.02) - wingFlap;
          ctx.beginPath(); ctx.moveTo(fx, fy); ctx.lineTo(fx + sz*0.15, fy - sz*0.1); ctx.stroke();
        }
        ctx.restore();
      }
      // Body
      ctx.fillStyle = rgba(pc(0), 0.9);
      ctx.beginPath(); ctx.ellipse(0, sz*0.05, sz*0.18, sz*0.38, 0, 0, Math.PI*2); ctx.fill();
      // White head
      ctx.fillStyle = 'rgba(240,240,240,0.95)';
      ctx.beginPath(); ctx.arc(0, -sz*0.28, sz*0.2, 0, Math.PI*2); ctx.fill();
      // Beak
      ctx.fillStyle = 'rgba(255,200,0,0.95)';
      ctx.beginPath(); ctx.moveTo(sz*0.08, -sz*0.25); ctx.lineTo(sz*0.35, -sz*0.28); ctx.lineTo(sz*0.08, -sz*0.32); ctx.closePath(); ctx.fill();
      // Eye
      ctx.fillStyle = 'rgba(0,0,0,0.9)';
      ctx.beginPath(); ctx.arc(sz*0.08, -sz*0.3, sz*0.04, 0, Math.PI*2); ctx.fill();
      break;
    }

    // ── SMILEY ──────────────────────────────────────────
    case 'smiley': {
      // Expression changes with energy: smile → grin → shock
      const expr = e; // 0=calm smile, 1=manic shock
      ctx.shadowBlur = sz*0.3; ctx.shadowColor = pc(1);
      // Face
      ctx.fillStyle = rgba(pc(1), 0.9);
      ctx.beginPath(); ctx.arc(0, 0, sz, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = rgba(pc(0), 0.8); ctx.lineWidth = sz*0.05; ctx.stroke();
      ctx.shadowBlur = 0;
      // Eyes
      const eyeOpenness = 0.5 + expr*0.5 + bp*0.3;
      ctx.fillStyle = 'rgba(0,0,0,0.9)';
      ctx.beginPath(); ctx.ellipse(-sz*0.3, -sz*0.15, sz*0.12, sz*0.12*eyeOpenness, 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(sz*0.3, -sz*0.15, sz*0.12, sz*0.12*eyeOpenness, 0, 0, Math.PI*2); ctx.fill();
      // Shine dots
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.beginPath(); ctx.arc(-sz*0.24, -sz*0.2, sz*0.04, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(sz*0.36, -sz*0.2, sz*0.04, 0, Math.PI*2); ctx.fill();
      // Mouth — morphs from smile to O-shock
      ctx.strokeStyle = 'rgba(0,0,0,0.9)'; ctx.lineWidth = sz*0.07; ctx.lineCap = 'round';
      if (expr < 0.5) {
        // Smile
        ctx.beginPath(); ctx.arc(0, sz*0.05, sz*0.45, 0.2, Math.PI-0.2); ctx.stroke();
      } else {
        // Shock O
        const mw = sz*(0.2 + expr*0.25);
        const mh = sz*(0.15 + expr*0.3 + bp*0.15);
        ctx.beginPath(); ctx.ellipse(0, sz*0.3, mw, mh, 0, 0, Math.PI*2); ctx.stroke();
      }
      ctx.lineCap = 'butt';
      break;
    }

    // ── DEMON_FACE ──────────────────────────────────────
    case 'demon_face': {
      ctx.shadowBlur = sz*0.4; ctx.shadowColor = pc(0);
      // Face
      ctx.fillStyle = rgba(pc(0), 0.88);
      ctx.beginPath(); ctx.ellipse(0, 0, sz*0.65, sz*0.75, 0, 0, Math.PI*2); ctx.fill();
      // Horns
      ctx.fillStyle = rgba(pc(0), 0.92);
      ctx.beginPath(); ctx.moveTo(-sz*0.3, -sz*0.55); ctx.lineTo(-sz*0.55, -sz*1.05); ctx.lineTo(-sz*0.15, -sz*0.6); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(sz*0.3, -sz*0.55); ctx.lineTo(sz*0.55, -sz*1.05); ctx.lineTo(sz*0.15, -sz*0.6); ctx.closePath(); ctx.fill();
      // Angry brows
      ctx.strokeStyle = 'rgba(0,0,0,0.9)'; ctx.lineWidth = sz*0.09; ctx.lineCap = 'round';
      ctx.beginPath(); ctx.moveTo(-sz*0.55, -sz*0.15); ctx.lineTo(-sz*0.1, sz*0.0); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(sz*0.55, -sz*0.15); ctx.lineTo(sz*0.1, sz*0.0); ctx.stroke();
      // Eyes — glowing
      ctx.fillStyle = rgba(pc(1), 0.95); ctx.shadowBlur = sz*0.3; ctx.shadowColor = pc(1);
      ctx.beginPath(); ctx.ellipse(-sz*0.28, -sz*0.02, sz*0.14, sz*0.12 + bp*sz*0.04, 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(sz*0.28, -sz*0.02, sz*0.14, sz*0.12 + bp*sz*0.04, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = 'rgba(0,0,0,0.9)'; ctx.shadowBlur = 0;
      ctx.beginPath(); ctx.arc(-sz*0.28, -sz*0.02, sz*0.07, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(sz*0.28, -sz*0.02, sz*0.07, 0, Math.PI*2); ctx.fill();
      // Fangs
      ctx.fillStyle = 'rgba(240,235,220,0.95)';
      ctx.beginPath(); ctx.moveTo(-sz*0.2, sz*0.35); ctx.lineTo(-sz*0.25, sz*0.65); ctx.lineTo(-sz*0.1, sz*0.35); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(sz*0.2, sz*0.35); ctx.lineTo(sz*0.25, sz*0.65); ctx.lineTo(sz*0.1, sz*0.35); ctx.closePath(); ctx.fill();
      // Mouth
      ctx.strokeStyle = 'rgba(0,0,0,0.7)'; ctx.lineWidth = sz*0.06;
      ctx.beginPath(); ctx.arc(0, sz*0.2, sz*0.4, 0.1, Math.PI-0.1); ctx.stroke();
      break;
    }

    // ── ALIEN_HEAD ──────────────────────────────────────
    case 'alien_head': {
      ctx.shadowBlur = sz*0.3; ctx.shadowColor = pc(2);
      // Large cranium
      ctx.fillStyle = rgba(pc(2), 0.82);
      ctx.beginPath(); ctx.ellipse(0, -sz*0.15, sz*0.55, sz*0.65, 0, 0, Math.PI*2); ctx.fill();
      // Narrow chin
      ctx.beginPath(); ctx.ellipse(0, sz*0.45, sz*0.22, sz*0.28, 0, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
      // Huge almond eyes
      ctx.fillStyle = 'rgba(0,0,0,0.95)';
      ctx.beginPath(); ctx.ellipse(-sz*0.22, -sz*0.08, sz*0.24, sz*0.14, -0.4, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(sz*0.22, -sz*0.08, sz*0.24, sz*0.14, 0.4, 0, Math.PI*2); ctx.fill();
      // Inner eye glow
      ctx.fillStyle = rgba(pc(1), 0.7 + bp*0.3); ctx.shadowBlur = 15; ctx.shadowColor = pc(1);
      ctx.beginPath(); ctx.ellipse(-sz*0.22, -sz*0.08, sz*0.1, sz*0.06, -0.4, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(sz*0.22, -sz*0.08, sz*0.1, sz*0.06, 0.4, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
      // Tiny nostril slits
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(-sz*0.06, sz*0.2, sz*0.04, sz*0.08);
      ctx.fillRect(sz*0.02, sz*0.2, sz*0.04, sz*0.08);
      // Thin line mouth
      ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.lineWidth = sz*0.04;
      ctx.beginPath(); ctx.moveTo(-sz*0.15, sz*0.42); ctx.quadraticCurveTo(0, sz*0.38, sz*0.15, sz*0.42); ctx.stroke();
      break;
    }

    // ── ROBOT_HEAD ──────────────────────────────────────
    case 'robot_head': {
      ctx.shadowBlur = sz*0.2; ctx.shadowColor = pc(0);
      // Main box head
      ctx.fillStyle = rgba(pc(0), 0.88);
      ctx.strokeStyle = rgba(pc(1), 0.6); ctx.lineWidth = sz*0.03;
      const rx=-sz*0.55, ry=-sz*0.62, rw=sz*1.1, rh=sz*1.1;
      ctx.beginPath(); ctx.roundRect(rx, ry, rw, rh, sz*0.08); ctx.fill(); ctx.stroke();
      // Antenna
      ctx.strokeStyle = rgba(pc(1), 0.8); ctx.lineWidth = sz*0.04;
      ctx.beginPath(); ctx.moveTo(0, ry); ctx.lineTo(0, ry-sz*0.3); ctx.stroke();
      ctx.fillStyle = rgba(pc(1), 0.9); ctx.shadowBlur = 10; ctx.shadowColor = pc(1);
      ctx.beginPath(); ctx.arc(0, ry-sz*0.35, sz*0.07, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
      // Visor screen
      const visorColor = `hsl(${(ph*60)%360},90%,${50+bp*30}%)`;
      ctx.fillStyle = visorColor;
      ctx.shadowBlur = 15+bp*20; ctx.shadowColor = visorColor;
      ctx.beginPath(); ctx.roundRect(-sz*0.42, -sz*0.45, sz*0.84, sz*0.38, sz*0.05); ctx.fill();
      ctx.shadowBlur = 0;
      // Scanline on visor
      ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = sz*0.02;
      for (let sl=0; sl<4; sl++) {
        const sy = -sz*0.42 + sl*sz*0.11;
        ctx.beginPath(); ctx.moveTo(-sz*0.42, sy); ctx.lineTo(sz*0.42, sy); ctx.stroke();
      }
      // Ear bolts
      ctx.fillStyle = rgba(pc(0), 0.7); ctx.strokeStyle = rgba(pc(1), 0.5); ctx.lineWidth = sz*0.02;
      ctx.beginPath(); ctx.rect(rx-sz*0.12, -sz*0.2, sz*0.12, sz*0.25); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.rect(sz*0.55, -sz*0.2, sz*0.12, sz*0.25); ctx.fill(); ctx.stroke();
      // Mouth grille
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.beginPath(); ctx.roundRect(-sz*0.35, sz*0.12, sz*0.7, sz*0.22, sz*0.03); ctx.fill();
      ctx.strokeStyle = rgba(pc(1), 0.4); ctx.lineWidth = sz*0.02;
      for (let g=0; g<5; g++) {
        ctx.beginPath(); ctx.moveTo(-sz*0.28+g*sz*0.14, sz*0.14); ctx.lineTo(-sz*0.28+g*sz*0.14, sz*0.32); ctx.stroke();
      }
      break;
    }

    // ── PEACE_SIGN ──────────────────────────────────────
    case 'peace_sign': {
      ctx.shadowBlur = sz*0.3; ctx.shadowColor = pc(0);
      ctx.strokeStyle = rgba(pc(0), 0.9); ctx.lineWidth = sz*0.1; ctx.lineCap = 'round';
      // Shatter on big beat
      if (bp > 0.7) {
        // Shattered pieces flying
        ctx.globalAlpha = 1 - (bp-0.7)*2;
        for (let seg=0; seg<6; seg++) {
          const angle = seg/6*Math.PI*2;
          const drift = (bp-0.7)*sz*2;
          ctx.save();
          ctx.translate(Math.cos(angle)*drift, Math.sin(angle)*drift);
          ctx.rotate(angle*(bp-0.7)*3);
          ctx.beginPath(); ctx.arc(0, 0, sz*0.5, angle, angle+Math.PI/3); ctx.stroke();
          ctx.restore();
        }
        ctx.globalAlpha = 1;
      } else {
        // Intact peace sign
        ctx.beginPath(); ctx.arc(0, 0, sz, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, -sz); ctx.lineTo(0, sz); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-sz*0.87, sz*0.5); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(sz*0.87, sz*0.5); ctx.stroke();
      }
      ctx.lineCap = 'butt';
      break;
    }

    // ── LIGHTNING_BOLT ──────────────────────────────────
    case 'lightning_bolt': {
      ctx.shadowBlur = sz*0.5; ctx.shadowColor = rgba(pc(1), 0.9);
      // Main bolt shape
      ctx.fillStyle = rgba(pc(1), 0.95);
      ctx.beginPath();
      ctx.moveTo(sz*0.2, -sz);
      ctx.lineTo(-sz*0.12, -sz*0.05);
      ctx.lineTo(sz*0.08, -sz*0.05);
      ctx.lineTo(-sz*0.2, sz);
      ctx.lineTo(sz*0.12, sz*0.05);
      ctx.lineTo(-sz*0.08, sz*0.05);
      ctx.lineTo(sz*0.2, -sz);
      ctx.closePath(); ctx.fill();
      // Branch arcs on beat
      if (bp > 0.3) {
        ctx.strokeStyle = rgba(pc(1), bp*0.7); ctx.lineWidth = sz*0.03;
        for (let b2=0; b2<3; b2++) {
          const bx = (Math.random()-0.5)*sz*0.3;
          const by = -sz*0.5 + b2*sz*0.3;
          ctx.beginPath();
          ctx.moveTo(bx, by);
          ctx.lineTo(bx + (Math.random()-0.5)*sz*0.6, by + sz*0.2);
          ctx.stroke();
        }
      }
      ctx.shadowBlur = 0;
      break;
    }

    // ── YIN_YANG ──────────────────────────────────────
    case 'yin_yang': {
      ctx.shadowBlur = sz*0.2; ctx.shadowColor = pc(0);
      // White half
      ctx.fillStyle = 'rgba(240,240,240,0.95)';
      ctx.beginPath(); ctx.arc(0, 0, sz, -Math.PI/2, Math.PI/2); ctx.fill();
      // Black half
      ctx.fillStyle = 'rgba(10,10,10,0.95)';
      ctx.beginPath(); ctx.arc(0, 0, sz, Math.PI/2, -Math.PI/2); ctx.fill();
      // Small white circle in black half
      ctx.fillStyle = 'rgba(240,240,240,0.95)';
      ctx.beginPath(); ctx.arc(0, sz*0.5, sz*0.25, 0, Math.PI*2); ctx.fill();
      // Small black circle in white half
      ctx.fillStyle = 'rgba(10,10,10,0.95)';
      ctx.beginPath(); ctx.arc(0, -sz*0.5, sz*0.25, 0, Math.PI*2); ctx.fill();
      // Outer ring
      ctx.strokeStyle = 'rgba(100,100,100,0.5)'; ctx.lineWidth = sz*0.04;
      ctx.beginPath(); ctx.arc(0, 0, sz, 0, Math.PI*2); ctx.stroke();
      ctx.shadowBlur = 0;
      break;
    }

    // ── STAR ──────────────────────────────────────────
    case 'star': {
      ctx.shadowBlur = sz*0.4; ctx.shadowColor = pc(1);
      ctx.fillStyle = rgba(pc(1), 0.92);
      const spikes = 5;
      ctx.beginPath();
      for (let i=0; i<spikes*2; i++) {
        const a = i/spikes*Math.PI - Math.PI/2;
        const r = i%2===0 ? sz*(1 + bp*0.25) : sz*0.4;
        i===0 ? ctx.moveTo(Math.cos(a)*r, Math.sin(a)*r) : ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
      }
      ctx.closePath(); ctx.fill();
      // Inner glow
      ctx.fillStyle = rgba(pc(0), 0.6);
      ctx.beginPath();
      for (let i=0; i<spikes*2; i++) {
        const a = i/spikes*Math.PI - Math.PI/2;
        const r = i%2===0 ? sz*0.5 : sz*0.2;
        i===0 ? ctx.moveTo(Math.cos(a)*r, Math.sin(a)*r) : ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
      }
      ctx.closePath(); ctx.fill();
      ctx.shadowBlur = 0;
      break;
    }

    // ── DIAMOND ──────────────────────────────────────────
    case 'diamond': case 'crystal': {
      ctx.shadowBlur = sz*0.4; ctx.shadowColor = rgba(pc(2), 0.8);
      // Main gem facets
      const facetColors = [rgba(pc(0),0.9), rgba(pc(1),0.85), rgba(pc(2),0.9), rgba(pc(3),0.8)];
      // Top crown
      ctx.fillStyle = facetColors[0];
      ctx.beginPath(); ctx.moveTo(0, -sz); ctx.lineTo(-sz*0.4, -sz*0.2); ctx.lineTo(sz*0.4, -sz*0.2); ctx.closePath(); ctx.fill();
      ctx.fillStyle = facetColors[1];
      ctx.beginPath(); ctx.moveTo(0, -sz); ctx.lineTo(-sz*0.7, -sz*0.2); ctx.lineTo(-sz*0.4, -sz*0.2); ctx.closePath(); ctx.fill();
      ctx.fillStyle = facetColors[2];
      ctx.beginPath(); ctx.moveTo(0, -sz); ctx.lineTo(sz*0.7, -sz*0.2); ctx.lineTo(sz*0.4, -sz*0.2); ctx.closePath(); ctx.fill();
      // Girdle
      ctx.fillStyle = facetColors[3];
      ctx.beginPath(); ctx.moveTo(-sz*0.7, -sz*0.2); ctx.lineTo(-sz*0.4, -sz*0.2); ctx.lineTo(-sz*0.1, sz*0.1); ctx.lineTo(-sz*0.5, sz*0.1); ctx.closePath(); ctx.fill();
      ctx.fillStyle = facetColors[0];
      ctx.beginPath(); ctx.moveTo(-sz*0.4, -sz*0.2); ctx.lineTo(sz*0.4, -sz*0.2); ctx.lineTo(sz*0.1, sz*0.1); ctx.lineTo(-sz*0.1, sz*0.1); ctx.closePath(); ctx.fill();
      ctx.fillStyle = facetColors[1];
      ctx.beginPath(); ctx.moveTo(sz*0.4, -sz*0.2); ctx.lineTo(sz*0.7, -sz*0.2); ctx.lineTo(sz*0.5, sz*0.1); ctx.lineTo(sz*0.1, sz*0.1); ctx.closePath(); ctx.fill();
      // Pavilion (bottom)
      ctx.fillStyle = facetColors[2];
      ctx.beginPath(); ctx.moveTo(-sz*0.5, sz*0.1); ctx.lineTo(-sz*0.1, sz*0.1); ctx.lineTo(0, sz); ctx.closePath(); ctx.fill();
      ctx.fillStyle = facetColors[3];
      ctx.beginPath(); ctx.moveTo(-sz*0.1, sz*0.1); ctx.lineTo(sz*0.1, sz*0.1); ctx.lineTo(0, sz); ctx.closePath(); ctx.fill();
      ctx.fillStyle = facetColors[0];
      ctx.beginPath(); ctx.moveTo(sz*0.1, sz*0.1); ctx.lineTo(sz*0.5, sz*0.1); ctx.lineTo(0, sz); ctx.closePath(); ctx.fill();
      // Shine
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.beginPath(); ctx.moveTo(-sz*0.1, -sz*0.7); ctx.lineTo(-sz*0.3, -sz*0.3); ctx.lineTo(sz*0.0, -sz*0.5); ctx.closePath(); ctx.fill();
      ctx.shadowBlur = 0;
      break;
    }

    // ── COFFIN ──────────────────────────────────────────
    case 'coffin': {
      ctx.shadowBlur = sz*0.3; ctx.shadowColor = pc(0);
      const lidOpen = bp * sz * 0.2;
      // Body
      ctx.fillStyle = rgba(pc(0), 0.88);
      ctx.strokeStyle = rgba(pc(1), 0.5); ctx.lineWidth = sz*0.04;
      ctx.beginPath();
      ctx.moveTo(-sz*0.35, -sz*0.9);
      ctx.lineTo(-sz*0.5, -sz*0.5);
      ctx.lineTo(-sz*0.5, sz*0.5);
      ctx.lineTo(-sz*0.35, sz*0.9);
      ctx.lineTo(sz*0.35, sz*0.9);
      ctx.lineTo(sz*0.5, sz*0.5);
      ctx.lineTo(sz*0.5, -sz*0.5);
      ctx.lineTo(sz*0.35, -sz*0.9);
      ctx.closePath(); ctx.fill(); ctx.stroke();
      // Cross on front
      ctx.fillStyle = rgba(pc(1), 0.7);
      ctx.fillRect(-sz*0.06, -sz*0.5, sz*0.12, sz*0.5);
      ctx.fillRect(-sz*0.22, -sz*0.28, sz*0.44, sz*0.12);
      // Lid crack / open on beat
      if (lidOpen > 0.05) {
        ctx.strokeStyle = rgba(pc(1), 0.8); ctx.lineWidth = sz*0.05;
        ctx.beginPath();
        ctx.moveTo(-sz*0.5, -sz*0.5 - lidOpen);
        ctx.lineTo(-sz*0.35, -sz*0.9 - lidOpen);
        ctx.lineTo(sz*0.35, -sz*0.9 - lidOpen);
        ctx.lineTo(sz*0.5, -sz*0.5 - lidOpen);
        ctx.stroke();
      }
      ctx.shadowBlur = 0;
      break;
    }

    // ── ASTRONAUT ──────────────────────────────────────
    case 'astronaut': {
      ctx.shadowBlur = sz*0.2; ctx.shadowColor = pc(0);
      // Suit body
      ctx.fillStyle = 'rgba(220,220,230,0.92)';
      ctx.beginPath(); ctx.ellipse(0, sz*0.2, sz*0.52, sz*0.62, 0, 0, Math.PI*2); ctx.fill();
      // Arms
      ctx.beginPath(); ctx.ellipse(-sz*0.58, sz*0.12, sz*0.18, sz*0.38, -0.3, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(sz*0.58, sz*0.12, sz*0.18, sz*0.38, 0.3, 0, Math.PI*2); ctx.fill();
      // Helmet
      ctx.fillStyle = 'rgba(200,210,230,0.9)';
      ctx.beginPath(); ctx.arc(0, -sz*0.28, sz*0.42, 0, Math.PI*2); ctx.fill();
      // Visor
      ctx.fillStyle = rgba(pc(1), 0.7);
      ctx.shadowBlur = 10; ctx.shadowColor = pc(1);
      ctx.beginPath(); ctx.ellipse(0, -sz*0.28, sz*0.28, sz*0.22, 0, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
      // Visor reflection
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.beginPath(); ctx.ellipse(-sz*0.1, -sz*0.35, sz*0.1, sz*0.06, -0.4, 0, Math.PI*2); ctx.fill();
      // Backpack
      ctx.fillStyle = 'rgba(180,185,200,0.8)';
      ctx.fillRect(-sz*0.25, sz*0.0, sz*0.5, sz*0.28);
      // Flag / patch
      ctx.fillStyle = rgba(pc(0), 0.8);
      ctx.fillRect(-sz*0.42, -sz*0.08, sz*0.16, sz*0.1);
      break;
    }

    // ── ROCKET ──────────────────────────────────────────
    case 'rocket': {
      ctx.shadowBlur = sz*0.25; ctx.shadowColor = pc(0);
      // Body
      ctx.fillStyle = rgba(pc(0), 0.9);
      ctx.beginPath(); ctx.roundRect(-sz*0.22, -sz*0.5, sz*0.44, sz*1.1, sz*0.1); ctx.fill();
      // Nose cone
      ctx.fillStyle = rgba(pc(1), 0.9);
      ctx.beginPath(); ctx.moveTo(-sz*0.22, -sz*0.5); ctx.lineTo(0, -sz*1.0); ctx.lineTo(sz*0.22, -sz*0.5); ctx.closePath(); ctx.fill();
      // Window
      ctx.fillStyle = rgba(pc(2), 0.85); ctx.shadowBlur = 10; ctx.shadowColor = pc(2);
      ctx.beginPath(); ctx.arc(0, -sz*0.15, sz*0.16, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
      // Fins
      ctx.fillStyle = rgba(pc(1), 0.8);
      ctx.beginPath(); ctx.moveTo(-sz*0.22, sz*0.4); ctx.lineTo(-sz*0.55, sz*0.75); ctx.lineTo(-sz*0.22, sz*0.6); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(sz*0.22, sz*0.4); ctx.lineTo(sz*0.55, sz*0.75); ctx.lineTo(sz*0.22, sz*0.6); ctx.closePath(); ctx.fill();
      // Exhaust flame
      const flameH = sz*(0.3 + Math.sin(ph*8)*0.1 + bp*0.25);
      for (let fl=0; fl<3; fl++) {
        const ffg = ctx.createLinearGradient(0, sz*0.6, 0, sz*0.6+flameH*(1+fl*0.3));
        ffg.addColorStop(0, fl===0?'rgba(255,200,0,0.9)':fl===1?'rgba(255,100,0,0.7)':'rgba(100,50,255,0.5)');
        ffg.addColorStop(1, 'transparent');
        ctx.fillStyle = ffg;
        ctx.beginPath(); ctx.ellipse(0, sz*0.6+flameH*(0.3+fl*0.1), sz*(0.12-fl*0.03), flameH*(0.4+fl*0.2), 0, 0, Math.PI*2); ctx.fill();
      }
      break;
    }

    // ── UFO ──────────────────────────────────────────────
    case 'ufo': {
      ctx.shadowBlur = sz*0.35; ctx.shadowColor = pc(2);
      // Tractor beam on beat
      if (bp > 0.2) {
        const beamGrad = ctx.createLinearGradient(0, sz*0.1, 0, sz*1.2);
        beamGrad.addColorStop(0, rgba(pc(2), bp*0.4));
        beamGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = beamGrad;
        ctx.beginPath();
        ctx.moveTo(-sz*0.3, sz*0.1);
        ctx.lineTo(-sz*0.7, sz*1.2);
        ctx.lineTo(sz*0.7, sz*1.2);
        ctx.lineTo(sz*0.3, sz*0.1);
        ctx.closePath(); ctx.fill();
      }
      // Saucer body
      ctx.fillStyle = rgba(pc(0), 0.88);
      ctx.beginPath(); ctx.ellipse(0, 0, sz*0.9, sz*0.22, 0, 0, Math.PI*2); ctx.fill();
      // Dome
      ctx.fillStyle = rgba(pc(2), 0.8);
      ctx.shadowBlur = 15; ctx.shadowColor = pc(2);
      ctx.beginPath(); ctx.ellipse(0, -sz*0.1, sz*0.42, sz*0.32, 0, Math.PI, 0); ctx.fill();
      ctx.shadowBlur = 0;
      // Lights around rim
      for (let l=0; l<8; l++) {
        const la = l/8*Math.PI*2 + ph*2;
        const lit = l%2===0;
        ctx.fillStyle = lit ? rgba(pc(l%4), 0.9) : rgba(pc(l%4), 0.3);
        if (lit) { ctx.shadowBlur = 8; ctx.shadowColor = pc(l%4); }
        ctx.beginPath(); ctx.arc(Math.cos(la)*sz*0.75, Math.sin(la)*sz*0.1, sz*0.06, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
      }
      break;
    }

    // ── BLACK_HOLE ──────────────────────────────────────
    case 'black_hole': {
      // Actual accretion disk + funnel, NOT a circle
      ctx.shadowBlur = sz*0.3; ctx.shadowColor = pc(0);
      // Accretion disk rings
      for (let ring=8; ring>0; ring--) {
        const ri = ring/8;
        ctx.save(); ctx.scale(1, 0.3); // flatten to ellipse
        ctx.beginPath(); ctx.arc(0, 0, sz*(0.5+ri*0.7), 0, Math.PI*2);
        const dg = ctx.createRadialGradient(0,0,sz*(0.4+ri*0.6), 0,0,sz*(0.5+ri*0.7));
        dg.addColorStop(0, rgba(pc(ring%4), 0.5*(1-ri)*THEME.sceneIntensity));
        dg.addColorStop(1, 'transparent');
        ctx.fillStyle = dg; ctx.fill();
        ctx.restore();
      }
      // Spiral arms
      for (let arm=0; arm<3; arm++) {
        const aoff = arm/3*Math.PI*2 + cpRot*0.5;
        ctx.beginPath();
        for (let i=0; i<50; i++) {
          const r = sz*(0.3 + i/50 * 1.4);
          const a = aoff + i/50 * Math.PI*3;
          const x2 = Math.cos(a)*r, y2 = Math.sin(a)*r*0.3;
          i===0 ? ctx.moveTo(x2,y2) : ctx.lineTo(x2,y2);
        }
        ctx.strokeStyle = rgba(pc(arm%4), 0.4);
        ctx.lineWidth = sz*0.04; ctx.stroke();
      }
      // Event horizon (actual black)
      ctx.fillStyle = 'rgba(0,0,0,0.98)';
      ctx.beginPath(); ctx.arc(0, 0, sz*0.32, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = sz*0.5; ctx.shadowColor = pc(0);
      ctx.strokeStyle = rgba(pc(0), 0.8); ctx.lineWidth = sz*0.06;
      ctx.beginPath(); ctx.arc(0, 0, sz*0.32, 0, Math.PI*2); ctx.stroke();
      ctx.shadowBlur = 0;
      break;
    }

    // ── VINYL_RECORD ──────────────────────────────────────
    case 'vinyl_record': {
      ctx.shadowBlur = sz*0.2; ctx.shadowColor = 'rgba(0,0,0,0.5)';
      // Vinyl
      ctx.fillStyle = 'rgba(15,12,20,0.97)';
      ctx.beginPath(); ctx.arc(0, 0, sz, 0, Math.PI*2); ctx.fill();
      // Grooves
      ctx.strokeStyle = 'rgba(40,35,50,0.8)';
      for (let g=3; g<10; g++) {
        ctx.lineWidth = sz*0.025;
        ctx.beginPath(); ctx.arc(0, 0, sz*(g/10), 0, Math.PI*2); ctx.stroke();
      }
      // Label
      const lg = ctx.createRadialGradient(-sz*0.1, -sz*0.1, 0, 0, 0, sz*0.35);
      lg.addColorStop(0, rgba(pc(1), 0.95));
      lg.addColorStop(1, rgba(pc(0), 0.85));
      ctx.fillStyle = lg;
      ctx.beginPath(); ctx.arc(0, 0, sz*0.35, 0, Math.PI*2); ctx.fill();
      // Center hole
      ctx.fillStyle = 'rgba(0,0,0,0.95)';
      ctx.beginPath(); ctx.arc(0, 0, sz*0.06, 0, Math.PI*2); ctx.fill();
      // Scratch effect on beat
      if (bp > 0.5) {
        ctx.strokeStyle = rgba(pc(0), (bp-0.5)*1.5);
        ctx.lineWidth = sz*0.03;
        ctx.beginPath(); ctx.arc(0, 0, sz*0.7, -0.3, 0.3); ctx.stroke();
      }
      ctx.shadowBlur = 0;
      break;
    }

    // ── DISCO_BALL ──────────────────────────────────────
    case 'disco_ball': {
      // Draw the ball AND cast beams across the scene
      const rows=14, cols=18;
      ctx.shadowBlur = 5;
      for (let r=0; r<rows; r++) for (let c=0; c<cols; c++) {
        const lat=(r/rows-0.5)*Math.PI, lon=c/cols*Math.PI*2+cpRot*3;
        const tx=Math.cos(lat)*Math.cos(lon)*sz, ty=Math.sin(lat)*sz, tz=Math.cos(lat)*Math.sin(lon);
        if(tz<0.05) continue;
        const tsz=(5+tz*5)*(1+bp*0.2);
        const bright = 0.3+Math.abs(Math.sin(lon+cpRot*2+lat))*0.7;
        ctx.fillStyle = rgba(pc((r+c)%4), bright*(0.5+tz*0.5));
        ctx.shadowColor = pc((r+c)%4);
        ctx.fillRect(tx-tsz/2, ty-tsz/2, tsz, tsz);
      }
      ctx.shadowBlur = 0;
      break;
    }

    // ── SUN ──────────────────────────────────────────────
    case 'sun': {
      // Actual rays radiating out
      ctx.shadowBlur = sz*0.5; ctx.shadowColor = rgba(pc(1),0.8);
      for (let r=0; r<18; r++) {
        const a = r/18*Math.PI*2;
        const rLen = sz*(1.1+Math.sin(ph*2+r*0.7)*0.18+bp*0.22);
        const rW = sz*(0.04+Math.sin(ph+r)*0.02);
        ctx.save(); ctx.rotate(a);
        const rayG = ctx.createLinearGradient(0, sz*0.8, 0, rLen);
        rayG.addColorStop(0, rgba(pc(1),0.7)); rayG.addColorStop(1,'transparent');
        ctx.fillStyle = rayG;
        ctx.fillRect(-rW, sz*0.8, rW*2, rLen - sz*0.8);
        ctx.restore();
      }
      // Corona glow
      const cg = ctx.createRadialGradient(0,0,sz*0.7,0,0,sz*1.5);
      cg.addColorStop(0, rgba(pc(1),0.15)); cg.addColorStop(1,'transparent');
      ctx.fillStyle = cg; ctx.beginPath(); ctx.arc(0,0,sz*1.5,0,Math.PI*2); ctx.fill();
      // Disc
      const sg = ctx.createRadialGradient(-sz*0.25,-sz*0.25,0,0,0,sz);
      sg.addColorStop(0,'rgba(255,255,220,1)');
      sg.addColorStop(0.4,rgba(pc(1),0.9));
      sg.addColorStop(1,rgba(pc(0),0.6));
      ctx.fillStyle = sg; ctx.beginPath(); ctx.arc(0,0,sz,0,Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
      break;
    }

    // ── MOON ──────────────────────────────────────────────
    case 'moon': {
      ctx.shadowBlur = sz*0.3; ctx.shadowColor = rgba(pc(2),0.7);
      // Moon disc
      ctx.fillStyle = 'rgba(220,218,240,0.95)';
      ctx.beginPath(); ctx.arc(0,0,sz,0,Math.PI*2); ctx.fill();
      // Craters
      const craters = [{x:-sz*0.3,y:-sz*0.2,r:sz*0.14},{x:sz*0.25,y:sz*0.1,r:sz*0.2},{x:-sz*0.05,y:sz*0.35,r:sz*0.1},{x:sz*0.1,y:-sz*0.42,r:sz*0.09}];
      for (const cr of craters) {
        ctx.fillStyle = 'rgba(170,165,195,0.6)';
        ctx.beginPath(); ctx.arc(cr.x,cr.y,cr.r,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = 'rgba(195,192,215,0.4)';
        ctx.beginPath(); ctx.arc(cr.x-cr.r*0.2,cr.y-cr.r*0.2,cr.r*0.6,0,Math.PI*2); ctx.fill();
      }
      // Shadow cutout — makes it crescent
      ctx.fillStyle = rgba(THEME.bgColor, 0.9);
      ctx.beginPath(); ctx.arc(sz*0.32, 0, sz*0.82, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
      break;
    }

    // ── COMET ──────────────────────────────────────────────
    case 'comet': {
      ctx.shadowBlur = sz*0.4; ctx.shadowColor = rgba(pc(1),0.8);
      // Tail — tapers behind
      for (let tail=0; tail<12; tail++) {
        const tFrac = tail/12;
        const tailG = ctx.createLinearGradient(-sz*0.3-tFrac*sz*2.5,0,0,0);
        tailG.addColorStop(0,'transparent');
        tailG.addColorStop(1, rgba(pc(tail%4), 0.35*(1-tFrac)));
        ctx.fillStyle = tailG;
        ctx.beginPath();
        ctx.ellipse(-sz*0.3-tFrac*sz*1.5, (Math.sin(tail*0.8+ph)*sz*0.04), sz*(0.8+tFrac*1.2), sz*(0.06+tFrac*0.22+bp*0.05), 0, 0, Math.PI*2);
        ctx.fill();
      }
      // Debris particles in tail
      for (let d=0; d<8; d++) {
        ctx.fillStyle = rgba(pc(d%4), 0.5);
        ctx.beginPath();
        ctx.arc(-sz*(0.5+d*0.3)+Math.sin(ph+d)*sz*0.08, (Math.sin(d*1.7+ph)*sz*0.12), sz*0.04, 0, Math.PI*2);
        ctx.fill();
      }
      // Head — bright nucleus
      const hg = ctx.createRadialGradient(-sz*0.05,-sz*0.05,0,0,0,sz*0.38);
      hg.addColorStop(0,'rgba(255,255,230,1)');
      hg.addColorStop(0.5,rgba(pc(1),0.9));
      hg.addColorStop(1,rgba(pc(0),0.4));
      ctx.fillStyle = hg;
      ctx.beginPath(); ctx.arc(0,0,sz*0.38,0,Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
      break;
    }

    // ── SKULL_CROSSBONES ──────────────────────────────────
    case 'skull_crossbones': {
      // Two crossed bones behind skull
      ctx.shadowBlur = sz*0.3; ctx.shadowColor = pc(0);
      ctx.strokeStyle = rgba(pc(0), 0.75); ctx.lineWidth = sz*0.14; ctx.lineCap = 'round';
      ctx.beginPath(); ctx.moveTo(-sz*0.65, sz*0.8); ctx.lineTo(sz*0.65, sz*0.1); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(sz*0.65, sz*0.8); ctx.lineTo(-sz*0.65, sz*0.1); ctx.stroke();
      ctx.lineCap = 'butt';
      // Skull on top
      ctx.save(); ctx.translate(0, -sz*0.1); ctx.scale(0.8,0.8); drawCP(ctx,'skull',sz,t); ctx.restore();
      ctx.shadowBlur = 0;
      break;
    }

    // ── TRIDENT ──────────────────────────────────────────
    case 'trident': {
      ctx.shadowBlur = sz*0.35; ctx.shadowColor = pc(0);
      ctx.fillStyle = rgba(pc(0), 0.9);
      ctx.strokeStyle = rgba(pc(0), 0.9);
      // Shaft
      ctx.lineWidth = sz*0.1; ctx.lineCap = 'round';
      ctx.beginPath(); ctx.moveTo(0, sz); ctx.lineTo(0, -sz*0.3); ctx.stroke();
      // Center prong
      ctx.beginPath(); ctx.moveTo(0, -sz*0.3); ctx.lineTo(0, -sz); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-sz*0.08, -sz*0.7); ctx.lineTo(sz*0.08, -sz*0.7); ctx.lineTo(sz*0.08, -sz*0.8); ctx.lineTo(0, -sz); ctx.lineTo(-sz*0.08, -sz*0.8); ctx.lineTo(-sz*0.08, -sz*0.7); ctx.closePath(); ctx.fill();
      // Side prongs
      ctx.lineWidth = sz*0.07;
      for (const sx3 of [-1, 1]) {
        ctx.beginPath(); ctx.moveTo(sz*0.3*sx3, -sz*0.3); ctx.lineTo(sz*0.42*sx3, -sz*0.85); ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(sz*(0.36+0.05*sx3), -sz*0.6);
        ctx.lineTo(sz*(0.45+0.05*sx3), -sz*0.85);
        ctx.lineTo(sz*(0.3*sx3), -sz*0.78);
        ctx.closePath(); ctx.fill();
      }
      // Cross guard
      ctx.lineWidth = sz*0.09;
      ctx.beginPath(); ctx.moveTo(-sz*0.45, -sz*0.22); ctx.lineTo(sz*0.45, -sz*0.22); ctx.stroke();
      ctx.lineCap = 'butt'; ctx.shadowBlur = 0;
      break;
    }

    // ── LOTUS ──────────────────────────────────────────────
    case 'lotus': {
      ctx.shadowBlur = sz*0.25; ctx.shadowColor = pc(0);
      // Outer petals
      for (let layer=0; layer<3; layer++) {
        const petals = 8 - layer*2;
        const openAngle = (0.3 + songProg*0.4 + bp*0.15) * (1 - layer*0.2);
        for (let p=0; p<petals; p++) {
          const a = p/petals*Math.PI*2;
          ctx.save(); ctx.rotate(a + cpRot*0.1*layer);
          ctx.fillStyle = rgba(pc((layer+p)%4), 0.7 - layer*0.1);
          ctx.beginPath();
          ctx.moveTo(0, 0);
          const pr = sz*(0.5+layer*0.15);
          ctx.bezierCurveTo(-sz*0.12, -pr*0.3, -sz*0.08+Math.sin(ph)*sz*0.02, -pr, 0, -pr*(1+openAngle));
          ctx.bezierCurveTo(sz*0.08+Math.sin(ph)*sz*0.02, -pr, sz*0.12, -pr*0.3, 0, 0);
          ctx.closePath(); ctx.fill();
          ctx.restore();
        }
      }
      // Center
      const cgg = ctx.createRadialGradient(0,0,0,0,0,sz*0.2);
      cgg.addColorStop(0, rgba(pc(1),0.95)); cgg.addColorStop(1, rgba(pc(0),0.7));
      ctx.fillStyle = cgg; ctx.beginPath(); ctx.arc(0,0,sz*0.2,0,Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
      break;
    }

    // ── EYE ──────────────────────────────────────────────
    case 'eye': {
      ctx.shadowBlur = sz*0.3; ctx.shadowColor = pc(1);
      // Whites
      ctx.fillStyle = 'rgba(240,238,235,0.97)';
      ctx.beginPath();
      ctx.moveTo(-sz, 0);
      ctx.bezierCurveTo(-sz*0.5, -sz*0.55, sz*0.5, -sz*0.55, sz, 0);
      ctx.bezierCurveTo(sz*0.5, sz*0.55, -sz*0.5, sz*0.55, -sz, 0);
      ctx.closePath(); ctx.fill();
      // Iris
      const irisR = sz*(0.36 + bp*0.06);
      const irisg = ctx.createRadialGradient(0,0,0,0,0,irisR);
      irisg.addColorStop(0, rgba(pc(1),1)); irisg.addColorStop(0.7, rgba(pc(0),0.9)); irisg.addColorStop(1, rgba(pc(0),0.6));
      ctx.fillStyle = irisg;
      ctx.beginPath(); ctx.arc(0,0,irisR,0,Math.PI*2); ctx.fill();
      // Pupil — dilates with energy
      const pupilR = sz*(0.16 + e*0.12);
      ctx.fillStyle = 'rgba(0,0,0,0.97)';
      ctx.shadowBlur = 0;
      ctx.beginPath(); ctx.arc(0,0,pupilR,0,Math.PI*2); ctx.fill();
      // Reflection
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.beginPath(); ctx.arc(-pupilR*0.4,-pupilR*0.5,pupilR*0.35,0,Math.PI*2); ctx.fill();
      // Eyelid outline
      ctx.strokeStyle = 'rgba(80,60,50,0.5)'; ctx.lineWidth = sz*0.04;
      ctx.beginPath();
      ctx.moveTo(-sz, 0);
      ctx.bezierCurveTo(-sz*0.5, -sz*0.55, sz*0.5, -sz*0.55, sz, 0);
      ctx.stroke();
      ctx.shadowBlur = 0;
      break;
    }

    // ── ANKH ──────────────────────────────────────────────
    case 'ankh': {
      ctx.shadowBlur = sz*0.25; ctx.shadowColor = pc(0);
      ctx.strokeStyle = rgba(pc(0), 0.92); ctx.lineWidth = sz*0.13; ctx.lineCap = 'round';
      // Vertical
      ctx.beginPath(); ctx.moveTo(0, -sz*0.1); ctx.lineTo(0, sz); ctx.stroke();
      // Horizontal
      ctx.beginPath(); ctx.moveTo(-sz*0.55, sz*0.18); ctx.lineTo(sz*0.55, sz*0.18); ctx.stroke();
      // Loop
      ctx.lineWidth = sz*0.1;
      ctx.beginPath(); ctx.ellipse(0, -sz*0.48, sz*0.38, sz*0.44, 0, 0, Math.PI*2); ctx.stroke();
      ctx.lineCap = 'butt'; ctx.shadowBlur = 0;
      break;
    }

    // ── MANDALA ──────────────────────────────────────────
    case 'mandala': {
      for (let layer=0; layer<7; layer++) {
        const r = sz*(0.12+layer*0.13);
        const petals = 6+layer*2;
        for (let p=0; p<petals; p++) {
          const a = p/petals*Math.PI*2 + cpRot*(1-layer*0.08);
          ctx.save(); ctx.rotate(a);
          ctx.fillStyle = rgba(pc((layer+p)%4), (0.45-layer*0.04)*THEME.sceneIntensity*(1+bp*0.2));
          ctx.beginPath(); ctx.ellipse(r,0,r*0.38,r*0.11,0,0,Math.PI*2); ctx.fill();
          ctx.restore();
        }
      }
      ctx.fillStyle = rgba(pc(0),0.9); ctx.shadowBlur=15; ctx.shadowColor=pc(0);
      ctx.beginPath(); ctx.arc(0,0,sz*0.1,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
      break;
    }

    // ── DNA_HELIX ──────────────────────────────────────────
    case 'dna_helix': {
      const segs=24;
      for (let strand=0; strand<2; strand++) for (let i=0; i<segs-1; i++) {
        const y1=i/segs*sz*2-sz, y2=(i+1)/segs*sz*2-sz;
        const x1=Math.cos(i/segs*Math.PI*4+cpRot+(strand/2)*Math.PI)*sz*0.42;
        const x2=Math.cos((i+1)/segs*Math.PI*4+cpRot+(strand/2)*Math.PI)*sz*0.42;
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
        ctx.strokeStyle=rgba(pc((strand*2+i)%4),0.85);
        ctx.lineWidth=sz*0.05; ctx.shadowBlur=6; ctx.shadowColor=pc(strand%4); ctx.stroke(); ctx.shadowBlur=0;
      }
      for (let i=0; i<segs; i++) {
        const y=i/segs*sz*2-sz;
        const x1=Math.cos(i/segs*Math.PI*4+cpRot)*sz*0.42;
        const x2=Math.cos(i/segs*Math.PI*4+cpRot+Math.PI)*sz*0.42;
        ctx.beginPath(); ctx.moveTo(x1,y); ctx.lineTo(x2,y);
        ctx.strokeStyle=rgba(pc(i%4),0.35); ctx.lineWidth=sz*0.025; ctx.stroke();
        // Nucleotide dots
        if (i%3===0) {
          ctx.fillStyle = rgba(pc(i%4),0.7);
          ctx.beginPath(); ctx.arc(x1,y,sz*0.04,0,Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(x2,y,sz*0.04,0,Math.PI*2); ctx.fill();
        }
      }
      break;
    }

    // ── TESSERACT ──────────────────────────────────────────
    case 'tesseract': {
      const draw3DBox=(scale,al,ci)=>{
        const pts=[[-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1],[-1,-1,1],[1,-1,1],[1,1,1],[-1,1,1]].map(([px,py,pz])=>{
          const rx=px*Math.cos(cpRot)-pz*Math.sin(cpRot),rz2=px*Math.sin(cpRot)+pz*Math.cos(cpRot);
          const ry=py*Math.cos(cpRot*0.7)-rz2*Math.sin(cpRot*0.7),rz3=py*Math.sin(cpRot*0.7)+rz2*Math.cos(cpRot*0.7);
          return{x:rx*sz*scale/(rz3+3)*3,y:ry*sz*scale/(rz3+3)*3};
        });
        [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]].forEach(([a,b])=>{
          ctx.beginPath(); ctx.moveTo(pts[a].x,pts[a].y); ctx.lineTo(pts[b].x,pts[b].y);
          ctx.strokeStyle=rgba(pc(ci),al); ctx.lineWidth=sz*0.03; ctx.stroke();
        });
      };
      ctx.shadowBlur=12; ctx.shadowColor=pc(0);
      draw3DBox(0.4,0.95,0); draw3DBox(0.8,0.55,1); draw3DBox(1.2,0.28,2);
      ctx.shadowBlur=0;
      break;
    }

    // ── HOURGLASS ──────────────────────────────────────────
    case 'hourglass': {
      ctx.shadowBlur = sz*0.2; ctx.shadowColor = pc(0);
      ctx.fillStyle = rgba(pc(0), 0.35); ctx.strokeStyle = rgba(pc(0), 0.85); ctx.lineWidth = sz*0.04;
      // Top half
      ctx.beginPath(); ctx.moveTo(-sz*0.5,-sz); ctx.lineTo(sz*0.5,-sz); ctx.lineTo(0,0); ctx.closePath(); ctx.fill(); ctx.stroke();
      // Bottom half
      ctx.beginPath(); ctx.moveTo(-sz*0.5,sz); ctx.lineTo(sz*0.5,sz); ctx.lineTo(0,0); ctx.closePath(); ctx.fill(); ctx.stroke();
      // Sand
      ctx.fillStyle = rgba(pc(1), 0.85);
      ctx.fillRect(-sz*0.38*(1-songProg), -sz*(0.95-songProg*0.05), sz*0.76*(1-songProg), sz*(0.9-songProg*0.85));
      ctx.fillStyle = rgba(pc(2), 0.75);
      ctx.fillRect(-sz*0.38*songProg, sz*0.05, sz*0.76*songProg, sz*0.88*songProg);
      // Falling grain
      if (songProg < 0.98) {
        ctx.fillStyle = rgba(pc(1), 0.7);
        for (let g=0; g<3; g++) ctx.fillRect(Math.sin(ph*7+g)*sz*0.04 - sz*0.01, sz*(0.0+g*0.05), sz*0.025, sz*0.06);
      }
      ctx.shadowBlur = 0;
      break;
    }

    // ── CROWN ──────────────────────────────────────────────
    case 'crown': {
      ctx.shadowBlur = sz*0.3; ctx.shadowColor = pc(1);
      ctx.fillStyle = rgba(pc(1), 0.9);
      // Base band
      ctx.fillRect(-sz*0.75, sz*0.05, sz*1.5, sz*0.4);
      // 5 points
      const heights = [0.55, 0.38, 0.7, 0.38, 0.55];
      for (let p=0; p<5; p++) {
        const px2 = -sz*0.75 + p*sz*0.375;
        ctx.beginPath();
        ctx.moveTo(px2, sz*0.05);
        ctx.lineTo(px2 + sz*0.1875, -sz*heights[p]*(1+bp*0.08));
        ctx.lineTo(px2 + sz*0.375, sz*0.05);
        ctx.closePath(); ctx.fill();
      }
      ctx.shadowBlur = 0;
      // Jewels
      for (let j=0; j<5; j++) {
        ctx.fillStyle = rgba(pc(j%4), 0.95);
        ctx.shadowBlur = 8; ctx.shadowColor = pc(j%4);
        ctx.beginPath(); ctx.arc(-sz*0.56+j*sz*0.28, sz*0.24, sz*(0.07+bp*0.03), 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
      }
      break;
    }

    // ── CLOCK_FACE ──────────────────────────────────────────
    case 'clock_face': {
      ctx.shadowBlur = sz*0.15; ctx.shadowColor = pc(0);
      ctx.fillStyle = 'rgba(240,235,220,0.93)';
      ctx.beginPath(); ctx.arc(0,0,sz,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle = rgba(pc(0),0.75); ctx.lineWidth = sz*0.045; ctx.stroke();
      ctx.shadowBlur = 0;
      for (let hr=0; hr<12; hr++) {
        const ha = hr/12*Math.PI*2-Math.PI/2;
        ctx.beginPath(); ctx.moveTo(Math.cos(ha)*sz*0.8, Math.sin(ha)*sz*0.8); ctx.lineTo(Math.cos(ha)*sz*0.92, Math.sin(ha)*sz*0.92);
        ctx.strokeStyle = rgba(pc(0),0.8); ctx.lineWidth = hr%3===0?sz*0.06:sz*0.03; ctx.stroke();
      }
      const ha2 = cpPh*0.1-Math.PI/2, ma = cpPh-Math.PI/2, sa = cpPh*10-Math.PI/2;
      ctx.lineCap = 'round';
      ctx.strokeStyle = rgba(pc(0),0.9); ctx.lineWidth=sz*0.07;
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(ha2)*sz*0.55, Math.sin(ha2)*sz*0.55); ctx.stroke();
      ctx.lineWidth = sz*0.05;
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(ma)*sz*0.75, Math.sin(ma)*sz*0.75); ctx.stroke();
      ctx.strokeStyle = rgba(pc(2),0.9); ctx.lineWidth = sz*0.025;
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(sa)*sz*0.85, Math.sin(sa)*sz*0.85); ctx.stroke();
      ctx.lineCap = 'butt';
      ctx.fillStyle = rgba(pc(0),1); ctx.beginPath(); ctx.arc(0,0,sz*0.05,0,Math.PI*2); ctx.fill();
      break;
    }

    // ── TURNTABLE ──────────────────────────────────────────
    case 'turntable': {
      ctx.shadowBlur = sz*0.2; ctx.shadowColor = 'rgba(0,0,0,0.5)';
      // Deck body
      ctx.fillStyle = 'rgba(25,22,30,0.95)';
      ctx.beginPath(); ctx.roundRect(-sz,-sz*0.65,sz*2,sz*1.3,sz*0.08); ctx.fill();
      ctx.strokeStyle = rgba(pc(0),0.5); ctx.lineWidth = sz*0.03; ctx.stroke();
      // Platter
      ctx.fillStyle = 'rgba(40,35,50,0.95)';
      ctx.beginPath(); ctx.arc(sz*0.05,sz*0.05,sz*0.7,0,Math.PI*2); ctx.fill();
      // Record on platter
      ctx.save(); ctx.translate(sz*0.05,sz*0.05);
      drawCP(ctx, 'vinyl_record', sz*0.65, t);
      ctx.restore();
      // Tonearm
      ctx.save();
      ctx.translate(sz*0.7, -sz*0.45);
      ctx.rotate(cpPh*0.05 - 0.5);
      ctx.strokeStyle = 'rgba(180,170,150,0.9)'; ctx.lineWidth = sz*0.04; ctx.lineCap = 'round';
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-sz*1.2, sz*0.9); ctx.stroke();
      ctx.fillStyle = 'rgba(200,190,160,0.9)';
      ctx.beginPath(); ctx.arc(0,0,sz*0.08,0,Math.PI*2); ctx.fill();
      ctx.lineCap = 'butt'; ctx.restore();
      ctx.shadowBlur = 0;
      break;
    }

    // ── PLANET ──────────────────────────────────────────────
    case 'planet': {
      // Planet with rings AND surface features — clearly different from sun
      ctx.shadowBlur = sz*0.2; ctx.shadowColor = pc(0);
      const pg = ctx.createRadialGradient(-sz*0.3,-sz*0.3,0,0,0,sz);
      pg.addColorStop(0,rgba(pc(2),1)); pg.addColorStop(0.5,rgba(pc(0),0.85)); pg.addColorStop(1,rgba(pc(1),0.5));
      ctx.fillStyle = pg; ctx.beginPath(); ctx.arc(0,0,sz,0,Math.PI*2); ctx.fill();
      // Surface bands
      for (let band=0; band<5; band++) {
        const by = -sz*0.7 + band*sz*0.35;
        ctx.fillStyle = rgba(pc((band+1)%4), 0.15);
        ctx.beginPath(); ctx.ellipse(0, by, sz*Math.sqrt(1-(by/sz)*(by/sz))*0.98, sz*0.06, 0, 0, Math.PI*2); ctx.fill();
      }
      // Storm spot
      ctx.fillStyle = rgba(pc(3), 0.35);
      ctx.beginPath(); ctx.ellipse(sz*0.25, sz*0.1, sz*0.2, sz*0.14, 0.3, 0, Math.PI*2); ctx.fill();
      // Rings
      ctx.save(); ctx.scale(1,0.25);
      for (let ri=0; ri<4; ri++) {
        ctx.beginPath(); ctx.arc(0,0,sz*(1.3+ri*0.2),0,Math.PI*2);
        ctx.strokeStyle = rgba(pc((ri+2)%4),0.3-ri*0.06); ctx.lineWidth = 8+ri*3; ctx.stroke();
      }
      ctx.restore(); ctx.shadowBlur=0;
      break;
    }

    // ── WORMHOLE ──────────────────────────────────────────
    case 'wormhole': {
      // Funnel + spiral, NOT just concentric circles
      for (let ring=12; ring>0; ring--) {
        ctx.save(); ctx.scale(1, 0.5+ring*0.04);
        ctx.beginPath(); ctx.arc(0,0,sz*(ring/12)*(1+bp*0.05),0,Math.PI*2);
        ctx.strokeStyle = rgba(pc(ring%4),0.5*(ring/12)+bp*0.1);
        ctx.lineWidth = sz*0.04; ctx.stroke(); ctx.restore();
      }
      // Spiral
      ctx.beginPath();
      for (let i=0; i<100; i++) {
        const r=sz*(1-i/100)*0.9, a=i/100*Math.PI*8+cpRot;
        i===0?ctx.moveTo(Math.cos(a)*r,Math.sin(a)*r*0.5):ctx.lineTo(Math.cos(a)*r,Math.sin(a)*r*0.5);
      }
      ctx.strokeStyle=rgba(pc(0),0.4); ctx.lineWidth=sz*0.025; ctx.stroke();
      // Black void center
      const pvg=ctx.createRadialGradient(0,0,0,0,0,sz*0.35);
      pvg.addColorStop(0,'rgba(0,0,0,1)'); pvg.addColorStop(0.7,rgba(pc(0),0.4)); pvg.addColorStop(1,'transparent');
      ctx.fillStyle=pvg; ctx.beginPath(); ctx.arc(0,0,sz*0.45,0,Math.PI*2); ctx.fill();
      break;
    }

    // ── CHANDELIER ──────────────────────────────────────────
    case 'chandelier': {
      ctx.shadowBlur = sz*0.3; ctx.shadowColor = pc(0);
      ctx.strokeStyle = rgba(pc(0),0.85); ctx.lineWidth = sz*0.04;
      // Central stem
      ctx.beginPath(); ctx.moveTo(0,-sz*0.9); ctx.lineTo(0,sz*0.3); ctx.stroke();
      // Arms radiating out
      for (let arm=0; arm<6; arm++) {
        const a = arm/6*Math.PI*2 + cpRot*0.3;
        const ax = Math.cos(a)*sz*0.7, ay = Math.sin(a)*sz*0.2 - sz*0.1;
        ctx.beginPath(); ctx.moveTo(0,sz*0.05); ctx.quadraticCurveTo(Math.cos(a)*sz*0.35,ay*0.5,ax,ay); ctx.stroke();
        // Hanging crystal drops
        ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(ax,ay+sz*0.2); ctx.strokeStyle = rgba(pc(arm%4),0.5); ctx.lineWidth=sz*0.015; ctx.stroke();
        ctx.fillStyle = rgba(pc(arm%4),0.88); ctx.shadowBlur=10; ctx.shadowColor=pc(arm%4);
        ctx.beginPath(); ctx.moveTo(ax,ay+sz*0.2); ctx.lineTo(ax-sz*0.04,ay+sz*0.25); ctx.lineTo(ax,ay+sz*0.35); ctx.lineTo(ax+sz*0.04,ay+sz*0.25); ctx.closePath(); ctx.fill();
        ctx.shadowBlur=0; ctx.strokeStyle=rgba(pc(0),0.85); ctx.lineWidth=sz*0.04;
      }
      // Central cluster
      ctx.fillStyle=rgba(pc(1),0.85); ctx.shadowBlur=15; ctx.shadowColor=pc(1);
      ctx.beginPath(); ctx.arc(0,sz*0.3,sz*0.12,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
      break;
    }

    // Fallback for unknown names — crystal/gem shape
    default: {
      ctx.shadowBlur = sz*0.3; ctx.shadowColor = pc(0);
      ctx.fillStyle = rgba(pc(0), 0.85);
      ctx.beginPath();
      for (let i=0; i<6; i++) {
        const a = i/6*Math.PI*2;
        const r = i%2===0 ? sz : sz*0.55;
        i===0 ? ctx.moveTo(Math.cos(a)*r, Math.sin(a)*r) : ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
      }
      ctx.closePath(); ctx.fill(); ctx.shadowBlur=0;
    }
  }
  ctx.restore();
}

// ── Position/behavior wrapper ───────────────────────────
function drawCPWithBehavior(ctx, t) {
  if (!THEME.centerpiece || THEME.centerpieceScale === 0) return;
  const w=W(), h=H();
  const baseCX = w*(THEME.centerpieceX||0.5);
  const baseCY = h*(THEME.centerpieceY||0.5);
  const sz = Math.min(w,h) * THEME.centerpieceScale * 0.38;
  cpPh += 0.013;

  let posX=baseCX, posY=baseCY, alpha=1;
  switch(THEME.centerpieceBehavior) {
    case 'spin_fast': cpRot+=0.09*(1+SM.energy); break;
    case 'pulse_beat': cpRot+=0.005; break;
    case 'orbit_slow': cpOrbit+=0.007; break;
    case 'strobe':  cpRot+=0.04; if(SM.beatPulse<0.3) return; break;
    case 'bounce':
      cpRot+=0.02;
      cpBounceX+=cpBounceVX*(1+SM.energy*0.3);
      cpBounceY+=cpBounceVY*(1+SM.energy*0.3);
      if(Math.abs(cpBounceX)>w*0.38){cpBounceVX*=-1;}
      if(Math.abs(cpBounceY)>h*0.32){cpBounceVY*=-1;}
      posX=baseCX+cpBounceX; posY=baseCY+cpBounceY; break;
    case 'drift':
      cpRot+=0.007;
      posX=baseCX+Math.sin(t*0.0004)*w*0.18;
      posY=baseCY+Math.cos(t*0.0003)*h*0.13; break;
    case 'watermark':
      cpRot+=0.002;
      alpha=0.06+Math.sin(cpPh*0.25)*0.025; break;
    case 'rise_set':
      cpRot+=0.01;
      posY=baseCY+Math.sin(t*0.00008)*h*0.15; break;
    case 'breathe':
      cpRot+=0.008; break;
    default: cpRot+=0.012*(1+SM.energy*0.15);
  }

  const pulseSz = THEME.centerpieceBehavior==='pulse_beat' ? sz*(1+SM.beatPulse*0.35) :
                  THEME.centerpieceBehavior==='breathe' ? sz*(1+Math.sin(cpPh*0.4)*0.1) : sz;
  const orbX = THEME.centerpieceBehavior==='orbit_slow' ? Math.cos(cpOrbit)*w*0.14 : 0;
  const orbY = THEME.centerpieceBehavior==='orbit_slow' ? Math.sin(cpOrbit)*h*0.08 : 0;

  if (pulseSz < 2) return;
  ctx.save();
  ctx.globalAlpha = alpha;
  if (beatFX.slamS > 1.002) {
    ctx.translate(w/2,h/2); ctx.scale(beatFX.slamS,beatFX.slamS); ctx.translate(-w/2,-h/2);
  }
  ctx.translate(posX+orbX, posY+orbY);
  ctx.rotate(cpRot);
  drawCP(ctx, THEME.centerpiece, pulseSz, t);
  ctx.restore();
}

// ── Mini version for scene integrations ────────────────
function drawCPMini(ctx, name, x, y, sz, rotation) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(rotation || 0);
  drawCP(ctx, name, sz, cpPh*100);
  ctx.restore();
}


// ═══ BEAT FX RENDER ═══
function drawBeatFX(){
  const w=W(),h=H(),cx=w/2,cy=h/2;
  if(beatFX.shockwaveA>0.01){beatFX.shockwaveR+=12*(1+SM.energy);beatFX.shockwaveA*=0.88;x2.beginPath();x2.arc(cx,cy,beatFX.shockwaveR,0,Math.PI*2);x2.strokeStyle=rgba(pc(0),beatFX.shockwaveA);x2.lineWidth=3+beatFX.shockwaveA*5;x2.stroke();if(beatFX.shockwaveR>Math.sqrt(cx*cx+cy*cy)+100)beatFX.shockwaveA=0;}
  if(beatFX.crackLines.length>0){for(let i=beatFX.crackLines.length-1;i>=0;i--){const cl=beatFX.crackLines[i];cl.life-=0.05;if(cl.life<=0){beatFX.crackLines.splice(i,1);continue;}x2.shadowBlur=15;x2.shadowColor=pc(cl.ci);let prev={x:cx,y:cy};for(const seg of cl.segs){x2.beginPath();x2.moveTo(prev.x,prev.y);x2.lineTo(seg.x,seg.y);x2.strokeStyle=rgba(pc(cl.ci),cl.life*0.9);x2.lineWidth=cl.life*3;x2.stroke();prev=seg;}x2.shadowBlur=0;}}
  if(beatFX.invertA>0.01){x2.fillStyle=rgba(pc(0),beatFX.invertA*0.4);x2.fillRect(0,0,w,h);beatFX.invertA*=0.82;}
  if(beatFX.slamS>1.001){beatFX.slamS+=(1-beatFX.slamS)*0.15;}
  if(beatFX.gravityWave>0.01){x2.fillStyle=rgba(pc(2),beatFX.gravityWave*0.08);x2.fillRect(0,0,w,h);beatFX.gravityWave*=0.9;}
  beatFX.speedBoost*=0.88;
}

// ═══ RENDER LOOP ═══
function render(t){
  requestAnimationFrame(render);
  if(!token)return;
  const w=W(),h=H();
  SM.energy+=(MS.energy-SM.energy)*0.05;
  SM.beatPulse*=0.87;
  if(t-MS.lastBeat>MS.beatInterval){MS.lastBeat=t;triggerBeat();}
  if(MS.duration>0){songProg=Math.min(1,(Date.now()-MS.analysisStart)/MS.duration);progMult=0.55+songProg*0.7;}
  // Progress bar
  document.getElementById('pgBar').style.width=(songProg*100)+'%';
  // Cursor
  const tc=h2r(pc(Math.floor(t/3000)%4));document.getElementById('cur').style.background=`rgb(${tc.r},${tc.g},${tc.b})`;
  // Scene layer
  switch(THEME.scene){
    case 'WARP_SPEED':drawWarpSpeed(t);break;case 'LAVA_WORLD':drawLavaWorld(t);break;
    case 'CYBER_GRID':drawCyberGrid(t);break;case 'DEEP_SEA':drawDeepSea(t);break;
    case 'STORM_CHASER':drawStormChaser(t);break;case 'JUNGLE_RAVE':drawJungleRave(t);break;
    case 'DISCO_DIMENSION':drawDiscoDimension(t);break;case 'ACID_TRIP':drawAcidTrip(t);break;
    case 'SPACE_STATION':drawSpaceStation(t);break;case 'NEON_CATHEDRAL':drawNeonCathedral(t);break;
    case 'CLASSIC_ARCADE':drawClassicArcade(t);break;case 'ELECTRIC_FOREST':drawElectricForest(t);break;
    case 'OMNIA_NIGHTCLUB':drawOmniaNightclub(t);break;case 'PIRATE_SHIP':drawPirateShip(t);break;
    case 'JUNKYARD':drawJunkyard(t);break;case 'SUPERHERO':drawSuperhero(t);break;
    case 'DAY_OF_DEAD':drawDayOfDead(t);break;case 'CHINESE_DRAGON':drawChineseDragon(t);break;
    case 'MOUNT_OLYMPUS':drawMountOlympus(t);break;case 'SUPER_MARIO':drawSuperMario(t);break;
    case 'ATLANTIS':drawAtlantis(t);break;case 'CARNIVAL':drawCarnival(t);break;
    case 'EGYPTIAN_TOMB':drawEgyptianTomb(t);break;default:drawWarpSpeed(t);
  }
  // Centerpiece layer — only for non-integrated scenes
  x1.clearRect(0,0,w,h);
  if(THEME.centerpiece&&THEME.centerpieceScale>0&&!CP_INTEGRATED_SCENES.has(THEME.scene)){
    drawCPWithBehavior(x1,t);
  }
  // Beat FX layer
  x2.clearRect(0,0,w,h);
  drawBeatFX();
  // Vignette
  x3.clearRect(0,0,w,h);
  const vg=x3.createRadialGradient(w/2,h/2,h*0.2,w/2,h/2,h*0.85);
  vg.addColorStop(0,'transparent');vg.addColorStop(1,'rgba(0,0,0,0.55)');
  x3.fillStyle=vg;x3.fillRect(0,0,w,h);
}
requestAnimationFrame(render);

// ═══ TRANSITION ═══
async function transition(name,artist,theme){
  if(inTrans)return;inTrans=true;
  const wash=document.getElementById('wash'),splash=document.getElementById('splash');
  const c=h2r(theme.palette[0]);
  wash.style.background=`radial-gradient(ellipse at 50% 40%,rgba(${c.r},${c.g},${c.b},0.92) 0%,rgba(0,0,0,0.97) 70%)`;
  wash.style.transition='opacity 1.1s ease';wash.style.opacity='1';
  await delay(1200);
  Object.assign(THEME,theme);
  MS.energy=theme.energy||0.5;songProg=0;progMult=0.55;
  initScene();
  document.getElementById('cur').style.background=theme.palette[0];
  document.getElementById('trackName').style.color=theme.palette[0];
  document.getElementById('sceneTag').style.color=theme.palette[2]||theme.palette[0];
  document.getElementById('pgBar').style.background=`linear-gradient(90deg,${theme.palette[1]||theme.palette[0]},${theme.palette[0]})`;
  document.getElementById('pgBar').style.boxShadow=`0 0 8px ${theme.palette[0]}`;
  document.getElementById('sceneTag').textContent=(theme.scene||'SCENE').replace(/_/g,' ')+' — '+(theme.label||'');
  document.getElementById('splashScene').textContent='— '+(theme.scene||'').replace(/_/g,' ')+' —';
  document.getElementById('splashTrack').textContent=name;
  document.getElementById('splashTrack').style.color=theme.palette[0];
  document.getElementById('splashArtist').textContent=artist;
  document.getElementById('splashDesc').textContent=theme.splashDesc||'';
  splash.classList.add('show');
  wash.style.transition='opacity 1.0s ease';wash.style.opacity='0';
  await delay(2200);
  splash.style.transition='opacity 0.7s ease';splash.style.opacity='0';
  await delay(800);
  splash.classList.remove('show');splash.style.opacity='';splash.style.transition='';
  inTrans=false;
}

// ═══ AI THEME LOADER ═══
const ARTIST_CTX={'marshmello':'Marshmello white marshmallow helmet X eyes. EDM festival.','daft punk':'Daft Punk robot helmets. French house. Disco. Tron neon.','deadmau5':'Mouse head helmet. Progressive house. Dark neon.','pink floyd':'Prism rainbow. Flying pigs. Psychedelic prog rock.','the weeknd':'Neon 80s. Red black. Blinding Lights city highways.','david bowie':'Ziggy Stardust lightning bolt. Glam. Cosmic.','queen':'Stadium rock. Operatic grandeur. Freddie Mercury.','nirvana':'Grunge. Dark raw distorted energy.','eminem':'Detroit. 8 Mile. Raw urban intense.','kendrick lamar':'Compton. DNA. DAMN imagery.','taylor swift':'Sparkles. Eras. Stadium spectacle.','billie eilish':'Dark green black. Spider webs. Haunted.','coldplay':'Colorful confetti. Neon wristbands. Cosmos.','radiohead':'Dystopian glitch. OK Computer robot anxiety.','metallica':'Thrash metal. Lightning bolt. Fire skulls.','skrillex':'Heavy dubstep. Glitch alien.','flume':'Organic futurism. Bioluminescent crystals.'};
function getArtistCtx(name){const k=name.toLowerCase();for(const[n,v]of Object.entries(ARTIST_CTX))if(k.includes(n))return v;return null;}
function extractKW(title){const stop=new Set(['a','an','the','in','of','to','and','or','i','my','me','you','is','it','by','on','for','with','as','be','was']);return title.toLowerCase().replace(/[^\w\s]/g,'').split(/\s+/).filter(w=>w.length>2&&!stop.has(w)).slice(0,6);}

async function loadTheme(tid,name,artist,artistIds,isExplicit,durationMs){
  if(aiCache[tid]){applyTheme(name,artist,aiCache[tid]);return;}
  let genres=[];
  try{const a=await spGet(`artists?ids=${artistIds.slice(0,3).join(',')}`);if(a?.artists)genres=a.artists.flatMap(x=>x.genres||[]).slice(0,8);}catch{}
  const streakDesc=sessionStreak<3?'early session':sessionStreak<6?'warmed up — go wilder':sessionStreak<10?'deep session — darker and more extreme':sessionStreak<15?'long session — full maximalist chaos':'marathon — most extreme worlds, nothing held back';
  const shortlist=getSceneShortlist();
  try{
    const r=await fetch('/api/theme',{method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({trackName:name,artistName:artist,genres,titleKeywords:extractKW(name),artistContext:getArtistCtx(artist)||`Genres: ${genres.join(', ')}`,sceneShortlist:shortlist,forbiddenCenterpieces:getForbidCPs(),availableCenterpieces:ALL_CPS.filter(x=>!getForbidCPs().includes(x)).join(', '),sessionStreak,streakDesc,isExplicit:!!isExplicit,songDurationSecs:Math.round((durationMs||180000)/1000)})});
    if(!r.ok)throw new Error('HTTP '+r.status);
    const raw=await r.json();if(raw.error)throw new Error(raw.error);
    const VALID_BEH=['rotate','spin_fast','pulse_beat','breathe','orbit_slow','rise_set','fixed','strobe','bounce','drift','watermark'];
    const VALID_BEATS=['speed_burst','shockwave','color_invert','world_crack','bass_slam','strobe_cut','creature_surge','cannon_fire','lightning_strike','gravity_wave','petal_burst','pixel_explode','skull_surge','coin_shower','tentacle_surge'];
    const scene=enforceScene((raw.scene||shortlist[0]||'WARP_SPEED').toUpperCase().replace(/ /g,'_'),shortlist);
    const cp=enforceCP(raw.centerpiece);
    const reactions=(raw.beatReactions||['shockwave']).filter(r2=>VALID_BEATS.includes(r2)).slice(0,4);
    const cpX=Math.min(0.9,Math.max(0.1,parseFloat(raw.centerpieceX)||0.5));
    const cpY=Math.min(0.9,Math.max(0.1,parseFloat(raw.centerpieceY)||0.5));
    const theme={scene,label:raw.label||'',splashDesc:raw.splashDesc||'',palette:Array.isArray(raw.palette)&&raw.palette.length===4?raw.palette:['#ff006e','#8338ec','#06ffd8','#ffbe0b'],bgColor:raw.bgColor||'#000010',centerpiece:cp,centerpieceScale:Math.min(1.5,Math.max(0,parseFloat(raw.centerpieceScale)||0.5)),centerpieceX:cpX,centerpieceY:cpY,centerpieceBehavior:VALID_BEH.includes(raw.centerpieceBehavior)?raw.centerpieceBehavior:'rotate',beatReactions:reactions.length?reactions:['shockwave'],sceneSpeed:Math.min(3,Math.max(0.3,parseFloat(raw.sceneSpeed)||1)),sceneIntensity:Math.min(1,Math.max(0,parseFloat(raw.sceneIntensity)||0.7)),energy:Math.min(1,Math.max(0,parseFloat(raw.energy)||0.5)),chaos:Math.min(1,Math.max(0,parseFloat(raw.chaos)||0.4))};
    recordScene(scene);recordCP(cp);
    aiCache[tid]=theme;applyTheme(name,artist,theme);
  }catch(e){console.error('[AI]',e);}
}
function applyTheme(name,artist,theme){
  document.getElementById('sceneTag').textContent=(theme.scene||'—').replace(/_/g,' ')+' — '+(theme.label||'');
  transition(name,artist,theme);
}

// ═══ SPOTIFY API ═══
async function spGet(ep){
  const r=await fetch('https://api.spotify.com/v1/'+ep,{headers:{Authorization:'Bearer '+token}});
  if(r.status===401){const nt=await refreshAT();if(nt)token=nt;else{logout();return null;}}
  if(!r.ok||r.status===204)return null;
  try{return await r.json()}catch{return null}
}
async function poll(){
  const d=await spGet('me/player/currently-playing');
  if(!d?.item)return;
  const tr=d.item,tid=tr.id;
  MS.progress=d.progress_ms||0;MS.duration=tr.duration_ms||180000;MS.analysisStart=Date.now()-MS.progress;
  MS.beatInterval=500;MS.energy=d.is_playing?0.6:0.3;
  if(tid!==lastTid){
    lastTid=tid;
    document.getElementById('trackName').textContent=tr.name;
    document.getElementById('artistName').textContent=tr.artists.map(a=>a.name).join(', ');
    const art=tr.album?.images?.[0]?.url;if(art)document.getElementById('albumArt').src=art;
    loadTheme(tid,tr.name,tr.artists.map(a=>a.name).join(', '),tr.artists.map(a=>a.id),tr.explicit,tr.duration_ms);
  }
}

// ═══ INIT ═══
document.getElementById('loginBtn').addEventListener('click',doLogin);
document.getElementById('fsBtn').addEventListener('click',()=>{if(!document.fullscreenElement){document.documentElement.requestFullscreen();document.getElementById('fsBtn').textContent='✕ EXIT';}else{document.exitFullscreen();document.getElementById('fsBtn').textContent='⛶ FS';}});

async function init(){
  const p=new URLSearchParams(location.search),code=p.get('code');
  console.log('[auth] init — code='+(code?'present':'none'));
  if(p.get('error')){showErr('Spotify error: '+p.get('error'));return;}
  if(code){
    history.replaceState({},document.title,'/');
    token=await exchToken(code);
    if(!token)return;
  }else{
    token=getAT();
    if(!token)token=await refreshAT();
    console.log('[auth] stored token: '+(token?'found':'none'));
  }
  if(token){
    document.getElementById('login').style.display='none';
    document.getElementById('ui').style.display='block';
    document.getElementById('fsBtn').style.display='block';
    initScene();
    poll();
    setInterval(poll,5000);
  }
}
init();
</script>
</body>
</html>
